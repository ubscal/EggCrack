
--Converted with ttyyuu12345's model to script plugin v4
function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Model0 = Instance.new("Model")
Model1 = Instance.new("Model")
Part2 = Instance.new("Part")
SurfaceGui3 = Instance.new("SurfaceGui")
Frame4 = Instance.new("Frame")
TextButton5 = Instance.new("TextButton")
TextButton6 = Instance.new("TextButton")
TextButton7 = Instance.new("TextButton")
TextButton8 = Instance.new("TextButton")
TextButton9 = Instance.new("TextButton")
Script10 = Instance.new("Script")
Script11 = Instance.new("Script")
TextButton12 = Instance.new("TextButton")
TextButton13 = Instance.new("TextButton")
TextButton14 = Instance.new("TextButton")
TextButton15 = Instance.new("TextButton")
Frame16 = Instance.new("Frame")
TextButton17 = Instance.new("TextButton")
TextButton18 = Instance.new("TextButton")
TextButton19 = Instance.new("TextButton")
TextButton20 = Instance.new("TextButton")
TextButton21 = Instance.new("TextButton")
TextButton22 = Instance.new("TextButton")
Frame23 = Instance.new("Frame")
TextButton24 = Instance.new("TextButton")
TextButton25 = Instance.new("TextButton")
TextButton26 = Instance.new("TextButton")
Frame27 = Instance.new("Frame")
TextButton28 = Instance.new("TextButton")
TextButton29 = Instance.new("TextButton")
TextButton30 = Instance.new("TextButton")
Frame31 = Instance.new("Frame")
TextButton32 = Instance.new("TextButton")
TextButton33 = Instance.new("TextButton")
TextButton34 = Instance.new("TextButton")
TextButton35 = Instance.new("TextButton")
TextButton36 = Instance.new("TextButton")
TextButton37 = Instance.new("TextButton")
Script38 = Instance.new("Script")
TextButton39 = Instance.new("TextButton")
TextButton40 = Instance.new("TextButton")
TextButton41 = Instance.new("TextButton")
TextButton42 = Instance.new("TextButton")
TextButton43 = Instance.new("TextButton")
Frame44 = Instance.new("Frame")
TextButton45 = Instance.new("TextButton")
TextButton46 = Instance.new("TextButton")
TextButton47 = Instance.new("TextButton")
TextButton48 = Instance.new("TextButton")
TextButton49 = Instance.new("TextButton")
Frame50 = Instance.new("Frame")
TextButton51 = Instance.new("TextButton")
TextButton52 = Instance.new("TextButton")
TextButton53 = Instance.new("TextButton")
TextButton54 = Instance.new("TextButton")
TextButton55 = Instance.new("TextButton")
Frame56 = Instance.new("Frame")
TextLabel57 = Instance.new("TextLabel")
TextLabel58 = Instance.new("TextLabel")
TextLabel59 = Instance.new("TextLabel")
TextButton60 = Instance.new("TextButton")
Script61 = Instance.new("Script")
Model62 = Instance.new("Model")
Part63 = Instance.new("Part")
ManualWeld64 = Instance.new("ManualWeld")
ManualWeld65 = Instance.new("ManualWeld")
Part66 = Instance.new("Part")
Part67 = Instance.new("Part")
Tool68 = Instance.new("Tool")
LocalScript69 = Instance.new("LocalScript")
LocalScript70 = Instance.new("LocalScript")
LocalScript71 = Instance.new("LocalScript")
LocalScript72 = Instance.new("LocalScript")
LocalScript73 = Instance.new("LocalScript")
LocalScript74 = Instance.new("LocalScript")
LocalScript75 = Instance.new("LocalScript")
LocalScript76 = Instance.new("LocalScript")
LocalScript77 = Instance.new("LocalScript")
LocalScript78 = Instance.new("LocalScript")
LocalScript79 = Instance.new("LocalScript")
LocalScript80 = Instance.new("LocalScript")
LocalScript81 = Instance.new("LocalScript")
LocalScript82 = Instance.new("LocalScript")
LocalScript83 = Instance.new("LocalScript")
RemoteFunction84 = Instance.new("RemoteFunction")
Script85 = Instance.new("Script")
RemoteFunction86 = Instance.new("RemoteFunction")
Script87 = Instance.new("Script")
LocalScript88 = Instance.new("LocalScript")
Part89 = Instance.new("Part")
Decal90 = Instance.new("Decal")
Decal91 = Instance.new("Decal")
Decal92 = Instance.new("Decal")
Decal93 = Instance.new("Decal")
Decal94 = Instance.new("Decal")
Decal95 = Instance.new("Decal")
Camera96 = Instance.new("Camera")
Frame97 = Instance.new("Frame")
Frame98 = Instance.new("Frame")
Frame99 = Instance.new("Frame")
Frame100 = Instance.new("Frame")
TextLabel101 = Instance.new("TextLabel")
TextLabel102 = Instance.new("TextLabel")
Frame103 = Instance.new("Frame")
TextLabel104 = Instance.new("TextLabel")
Frame105 = Instance.new("Frame")
Frame106 = Instance.new("Frame")
TextButton107 = Instance.new("TextButton")
ImageLabel108 = Instance.new("ImageLabel")
TextLabel109 = Instance.new("TextLabel")
Frame110 = Instance.new("Frame")
Frame111 = Instance.new("Frame")
TextButton112 = Instance.new("TextButton")
ImageLabel113 = Instance.new("ImageLabel")
TextLabel114 = Instance.new("TextLabel")
Frame115 = Instance.new("Frame")
Frame116 = Instance.new("Frame")
TextLabel117 = Instance.new("TextLabel")
Frame118 = Instance.new("Frame")
Frame119 = Instance.new("Frame")
Frame120 = Instance.new("Frame")
TextLabel121 = Instance.new("TextLabel")
TextLabel122 = Instance.new("TextLabel")
Frame123 = Instance.new("Frame")
TextLabel124 = Instance.new("TextLabel")
Frame125 = Instance.new("Frame")
Frame126 = Instance.new("Frame")
TextButton127 = Instance.new("TextButton")
ImageLabel128 = Instance.new("ImageLabel")
TextLabel129 = Instance.new("TextLabel")
Frame130 = Instance.new("Frame")
Frame131 = Instance.new("Frame")
TextButton132 = Instance.new("TextButton")
ImageLabel133 = Instance.new("ImageLabel")
TextLabel134 = Instance.new("TextLabel")
Frame135 = Instance.new("Frame")
Frame136 = Instance.new("Frame")
TextLabel137 = Instance.new("TextLabel")
Frame138 = Instance.new("Frame")
Frame139 = Instance.new("Frame")
TextLabel140 = Instance.new("TextLabel")
TextLabel141 = Instance.new("TextLabel")
Frame142 = Instance.new("Frame")
Frame143 = Instance.new("Frame")
Frame144 = Instance.new("Frame")
Frame145 = Instance.new("Frame")
Frame146 = Instance.new("Frame")
Frame147 = Instance.new("Frame")
Frame148 = Instance.new("Frame")
TextLabel149 = Instance.new("TextLabel")
Frame150 = Instance.new("Frame")
Frame151 = Instance.new("Frame")
Frame152 = Instance.new("Frame")
Frame153 = Instance.new("Frame")
Frame154 = Instance.new("Frame")
Frame155 = Instance.new("Frame")
Frame156 = Instance.new("Frame")
TextButton157 = Instance.new("TextButton")
Frame158 = Instance.new("Frame")
Frame159 = Instance.new("Frame")
Frame160 = Instance.new("Frame")
Frame161 = Instance.new("Frame")
Frame162 = Instance.new("Frame")
Frame163 = Instance.new("Frame")
Frame164 = Instance.new("Frame")
Frame165 = Instance.new("Frame")
TextLabel166 = Instance.new("TextLabel")
Frame167 = Instance.new("Frame")
Frame168 = Instance.new("Frame")
Frame169 = Instance.new("Frame")
Frame170 = Instance.new("Frame")
Frame171 = Instance.new("Frame")
Frame172 = Instance.new("Frame")
TextButton173 = Instance.new("TextButton")
Frame174 = Instance.new("Frame")
Frame175 = Instance.new("Frame")
Frame176 = Instance.new("Frame")
Frame177 = Instance.new("Frame")
TextLabel178 = Instance.new("TextLabel")
TextLabel179 = Instance.new("TextLabel")
Frame180 = Instance.new("Frame")
TextLabel181 = Instance.new("TextLabel")
Frame182 = Instance.new("Frame")
TextLabel183 = Instance.new("TextLabel")
Frame184 = Instance.new("Frame")
TextButton185 = Instance.new("TextButton")
ImageLabel186 = Instance.new("ImageLabel")
Frame187 = Instance.new("Frame")
TextBox188 = Instance.new("TextBox")
Frame189 = Instance.new("Frame")
TextLabel190 = Instance.new("TextLabel")
Frame191 = Instance.new("Frame")
TextButton192 = Instance.new("TextButton")
Frame193 = Instance.new("Frame")
ImageLabel194 = Instance.new("ImageLabel")
TextBox195 = Instance.new("TextBox")
Frame196 = Instance.new("Frame")
Frame197 = Instance.new("Frame")
TextLabel198 = Instance.new("TextLabel")
Frame199 = Instance.new("Frame")
Frame200 = Instance.new("Frame")
Frame201 = Instance.new("Frame")
Frame202 = Instance.new("Frame")
TextButton203 = Instance.new("TextButton")
ImageLabel204 = Instance.new("ImageLabel")
TextLabel205 = Instance.new("TextLabel")
Frame206 = Instance.new("Frame")
Frame207 = Instance.new("Frame")
TextButton208 = Instance.new("TextButton")
ImageLabel209 = Instance.new("ImageLabel")
TextLabel210 = Instance.new("TextLabel")
Frame211 = Instance.new("Frame")
Frame212 = Instance.new("Frame")
TextButton213 = Instance.new("TextButton")
ImageLabel214 = Instance.new("ImageLabel")
TextLabel215 = Instance.new("TextLabel")
Frame216 = Instance.new("Frame")
TextLabel217 = Instance.new("TextLabel")
Frame218 = Instance.new("Frame")
Frame219 = Instance.new("Frame")
TextLabel220 = Instance.new("TextLabel")
TextLabel221 = Instance.new("TextLabel")
Frame222 = Instance.new("Frame")
Frame223 = Instance.new("Frame")
Frame224 = Instance.new("Frame")
TextBox225 = Instance.new("TextBox")
ImageLabel226 = Instance.new("ImageLabel")
Frame227 = Instance.new("Frame")
TextLabel228 = Instance.new("TextLabel")
Frame229 = Instance.new("Frame")
Frame230 = Instance.new("Frame")
TextLabel231 = Instance.new("TextLabel")
Frame232 = Instance.new("Frame")
TextLabel233 = Instance.new("TextLabel")
Frame234 = Instance.new("Frame")
ImageLabel235 = Instance.new("ImageLabel")
TextButton236 = Instance.new("TextButton")
TextBox237 = Instance.new("TextBox")
Frame238 = Instance.new("Frame")
ImageLabel239 = Instance.new("ImageLabel")
TextBox240 = Instance.new("TextBox")
TextButton241 = Instance.new("TextButton")
Frame242 = Instance.new("Frame")
TextBox243 = Instance.new("TextBox")
TextButton244 = Instance.new("TextButton")
ImageLabel245 = Instance.new("ImageLabel")
Frame246 = Instance.new("Frame")
Frame247 = Instance.new("Frame")
TextLabel248 = Instance.new("TextLabel")
Frame249 = Instance.new("Frame")
Frame250 = Instance.new("Frame")
Frame251 = Instance.new("Frame")
TextLabel252 = Instance.new("TextLabel")
TextLabel253 = Instance.new("TextLabel")
Frame254 = Instance.new("Frame")
TextLabel255 = Instance.new("TextLabel")
Frame256 = Instance.new("Frame")
Frame257 = Instance.new("Frame")
TextLabel258 = Instance.new("TextLabel")
Frame259 = Instance.new("Frame")
Frame260 = Instance.new("Frame")
Frame261 = Instance.new("Frame")
TextLabel262 = Instance.new("TextLabel")
TextLabel263 = Instance.new("TextLabel")
Frame264 = Instance.new("Frame")
TextButton265 = Instance.new("TextButton")
TextButton266 = Instance.new("TextButton")
TextButton267 = Instance.new("TextButton")
TextButton268 = Instance.new("TextButton")
TextButton269 = Instance.new("TextButton")
TextButton270 = Instance.new("TextButton")
TextButton271 = Instance.new("TextButton")
TextButton272 = Instance.new("TextButton")
TextButton273 = Instance.new("TextButton")
TextButton274 = Instance.new("TextButton")
TextButton275 = Instance.new("TextButton")
TextButton276 = Instance.new("TextButton")
TextButton277 = Instance.new("TextButton")
TextButton278 = Instance.new("TextButton")
TextButton279 = Instance.new("TextButton")
TextButton280 = Instance.new("TextButton")
TextButton281 = Instance.new("TextButton")
TextButton282 = Instance.new("TextButton")
TextButton283 = Instance.new("TextButton")
TextButton284 = Instance.new("TextButton")
TextButton285 = Instance.new("TextButton")
TextButton286 = Instance.new("TextButton")
TextButton287 = Instance.new("TextButton")
TextButton288 = Instance.new("TextButton")
TextButton289 = Instance.new("TextButton")
TextButton290 = Instance.new("TextButton")
TextButton291 = Instance.new("TextButton")
TextButton292 = Instance.new("TextButton")
TextButton293 = Instance.new("TextButton")
TextButton294 = Instance.new("TextButton")
TextButton295 = Instance.new("TextButton")
TextButton296 = Instance.new("TextButton")
TextButton297 = Instance.new("TextButton")
TextButton298 = Instance.new("TextButton")
TextButton299 = Instance.new("TextButton")
TextButton300 = Instance.new("TextButton")
TextButton301 = Instance.new("TextButton")
TextButton302 = Instance.new("TextButton")
TextButton303 = Instance.new("TextButton")
TextButton304 = Instance.new("TextButton")
TextButton305 = Instance.new("TextButton")
TextButton306 = Instance.new("TextButton")
TextButton307 = Instance.new("TextButton")
TextButton308 = Instance.new("TextButton")
TextButton309 = Instance.new("TextButton")
TextButton310 = Instance.new("TextButton")
TextButton311 = Instance.new("TextButton")
TextButton312 = Instance.new("TextButton")
TextButton313 = Instance.new("TextButton")
TextButton314 = Instance.new("TextButton")
TextButton315 = Instance.new("TextButton")
TextButton316 = Instance.new("TextButton")
TextButton317 = Instance.new("TextButton")
TextButton318 = Instance.new("TextButton")
TextButton319 = Instance.new("TextButton")
TextButton320 = Instance.new("TextButton")
TextButton321 = Instance.new("TextButton")
TextButton322 = Instance.new("TextButton")
TextButton323 = Instance.new("TextButton")
TextButton324 = Instance.new("TextButton")
TextButton325 = Instance.new("TextButton")
TextButton326 = Instance.new("TextButton")
TextButton327 = Instance.new("TextButton")
TextButton328 = Instance.new("TextButton")
Frame329 = Instance.new("Frame")
Frame330 = Instance.new("Frame")
Frame331 = Instance.new("Frame")
Frame332 = Instance.new("Frame")
TextButton333 = Instance.new("TextButton")
ImageLabel334 = Instance.new("ImageLabel")
TextLabel335 = Instance.new("TextLabel")
Frame336 = Instance.new("Frame")
Frame337 = Instance.new("Frame")
TextButton338 = Instance.new("TextButton")
ImageLabel339 = Instance.new("ImageLabel")
TextLabel340 = Instance.new("TextLabel")
Frame341 = Instance.new("Frame")
TextLabel342 = Instance.new("TextLabel")
Frame343 = Instance.new("Frame")
Frame344 = Instance.new("Frame")
TextLabel345 = Instance.new("TextLabel")
TextLabel346 = Instance.new("TextLabel")
Frame347 = Instance.new("Frame")
Frame348 = Instance.new("Frame")
Frame349 = Instance.new("Frame")
TextBox350 = Instance.new("TextBox")
ImageLabel351 = Instance.new("ImageLabel")
Frame352 = Instance.new("Frame")
TextLabel353 = Instance.new("TextLabel")
Frame354 = Instance.new("Frame")
Frame355 = Instance.new("Frame")
TextLabel356 = Instance.new("TextLabel")
Frame357 = Instance.new("Frame")
TextLabel358 = Instance.new("TextLabel")
Frame359 = Instance.new("Frame")
TextBox360 = Instance.new("TextBox")
TextButton361 = Instance.new("TextButton")
ImageLabel362 = Instance.new("ImageLabel")
Frame363 = Instance.new("Frame")
TextBox364 = Instance.new("TextBox")
TextButton365 = Instance.new("TextButton")
ImageLabel366 = Instance.new("ImageLabel")
Frame367 = Instance.new("Frame")
TextBox368 = Instance.new("TextBox")
TextButton369 = Instance.new("TextButton")
ImageLabel370 = Instance.new("ImageLabel")
Frame371 = Instance.new("Frame")
Frame372 = Instance.new("Frame")
TextLabel373 = Instance.new("TextLabel")
Frame374 = Instance.new("Frame")
Frame375 = Instance.new("Frame")
Frame376 = Instance.new("Frame")
Frame377 = Instance.new("Frame")
TextButton378 = Instance.new("TextButton")
ImageLabel379 = Instance.new("ImageLabel")
TextLabel380 = Instance.new("TextLabel")
Frame381 = Instance.new("Frame")
Frame382 = Instance.new("Frame")
TextButton383 = Instance.new("TextButton")
ImageLabel384 = Instance.new("ImageLabel")
TextLabel385 = Instance.new("TextLabel")
Frame386 = Instance.new("Frame")
Frame387 = Instance.new("Frame")
TextButton388 = Instance.new("TextButton")
ImageLabel389 = Instance.new("ImageLabel")
TextLabel390 = Instance.new("TextLabel")
Frame391 = Instance.new("Frame")
TextLabel392 = Instance.new("TextLabel")
Frame393 = Instance.new("Frame")
Frame394 = Instance.new("Frame")
TextLabel395 = Instance.new("TextLabel")
TextLabel396 = Instance.new("TextLabel")
Frame397 = Instance.new("Frame")
Frame398 = Instance.new("Frame")
Frame399 = Instance.new("Frame")
TextBox400 = Instance.new("TextBox")
ImageLabel401 = Instance.new("ImageLabel")
Frame402 = Instance.new("Frame")
TextLabel403 = Instance.new("TextLabel")
Frame404 = Instance.new("Frame")
Frame405 = Instance.new("Frame")
TextLabel406 = Instance.new("TextLabel")
Frame407 = Instance.new("Frame")
TextLabel408 = Instance.new("TextLabel")
Frame409 = Instance.new("Frame")
TextBox410 = Instance.new("TextBox")
TextButton411 = Instance.new("TextButton")
ImageLabel412 = Instance.new("ImageLabel")
Frame413 = Instance.new("Frame")
TextBox414 = Instance.new("TextBox")
TextButton415 = Instance.new("TextButton")
ImageLabel416 = Instance.new("ImageLabel")
Frame417 = Instance.new("Frame")
TextBox418 = Instance.new("TextBox")
TextButton419 = Instance.new("TextButton")
ImageLabel420 = Instance.new("ImageLabel")
Frame421 = Instance.new("Frame")
Frame422 = Instance.new("Frame")
TextLabel423 = Instance.new("TextLabel")
TextLabel424 = Instance.new("TextLabel")
Frame425 = Instance.new("Frame")
Frame426 = Instance.new("Frame")
Frame427 = Instance.new("Frame")
TextLabel428 = Instance.new("TextLabel")
TextLabel429 = Instance.new("TextLabel")
Frame430 = Instance.new("Frame")
TextLabel431 = Instance.new("TextLabel")
Frame432 = Instance.new("Frame")
TextLabel433 = Instance.new("TextLabel")
Frame434 = Instance.new("Frame")
Frame435 = Instance.new("Frame")
TextLabel436 = Instance.new("TextLabel")
Frame437 = Instance.new("Frame")
Frame438 = Instance.new("Frame")
Frame439 = Instance.new("Frame")
TextLabel440 = Instance.new("TextLabel")
TextLabel441 = Instance.new("TextLabel")
Frame442 = Instance.new("Frame")
TextLabel443 = Instance.new("TextLabel")
Frame444 = Instance.new("Frame")
TextLabel445 = Instance.new("TextLabel")
Frame446 = Instance.new("Frame")
TextButton447 = Instance.new("TextButton")
ImageLabel448 = Instance.new("ImageLabel")
Frame449 = Instance.new("Frame")
TextBox450 = Instance.new("TextBox")
Frame451 = Instance.new("Frame")
TextButton452 = Instance.new("TextButton")
ImageLabel453 = Instance.new("ImageLabel")
Frame454 = Instance.new("Frame")
TextBox455 = Instance.new("TextBox")
Frame456 = Instance.new("Frame")
Frame457 = Instance.new("Frame")
TextLabel458 = Instance.new("TextLabel")
Frame459 = Instance.new("Frame")
TextButton460 = Instance.new("TextButton")
ImageLabel461 = Instance.new("ImageLabel")
Frame462 = Instance.new("Frame")
TextBox463 = Instance.new("TextBox")
Frame464 = Instance.new("Frame")
TextLabel465 = Instance.new("TextLabel")
Frame466 = Instance.new("Frame")
Frame467 = Instance.new("Frame")
TextButton468 = Instance.new("TextButton")
ImageLabel469 = Instance.new("ImageLabel")
TextLabel470 = Instance.new("TextLabel")
Frame471 = Instance.new("Frame")
TextButton472 = Instance.new("TextButton")
ImageLabel473 = Instance.new("ImageLabel")
TextLabel474 = Instance.new("TextLabel")
Frame475 = Instance.new("Frame")
Frame476 = Instance.new("Frame")
TextLabel477 = Instance.new("TextLabel")
Frame478 = Instance.new("Frame")
Frame479 = Instance.new("Frame")
Frame480 = Instance.new("Frame")
Frame481 = Instance.new("Frame")
Frame482 = Instance.new("Frame")
TextButton483 = Instance.new("TextButton")
TextBox484 = Instance.new("TextBox")
Frame485 = Instance.new("Frame")
TextButton486 = Instance.new("TextButton")
Frame487 = Instance.new("Frame")
Frame488 = Instance.new("Frame")
TextButton489 = Instance.new("TextButton")
Frame490 = Instance.new("Frame")
TextLabel491 = Instance.new("TextLabel")
Frame492 = Instance.new("Frame")
Frame493 = Instance.new("Frame")
Frame494 = Instance.new("Frame")
TextLabel495 = Instance.new("TextLabel")
TextLabel496 = Instance.new("TextLabel")
Frame497 = Instance.new("Frame")
TextButton498 = Instance.new("TextButton")
Frame499 = Instance.new("Frame")
TextButton500 = Instance.new("TextButton")
Frame501 = Instance.new("Frame")
Frame502 = Instance.new("Frame")
Frame503 = Instance.new("Frame")
TextLabel504 = Instance.new("TextLabel")
Frame505 = Instance.new("Frame")
Frame506 = Instance.new("Frame")
Frame507 = Instance.new("Frame")
Frame508 = Instance.new("Frame")
TextLabel509 = Instance.new("TextLabel")
TextLabel510 = Instance.new("TextLabel")
Frame511 = Instance.new("Frame")
TextLabel512 = Instance.new("TextLabel")
ImageButton513 = Instance.new("ImageButton")
Frame514 = Instance.new("Frame")
TextButton515 = Instance.new("TextButton")
TextButton516 = Instance.new("TextButton")
Frame517 = Instance.new("Frame")
Frame518 = Instance.new("Frame")
Frame519 = Instance.new("Frame")
TextLabel520 = Instance.new("TextLabel")
Frame521 = Instance.new("Frame")
TextButton522 = Instance.new("TextButton")
ImageLabel523 = Instance.new("ImageLabel")
Frame524 = Instance.new("Frame")
TextBox525 = Instance.new("TextBox")
Frame526 = Instance.new("Frame")
TextButton527 = Instance.new("TextButton")
ImageLabel528 = Instance.new("ImageLabel")
Frame529 = Instance.new("Frame")
TextBox530 = Instance.new("TextBox")
Frame531 = Instance.new("Frame")
TextButton532 = Instance.new("TextButton")
ImageLabel533 = Instance.new("ImageLabel")
Frame534 = Instance.new("Frame")
TextBox535 = Instance.new("TextBox")
ImageButton536 = Instance.new("ImageButton")
Frame537 = Instance.new("Frame")
Frame538 = Instance.new("Frame")
Frame539 = Instance.new("Frame")
Frame540 = Instance.new("Frame")
Frame541 = Instance.new("Frame")
TextLabel542 = Instance.new("TextLabel")
Frame543 = Instance.new("Frame")
TextButton544 = Instance.new("TextButton")
ImageLabel545 = Instance.new("ImageLabel")
Frame546 = Instance.new("Frame")
TextBox547 = Instance.new("TextBox")
Frame548 = Instance.new("Frame")
TextLabel549 = Instance.new("TextLabel")
Frame550 = Instance.new("Frame")
TextButton551 = Instance.new("TextButton")
ImageLabel552 = Instance.new("ImageLabel")
Frame553 = Instance.new("Frame")
TextBox554 = Instance.new("TextBox")
Frame555 = Instance.new("Frame")
TextLabel556 = Instance.new("TextLabel")
Frame557 = Instance.new("Frame")
TextButton558 = Instance.new("TextButton")
ImageLabel559 = Instance.new("ImageLabel")
Frame560 = Instance.new("Frame")
TextBox561 = Instance.new("TextBox")
Frame562 = Instance.new("Frame")
TextLabel563 = Instance.new("TextLabel")
Frame564 = Instance.new("Frame")
TextLabel565 = Instance.new("TextLabel")
Frame566 = Instance.new("Frame")
Frame567 = Instance.new("Frame")
TextButton568 = Instance.new("TextButton")
ImageLabel569 = Instance.new("ImageLabel")
TextLabel570 = Instance.new("TextLabel")
Frame571 = Instance.new("Frame")
Frame572 = Instance.new("Frame")
TextButton573 = Instance.new("TextButton")
ImageLabel574 = Instance.new("ImageLabel")
TextLabel575 = Instance.new("TextLabel")
TextLabel576 = Instance.new("TextLabel")
Frame577 = Instance.new("Frame")
TextLabel578 = Instance.new("TextLabel")
ImageButton579 = Instance.new("ImageButton")
Frame580 = Instance.new("Frame")
TextButton581 = Instance.new("TextButton")
TextButton582 = Instance.new("TextButton")
Frame583 = Instance.new("Frame")
Frame584 = Instance.new("Frame")
Frame585 = Instance.new("Frame")
TextLabel586 = Instance.new("TextLabel")
Frame587 = Instance.new("Frame")
TextButton588 = Instance.new("TextButton")
ImageLabel589 = Instance.new("ImageLabel")
Frame590 = Instance.new("Frame")
TextBox591 = Instance.new("TextBox")
Frame592 = Instance.new("Frame")
TextButton593 = Instance.new("TextButton")
ImageLabel594 = Instance.new("ImageLabel")
Frame595 = Instance.new("Frame")
TextBox596 = Instance.new("TextBox")
Frame597 = Instance.new("Frame")
TextButton598 = Instance.new("TextButton")
ImageLabel599 = Instance.new("ImageLabel")
Frame600 = Instance.new("Frame")
TextBox601 = Instance.new("TextBox")
ImageButton602 = Instance.new("ImageButton")
Frame603 = Instance.new("Frame")
Frame604 = Instance.new("Frame")
Frame605 = Instance.new("Frame")
Frame606 = Instance.new("Frame")
Frame607 = Instance.new("Frame")
TextLabel608 = Instance.new("TextLabel")
Frame609 = Instance.new("Frame")
TextButton610 = Instance.new("TextButton")
ImageLabel611 = Instance.new("ImageLabel")
Frame612 = Instance.new("Frame")
TextBox613 = Instance.new("TextBox")
Frame614 = Instance.new("Frame")
TextLabel615 = Instance.new("TextLabel")
Frame616 = Instance.new("Frame")
TextButton617 = Instance.new("TextButton")
ImageLabel618 = Instance.new("ImageLabel")
Frame619 = Instance.new("Frame")
TextBox620 = Instance.new("TextBox")
Frame621 = Instance.new("Frame")
TextLabel622 = Instance.new("TextLabel")
Frame623 = Instance.new("Frame")
Frame624 = Instance.new("Frame")
TextButton625 = Instance.new("TextButton")
ImageLabel626 = Instance.new("ImageLabel")
TextLabel627 = Instance.new("TextLabel")
Frame628 = Instance.new("Frame")
Frame629 = Instance.new("Frame")
TextButton630 = Instance.new("TextButton")
ImageLabel631 = Instance.new("ImageLabel")
TextLabel632 = Instance.new("TextLabel")
Frame633 = Instance.new("Frame")
ImageButton634 = Instance.new("ImageButton")
ImageLabel635 = Instance.new("ImageLabel")
ImageButton636 = Instance.new("ImageButton")
Frame637 = Instance.new("Frame")
ImageLabel638 = Instance.new("ImageLabel")
Frame639 = Instance.new("Frame")
TextLabel640 = Instance.new("TextLabel")
Frame641 = Instance.new("Frame")
TextButton642 = Instance.new("TextButton")
ImageLabel643 = Instance.new("ImageLabel")
TextBox644 = Instance.new("TextBox")
Frame645 = Instance.new("Frame")
Frame646 = Instance.new("Frame")
Frame647 = Instance.new("Frame")
TextLabel648 = Instance.new("TextLabel")
Frame649 = Instance.new("Frame")
TextButton650 = Instance.new("TextButton")
ImageLabel651 = Instance.new("ImageLabel")
TextBox652 = Instance.new("TextBox")
Frame653 = Instance.new("Frame")
Frame654 = Instance.new("Frame")
Frame655 = Instance.new("Frame")
TextLabel656 = Instance.new("TextLabel")
Frame657 = Instance.new("Frame")
TextButton658 = Instance.new("TextButton")
ImageLabel659 = Instance.new("ImageLabel")
TextBox660 = Instance.new("TextBox")
Frame661 = Instance.new("Frame")
Frame662 = Instance.new("Frame")
Frame663 = Instance.new("Frame")
Frame664 = Instance.new("Frame")
TextButton665 = Instance.new("TextButton")
Frame666 = Instance.new("Frame")
TextButton667 = Instance.new("TextButton")
Frame668 = Instance.new("Frame")
Frame669 = Instance.new("Frame")
Frame670 = Instance.new("Frame")
Frame671 = Instance.new("Frame")
TextLabel672 = Instance.new("TextLabel")
TextLabel673 = Instance.new("TextLabel")
Frame674 = Instance.new("Frame")
TextLabel675 = Instance.new("TextLabel")
Frame676 = Instance.new("Frame")
TextLabel677 = Instance.new("TextLabel")
Frame678 = Instance.new("Frame")
TextButton679 = Instance.new("TextButton")
ImageLabel680 = Instance.new("ImageLabel")
Frame681 = Instance.new("Frame")
TextBox682 = Instance.new("TextBox")
Frame683 = Instance.new("Frame")
TextButton684 = Instance.new("TextButton")
ImageLabel685 = Instance.new("ImageLabel")
Frame686 = Instance.new("Frame")
TextBox687 = Instance.new("TextBox")
Frame688 = Instance.new("Frame")
TextButton689 = Instance.new("TextButton")
ImageLabel690 = Instance.new("ImageLabel")
Frame691 = Instance.new("Frame")
TextBox692 = Instance.new("TextBox")
Frame693 = Instance.new("Frame")
TextButton694 = Instance.new("TextButton")
Frame695 = Instance.new("Frame")
Frame696 = Instance.new("Frame")
TextLabel697 = Instance.new("TextLabel")
TextBox698 = Instance.new("TextBox")
Frame699 = Instance.new("Frame")
Frame700 = Instance.new("Frame")
Frame701 = Instance.new("Frame")
Frame702 = Instance.new("Frame")
Frame703 = Instance.new("Frame")
TextButton704 = Instance.new("TextButton")
Frame705 = Instance.new("Frame")
Frame706 = Instance.new("Frame")
TextLabel707 = Instance.new("TextLabel")
TextBox708 = Instance.new("TextBox")
Frame709 = Instance.new("Frame")
Frame710 = Instance.new("Frame")
Frame711 = Instance.new("Frame")
Frame712 = Instance.new("Frame")
Frame713 = Instance.new("Frame")
TextButton714 = Instance.new("TextButton")
Frame715 = Instance.new("Frame")
TextButton716 = Instance.new("TextButton")
Frame717 = Instance.new("Frame")
Frame718 = Instance.new("Frame")
TextLabel719 = Instance.new("TextLabel")
Frame720 = Instance.new("Frame")
TextButton721 = Instance.new("TextButton")
ImageLabel722 = Instance.new("ImageLabel")
Frame723 = Instance.new("Frame")
TextBox724 = Instance.new("TextBox")
Frame725 = Instance.new("Frame")
TextButton726 = Instance.new("TextButton")
ImageLabel727 = Instance.new("ImageLabel")
Frame728 = Instance.new("Frame")
TextBox729 = Instance.new("TextBox")
Frame730 = Instance.new("Frame")
TextButton731 = Instance.new("TextButton")
ImageLabel732 = Instance.new("ImageLabel")
Frame733 = Instance.new("Frame")
TextBox734 = Instance.new("TextBox")
Frame735 = Instance.new("Frame")
Frame736 = Instance.new("Frame")
Frame737 = Instance.new("Frame")
ImageButton738 = Instance.new("ImageButton")
Frame739 = Instance.new("Frame")
TextLabel740 = Instance.new("TextLabel")
Frame741 = Instance.new("Frame")
Frame742 = Instance.new("Frame")
Frame743 = Instance.new("Frame")
Frame744 = Instance.new("Frame")
TextLabel745 = Instance.new("TextLabel")
TextLabel746 = Instance.new("TextLabel")
Frame747 = Instance.new("Frame")
TextLabel748 = Instance.new("TextLabel")
ImageButton749 = Instance.new("ImageButton")
Frame750 = Instance.new("Frame")
TextButton751 = Instance.new("TextButton")
TextButton752 = Instance.new("TextButton")
Frame753 = Instance.new("Frame")
Frame754 = Instance.new("Frame")
Frame755 = Instance.new("Frame")
TextLabel756 = Instance.new("TextLabel")
Frame757 = Instance.new("Frame")
TextButton758 = Instance.new("TextButton")
ImageLabel759 = Instance.new("ImageLabel")
Frame760 = Instance.new("Frame")
TextBox761 = Instance.new("TextBox")
Frame762 = Instance.new("Frame")
TextButton763 = Instance.new("TextButton")
ImageLabel764 = Instance.new("ImageLabel")
Frame765 = Instance.new("Frame")
TextBox766 = Instance.new("TextBox")
Frame767 = Instance.new("Frame")
TextButton768 = Instance.new("TextButton")
ImageLabel769 = Instance.new("ImageLabel")
Frame770 = Instance.new("Frame")
TextBox771 = Instance.new("TextBox")
ImageButton772 = Instance.new("ImageButton")
Frame773 = Instance.new("Frame")
Frame774 = Instance.new("Frame")
Frame775 = Instance.new("Frame")
Frame776 = Instance.new("Frame")
Frame777 = Instance.new("Frame")
TextLabel778 = Instance.new("TextLabel")
Frame779 = Instance.new("Frame")
TextButton780 = Instance.new("TextButton")
ImageLabel781 = Instance.new("ImageLabel")
Frame782 = Instance.new("Frame")
TextBox783 = Instance.new("TextBox")
Frame784 = Instance.new("Frame")
TextLabel785 = Instance.new("TextLabel")
Frame786 = Instance.new("Frame")
TextButton787 = Instance.new("TextButton")
ImageLabel788 = Instance.new("ImageLabel")
Frame789 = Instance.new("Frame")
TextBox790 = Instance.new("TextBox")
Frame791 = Instance.new("Frame")
TextLabel792 = Instance.new("TextLabel")
Frame793 = Instance.new("Frame")
TextButton794 = Instance.new("TextButton")
ImageLabel795 = Instance.new("ImageLabel")
Frame796 = Instance.new("Frame")
TextBox797 = Instance.new("TextBox")
TextLabel798 = Instance.new("TextLabel")
Frame799 = Instance.new("Frame")
TextLabel800 = Instance.new("TextLabel")
ImageButton801 = Instance.new("ImageButton")
Frame802 = Instance.new("Frame")
TextButton803 = Instance.new("TextButton")
TextButton804 = Instance.new("TextButton")
Frame805 = Instance.new("Frame")
Frame806 = Instance.new("Frame")
Frame807 = Instance.new("Frame")
TextLabel808 = Instance.new("TextLabel")
Frame809 = Instance.new("Frame")
TextButton810 = Instance.new("TextButton")
ImageLabel811 = Instance.new("ImageLabel")
Frame812 = Instance.new("Frame")
TextBox813 = Instance.new("TextBox")
Frame814 = Instance.new("Frame")
TextButton815 = Instance.new("TextButton")
ImageLabel816 = Instance.new("ImageLabel")
Frame817 = Instance.new("Frame")
TextBox818 = Instance.new("TextBox")
Frame819 = Instance.new("Frame")
TextButton820 = Instance.new("TextButton")
ImageLabel821 = Instance.new("ImageLabel")
Frame822 = Instance.new("Frame")
TextBox823 = Instance.new("TextBox")
ImageButton824 = Instance.new("ImageButton")
Frame825 = Instance.new("Frame")
Frame826 = Instance.new("Frame")
Frame827 = Instance.new("Frame")
Frame828 = Instance.new("Frame")
Frame829 = Instance.new("Frame")
TextLabel830 = Instance.new("TextLabel")
Frame831 = Instance.new("Frame")
TextButton832 = Instance.new("TextButton")
ImageLabel833 = Instance.new("ImageLabel")
Frame834 = Instance.new("Frame")
TextBox835 = Instance.new("TextBox")
Frame836 = Instance.new("Frame")
TextLabel837 = Instance.new("TextLabel")
Frame838 = Instance.new("Frame")
TextButton839 = Instance.new("TextButton")
ImageLabel840 = Instance.new("ImageLabel")
Frame841 = Instance.new("Frame")
TextBox842 = Instance.new("TextBox")
Frame843 = Instance.new("Frame")
TextLabel844 = Instance.new("TextLabel")
Frame845 = Instance.new("Frame")
TextButton846 = Instance.new("TextButton")
ImageLabel847 = Instance.new("ImageLabel")
Frame848 = Instance.new("Frame")
TextBox849 = Instance.new("TextBox")
Frame850 = Instance.new("Frame")
TextButton851 = Instance.new("TextButton")
ImageLabel852 = Instance.new("ImageLabel")
Frame853 = Instance.new("Frame")
TextBox854 = Instance.new("TextBox")
Frame855 = Instance.new("Frame")
TextButton856 = Instance.new("TextButton")
ImageLabel857 = Instance.new("ImageLabel")
Frame858 = Instance.new("Frame")
TextBox859 = Instance.new("TextBox")
ImageButton860 = Instance.new("ImageButton")
Frame861 = Instance.new("Frame")
Frame862 = Instance.new("Frame")
Frame863 = Instance.new("Frame")
Frame864 = Instance.new("Frame")
Frame865 = Instance.new("Frame")
TextLabel866 = Instance.new("TextLabel")
ImageButton867 = Instance.new("ImageButton")
Frame868 = Instance.new("Frame")
TextButton869 = Instance.new("TextButton")
TextButton870 = Instance.new("TextButton")
Frame871 = Instance.new("Frame")
Frame872 = Instance.new("Frame")
Frame873 = Instance.new("Frame")
TextLabel874 = Instance.new("TextLabel")
Frame875 = Instance.new("Frame")
TextButton876 = Instance.new("TextButton")
ImageLabel877 = Instance.new("ImageLabel")
Frame878 = Instance.new("Frame")
TextBox879 = Instance.new("TextBox")
Frame880 = Instance.new("Frame")
TextButton881 = Instance.new("TextButton")
ImageLabel882 = Instance.new("ImageLabel")
Frame883 = Instance.new("Frame")
TextBox884 = Instance.new("TextBox")
Frame885 = Instance.new("Frame")
TextButton886 = Instance.new("TextButton")
ImageLabel887 = Instance.new("ImageLabel")
Frame888 = Instance.new("Frame")
TextBox889 = Instance.new("TextBox")
ImageButton890 = Instance.new("ImageButton")
Frame891 = Instance.new("Frame")
Frame892 = Instance.new("Frame")
Frame893 = Instance.new("Frame")
Frame894 = Instance.new("Frame")
Frame895 = Instance.new("Frame")
Frame896 = Instance.new("Frame")
Frame897 = Instance.new("Frame")
Frame898 = Instance.new("Frame")
Frame899 = Instance.new("Frame")
Frame900 = Instance.new("Frame")
TextLabel901 = Instance.new("TextLabel")
TextLabel902 = Instance.new("TextLabel")
TextLabel903 = Instance.new("TextLabel")
TextLabel904 = Instance.new("TextLabel")
Frame905 = Instance.new("Frame")
TextLabel906 = Instance.new("TextLabel")
TextLabel907 = Instance.new("TextLabel")
Frame908 = Instance.new("Frame")
TextLabel909 = Instance.new("TextLabel")
TextLabel910 = Instance.new("TextLabel")
Frame911 = Instance.new("Frame")
Frame912 = Instance.new("Frame")
Frame913 = Instance.new("Frame")
TextLabel914 = Instance.new("TextLabel")
TextLabel915 = Instance.new("TextLabel")
Frame916 = Instance.new("Frame")
TextLabel917 = Instance.new("TextLabel")
TextLabel918 = Instance.new("TextLabel")
Frame919 = Instance.new("Frame")
TextLabel920 = Instance.new("TextLabel")
TextLabel921 = Instance.new("TextLabel")
Frame922 = Instance.new("Frame")
Frame923 = Instance.new("Frame")
Frame924 = Instance.new("Frame")
TextLabel925 = Instance.new("TextLabel")
TextLabel926 = Instance.new("TextLabel")
Frame927 = Instance.new("Frame")
Frame928 = Instance.new("Frame")
Frame929 = Instance.new("Frame")
TextLabel930 = Instance.new("TextLabel")
TextLabel931 = Instance.new("TextLabel")
Frame932 = Instance.new("Frame")
Frame933 = Instance.new("Frame")
Frame934 = Instance.new("Frame")
Frame935 = Instance.new("Frame")
TextLabel936 = Instance.new("TextLabel")
TextLabel937 = Instance.new("TextLabel")
TextLabel938 = Instance.new("TextLabel")
TextLabel939 = Instance.new("TextLabel")
Frame940 = Instance.new("Frame")
TextLabel941 = Instance.new("TextLabel")
TextLabel942 = Instance.new("TextLabel")
Frame943 = Instance.new("Frame")
TextLabel944 = Instance.new("TextLabel")
TextLabel945 = Instance.new("TextLabel")
Frame946 = Instance.new("Frame")
Frame947 = Instance.new("Frame")
Frame948 = Instance.new("Frame")
TextLabel949 = Instance.new("TextLabel")
TextLabel950 = Instance.new("TextLabel")
Frame951 = Instance.new("Frame")
Frame952 = Instance.new("Frame")
Frame953 = Instance.new("Frame")
TextLabel954 = Instance.new("TextLabel")
TextLabel955 = Instance.new("TextLabel")
Frame956 = Instance.new("Frame")
Frame957 = Instance.new("Frame")
Frame958 = Instance.new("Frame")
TextLabel959 = Instance.new("TextLabel")
TextLabel960 = Instance.new("TextLabel")
Frame961 = Instance.new("Frame")
Frame962 = Instance.new("Frame")
Frame963 = Instance.new("Frame")
TextLabel964 = Instance.new("TextLabel")
TextLabel965 = Instance.new("TextLabel")
Frame966 = Instance.new("Frame")
Frame967 = Instance.new("Frame")
Frame968 = Instance.new("Frame")
TextLabel969 = Instance.new("TextLabel")
TextLabel970 = Instance.new("TextLabel")
Frame971 = Instance.new("Frame")
Frame972 = Instance.new("Frame")
Frame973 = Instance.new("Frame")
TextLabel974 = Instance.new("TextLabel")
TextLabel975 = Instance.new("TextLabel")
Frame976 = Instance.new("Frame")
Frame977 = Instance.new("Frame")
Frame978 = Instance.new("Frame")
TextLabel979 = Instance.new("TextLabel")
TextLabel980 = Instance.new("TextLabel")
Frame981 = Instance.new("Frame")
Frame982 = Instance.new("Frame")
Frame983 = Instance.new("Frame")
TextLabel984 = Instance.new("TextLabel")
TextLabel985 = Instance.new("TextLabel")
Frame986 = Instance.new("Frame")
Frame987 = Instance.new("Frame")
Frame988 = Instance.new("Frame")
TextLabel989 = Instance.new("TextLabel")
TextLabel990 = Instance.new("TextLabel")
Frame991 = Instance.new("Frame")
TextLabel992 = Instance.new("TextLabel")
ImageButton993 = Instance.new("ImageButton")
Frame994 = Instance.new("Frame")
TextLabel995 = Instance.new("TextLabel")
Frame996 = Instance.new("Frame")
Frame997 = Instance.new("Frame")
ImageButton998 = Instance.new("ImageButton")
Frame999 = Instance.new("Frame")
TextLabel1000 = Instance.new("TextLabel")
ImageButton1001 = Instance.new("ImageButton")
Frame1002 = Instance.new("Frame")
TextLabel1003 = Instance.new("TextLabel")
ImageButton1004 = Instance.new("ImageButton")
Frame1005 = Instance.new("Frame")
TextLabel1006 = Instance.new("TextLabel")
ImageButton1007 = Instance.new("ImageButton")
Frame1008 = Instance.new("Frame")
TextLabel1009 = Instance.new("TextLabel")
ImageButton1010 = Instance.new("ImageButton")
Frame1011 = Instance.new("Frame")
TextLabel1012 = Instance.new("TextLabel")
Frame1013 = Instance.new("Frame")
ImageButton1014 = Instance.new("ImageButton")
TextLabel1015 = Instance.new("TextLabel")
ImageButton1016 = Instance.new("ImageButton")
TextLabel1017 = Instance.new("TextLabel")
ImageButton1018 = Instance.new("ImageButton")
TextLabel1019 = Instance.new("TextLabel")
ImageButton1020 = Instance.new("ImageButton")
TextLabel1021 = Instance.new("TextLabel")
ImageButton1022 = Instance.new("ImageButton")
TextLabel1023 = Instance.new("TextLabel")
ImageButton1024 = Instance.new("ImageButton")
TextLabel1025 = Instance.new("TextLabel")
ImageButton1026 = Instance.new("ImageButton")
TextLabel1027 = Instance.new("TextLabel")
ImageButton1028 = Instance.new("ImageButton")
TextLabel1029 = Instance.new("TextLabel")
ImageButton1030 = Instance.new("ImageButton")
TextLabel1031 = Instance.new("TextLabel")
ImageButton1032 = Instance.new("ImageButton")
TextLabel1033 = Instance.new("TextLabel")
ImageButton1034 = Instance.new("ImageButton")
TextLabel1035 = Instance.new("TextLabel")
ImageButton1036 = Instance.new("ImageButton")
TextLabel1037 = Instance.new("TextLabel")
ImageButton1038 = Instance.new("ImageButton")
TextLabel1039 = Instance.new("TextLabel")
ImageButton1040 = Instance.new("ImageButton")
TextLabel1041 = Instance.new("TextLabel")
Frame1042 = Instance.new("Frame")
Frame1043 = Instance.new("Frame")
Frame1044 = Instance.new("Frame")
Frame1045 = Instance.new("Frame")
Frame1046 = Instance.new("Frame")
Frame1047 = Instance.new("Frame")
Frame1048 = Instance.new("Frame")
Frame1049 = Instance.new("Frame")
TextLabel1050 = Instance.new("TextLabel")
Frame1051 = Instance.new("Frame")
Frame1052 = Instance.new("Frame")
Frame1053 = Instance.new("Frame")
Frame1054 = Instance.new("Frame")
Frame1055 = Instance.new("Frame")
Frame1056 = Instance.new("Frame")
TextLabel1057 = Instance.new("TextLabel")
Frame1058 = Instance.new("Frame")
TextLabel1059 = Instance.new("TextLabel")
TextLabel1060 = Instance.new("TextLabel")
Frame1061 = Instance.new("Frame")
TextLabel1062 = Instance.new("TextLabel")
TextLabel1063 = Instance.new("TextLabel")
Script1064 = Instance.new("Script")
Decal1065 = Instance.new("Decal")
Part1066 = Instance.new("Part")
Part1067 = Instance.new("Part")
Script1068 = Instance.new("Script")
Part1069 = Instance.new("Part")
SurfaceGui1070 = Instance.new("SurfaceGui")
Frame1071 = Instance.new("Frame")
Frame1072 = Instance.new("Frame")
TextButton1073 = Instance.new("TextButton")
TextButton1074 = Instance.new("TextButton")
Script1075 = Instance.new("Script")
ImageLabel1076 = Instance.new("ImageLabel")
Frame1077 = Instance.new("Frame")
TextButton1078 = Instance.new("TextButton")
Script1079 = Instance.new("Script")
Configuration1080 = Instance.new("Configuration")
ObjectValue1081 = Instance.new("ObjectValue")
ObjectValue1082 = Instance.new("ObjectValue")
ObjectValue1083 = Instance.new("ObjectValue")
ObjectValue1084 = Instance.new("ObjectValue")
ObjectValue1085 = Instance.new("ObjectValue")
ObjectValue1086 = Instance.new("ObjectValue")
ObjectValue1087 = Instance.new("ObjectValue")
ObjectValue1088 = Instance.new("ObjectValue")
ObjectValue1089 = Instance.new("ObjectValue")
ObjectValue1090 = Instance.new("ObjectValue")
Frame1091 = Instance.new("Frame")
TextButton1092 = Instance.new("TextButton")
TextButton1093 = Instance.new("TextButton")
Script1094 = Instance.new("Script")
ImageLabel1095 = Instance.new("ImageLabel")
Frame1096 = Instance.new("Frame")
TextButton1097 = Instance.new("TextButton")
Script1098 = Instance.new("Script")
Frame1099 = Instance.new("Frame")
TextButton1100 = Instance.new("TextButton")
TextButton1101 = Instance.new("TextButton")
Script1102 = Instance.new("Script")
ImageLabel1103 = Instance.new("ImageLabel")
Frame1104 = Instance.new("Frame")
TextButton1105 = Instance.new("TextButton")
Script1106 = Instance.new("Script")
Script1107 = Instance.new("Script")
TextButton1108 = Instance.new("TextButton")
Script1109 = Instance.new("Script")
Configuration1110 = Instance.new("Configuration")
LocalScript1111 = Instance.new("LocalScript")
LocalScript1112 = Instance.new("LocalScript")
LocalScript1113 = Instance.new("LocalScript")
LocalScript1114 = Instance.new("LocalScript")
StringValue1115 = Instance.new("StringValue")
StringValue1116 = Instance.new("StringValue")
LocalScript1117 = Instance.new("LocalScript")
LocalScript1118 = Instance.new("LocalScript")
LocalScript1119 = Instance.new("LocalScript")
LocalScript1120 = Instance.new("LocalScript")
Part1121 = Instance.new("Part")
ScreenGui1122 = Instance.new("ScreenGui")
Script1123 = Instance.new("Script")
TextButton1124 = Instance.new("TextButton")
LocalScript1125 = Instance.new("LocalScript")
Frame1126 = Instance.new("Frame")
TextLabel1127 = Instance.new("TextLabel")
TextButton1128 = Instance.new("TextButton")
LocalScript1129 = Instance.new("LocalScript")
BoolValue1130 = Instance.new("BoolValue")
Sound1131 = Instance.new("Sound")
Frame1132 = Instance.new("Frame")
TextButton1133 = Instance.new("TextButton")
LocalScript1134 = Instance.new("LocalScript")
Sound1135 = Instance.new("Sound")
TextBox1136 = Instance.new("TextBox")
Frame1137 = Instance.new("Frame")
StringValue1138 = Instance.new("StringValue")
LocalScript1139 = Instance.new("LocalScript")
TextLabel1140 = Instance.new("TextLabel")
TextButton1141 = Instance.new("TextButton")
LocalScript1142 = Instance.new("LocalScript")
Sound1143 = Instance.new("Sound")
TextButton1144 = Instance.new("TextButton")
LocalScript1145 = Instance.new("LocalScript")
Sound1146 = Instance.new("Sound")
Frame1147 = Instance.new("Frame")
TextButton1148 = Instance.new("TextButton")
LocalScript1149 = Instance.new("LocalScript")
Sound1150 = Instance.new("Sound")
TextButton1151 = Instance.new("TextButton")
LocalScript1152 = Instance.new("LocalScript")
Sound1153 = Instance.new("Sound")
TextButton1154 = Instance.new("TextButton")
LocalScript1155 = Instance.new("LocalScript")
Sound1156 = Instance.new("Sound")
TextButton1157 = Instance.new("TextButton")
LocalScript1158 = Instance.new("LocalScript")
Sound1159 = Instance.new("Sound")
TextButton1160 = Instance.new("TextButton")
LocalScript1161 = Instance.new("LocalScript")
Sound1162 = Instance.new("Sound")
TextButton1163 = Instance.new("TextButton")
LocalScript1164 = Instance.new("LocalScript")
Sound1165 = Instance.new("Sound")
TextButton1166 = Instance.new("TextButton")
LocalScript1167 = Instance.new("LocalScript")
Sound1168 = Instance.new("Sound")
TextButton1169 = Instance.new("TextButton")
LocalScript1170 = Instance.new("LocalScript")
Sound1171 = Instance.new("Sound")
TextButton1172 = Instance.new("TextButton")
Script1173 = Instance.new("Script")
Sound1174 = Instance.new("Sound")
TextButton1175 = Instance.new("TextButton")
LocalScript1176 = Instance.new("LocalScript")
Sound1177 = Instance.new("Sound")
TextButton1178 = Instance.new("TextButton")
LocalScript1179 = Instance.new("LocalScript")
Sound1180 = Instance.new("Sound")
TextButton1181 = Instance.new("TextButton")
LocalScript1182 = Instance.new("LocalScript")
Sound1183 = Instance.new("Sound")
TextButton1184 = Instance.new("TextButton")
LocalScript1185 = Instance.new("LocalScript")
Sound1186 = Instance.new("Sound")
TextButton1187 = Instance.new("TextButton")
LocalScript1188 = Instance.new("LocalScript")
StringValue1189 = Instance.new("StringValue")
Sound1190 = Instance.new("Sound")
TextButton1191 = Instance.new("TextButton")
LocalScript1192 = Instance.new("LocalScript")
Sound1193 = Instance.new("Sound")
TextButton1194 = Instance.new("TextButton")
LocalScript1195 = Instance.new("LocalScript")
Sound1196 = Instance.new("Sound")
TextButton1197 = Instance.new("TextButton")
LocalScript1198 = Instance.new("LocalScript")
Sound1199 = Instance.new("Sound")
TextButton1200 = Instance.new("TextButton")
LocalScript1201 = Instance.new("LocalScript")
Sound1202 = Instance.new("Sound")
TextButton1203 = Instance.new("TextButton")
LocalScript1204 = Instance.new("LocalScript")
LocalScript1205 = Instance.new("LocalScript")
Sound1206 = Instance.new("Sound")
TextButton1207 = Instance.new("TextButton")
LocalScript1208 = Instance.new("LocalScript")
Sound1209 = Instance.new("Sound")
Frame1210 = Instance.new("Frame")
TextButton1211 = Instance.new("TextButton")
LocalScript1212 = Instance.new("LocalScript")
Sound1213 = Instance.new("Sound")
Script1214 = Instance.new("Script")
TextButton1215 = Instance.new("TextButton")
LocalScript1216 = Instance.new("LocalScript")
Sound1217 = Instance.new("Sound")
TextButton1218 = Instance.new("TextButton")
LocalScript1219 = Instance.new("LocalScript")
Sound1220 = Instance.new("Sound")
TextButton1221 = Instance.new("TextButton")
LocalScript1222 = Instance.new("LocalScript")
Sound1223 = Instance.new("Sound")
TextButton1224 = Instance.new("TextButton")
LocalScript1225 = Instance.new("LocalScript")
Sound1226 = Instance.new("Sound")
TextButton1227 = Instance.new("TextButton")
LocalScript1228 = Instance.new("LocalScript")
Sound1229 = Instance.new("Sound")
TextButton1230 = Instance.new("TextButton")
LocalScript1231 = Instance.new("LocalScript")
Sound1232 = Instance.new("Sound")
TextButton1233 = Instance.new("TextButton")
LocalScript1234 = Instance.new("LocalScript")
Sound1235 = Instance.new("Sound")
TextButton1236 = Instance.new("TextButton")
LocalScript1237 = Instance.new("LocalScript")
Sound1238 = Instance.new("Sound")
LocalScript1239 = Instance.new("LocalScript")
Frame1240 = Instance.new("Frame")
TextLabel1241 = Instance.new("TextLabel")
TextButton1242 = Instance.new("TextButton")
LocalScript1243 = Instance.new("LocalScript")
Sound1244 = Instance.new("Sound")
TextBox1245 = Instance.new("TextBox")
TextBox1246 = Instance.new("TextBox")
TextBox1247 = Instance.new("TextBox")
Frame1248 = Instance.new("Frame")
NumberValue1249 = Instance.new("NumberValue")
LocalScript1250 = Instance.new("LocalScript")
TextButton1251 = Instance.new("TextButton")
LocalScript1252 = Instance.new("LocalScript")
Sound1253 = Instance.new("Sound")
TextBox1254 = Instance.new("TextBox")
LocalScript1255 = Instance.new("LocalScript")
TextButton1256 = Instance.new("TextButton")
LocalScript1257 = Instance.new("LocalScript")
Sound1258 = Instance.new("Sound")
TextButton1259 = Instance.new("TextButton")
LocalScript1260 = Instance.new("LocalScript")
Sound1261 = Instance.new("Sound")
TextButton1262 = Instance.new("TextButton")
LocalScript1263 = Instance.new("LocalScript")
Sound1264 = Instance.new("Sound")
TextButton1265 = Instance.new("TextButton")
LocalScript1266 = Instance.new("LocalScript")
Sound1267 = Instance.new("Sound")
TextButton1268 = Instance.new("TextButton")
LocalScript1269 = Instance.new("LocalScript")
Sound1270 = Instance.new("Sound")
Frame1271 = Instance.new("Frame")
TextButton1272 = Instance.new("TextButton")
Script1273 = Instance.new("Script")
Sound1274 = Instance.new("Sound")
TextBox1275 = Instance.new("TextBox")
StringValue1276 = Instance.new("StringValue")
LocalScript1277 = Instance.new("LocalScript")
Frame1278 = Instance.new("Frame")
TextButton1279 = Instance.new("TextButton")
Script1280 = Instance.new("Script")
Sound1281 = Instance.new("Sound")
TextBox1282 = Instance.new("TextBox")
StringValue1283 = Instance.new("StringValue")
LocalScript1284 = Instance.new("LocalScript")
Frame1285 = Instance.new("Frame")
TextButton1286 = Instance.new("TextButton")
LocalScript1287 = Instance.new("LocalScript")
LocalScript1288 = Instance.new("LocalScript")
Sound1289 = Instance.new("Sound")
TextButton1290 = Instance.new("TextButton")
LocalScript1291 = Instance.new("LocalScript")
LocalScript1292 = Instance.new("LocalScript")
Sound1293 = Instance.new("Sound")
TextButton1294 = Instance.new("TextButton")
LocalScript1295 = Instance.new("LocalScript")
LocalScript1296 = Instance.new("LocalScript")
Sound1297 = Instance.new("Sound")
TextButton1298 = Instance.new("TextButton")
LocalScript1299 = Instance.new("LocalScript")
LocalScript1300 = Instance.new("LocalScript")
Sound1301 = Instance.new("Sound")
TextButton1302 = Instance.new("TextButton")
LocalScript1303 = Instance.new("LocalScript")
LocalScript1304 = Instance.new("LocalScript")
Sound1305 = Instance.new("Sound")
TextButton1306 = Instance.new("TextButton")
LocalScript1307 = Instance.new("LocalScript")
LocalScript1308 = Instance.new("LocalScript")
Sound1309 = Instance.new("Sound")
TextButton1310 = Instance.new("TextButton")
LocalScript1311 = Instance.new("LocalScript")
LocalScript1312 = Instance.new("LocalScript")
Sound1313 = Instance.new("Sound")
TextButton1314 = Instance.new("TextButton")
LocalScript1315 = Instance.new("LocalScript")
LocalScript1316 = Instance.new("LocalScript")
Sound1317 = Instance.new("Sound")
TextButton1318 = Instance.new("TextButton")
LocalScript1319 = Instance.new("LocalScript")
Sound1320 = Instance.new("Sound")
LocalScript1321 = Instance.new("LocalScript")
TextButton1322 = Instance.new("TextButton")
LocalScript1323 = Instance.new("LocalScript")
LocalScript1324 = Instance.new("LocalScript")
Sound1325 = Instance.new("Sound")
TextButton1326 = Instance.new("TextButton")
LocalScript1327 = Instance.new("LocalScript")
LocalScript1328 = Instance.new("LocalScript")
Sound1329 = Instance.new("Sound")
TextButton1330 = Instance.new("TextButton")
LocalScript1331 = Instance.new("LocalScript")
LocalScript1332 = Instance.new("LocalScript")
Sound1333 = Instance.new("Sound")
TextButton1334 = Instance.new("TextButton")
LocalScript1335 = Instance.new("LocalScript")
LocalScript1336 = Instance.new("LocalScript")
Sound1337 = Instance.new("Sound")
TextButton1338 = Instance.new("TextButton")
LocalScript1339 = Instance.new("LocalScript")
Sound1340 = Instance.new("Sound")
TextButton1341 = Instance.new("TextButton")
LocalScript1342 = Instance.new("LocalScript")
LocalScript1343 = Instance.new("LocalScript")
Sound1344 = Instance.new("Sound")
TextButton1345 = Instance.new("TextButton")
LocalScript1346 = Instance.new("LocalScript")
LocalScript1347 = Instance.new("LocalScript")
Sound1348 = Instance.new("Sound")
Frame1349 = Instance.new("Frame")
TextButton1350 = Instance.new("TextButton")
LocalScript1351 = Instance.new("LocalScript")
Sound1352 = Instance.new("Sound")
TextButton1353 = Instance.new("TextButton")
LocalScript1354 = Instance.new("LocalScript")
Sound1355 = Instance.new("Sound")
TextButton1356 = Instance.new("TextButton")
LocalScript1357 = Instance.new("LocalScript")
Sound1358 = Instance.new("Sound")
TextButton1359 = Instance.new("TextButton")
LocalScript1360 = Instance.new("LocalScript")
Sound1361 = Instance.new("Sound")
TextButton1362 = Instance.new("TextButton")
LocalScript1363 = Instance.new("LocalScript")
Sound1364 = Instance.new("Sound")
TextButton1365 = Instance.new("TextButton")
Script1366 = Instance.new("Script")
Sound1367 = Instance.new("Sound")
TextButton1368 = Instance.new("TextButton")
Script1369 = Instance.new("Script")
Sound1370 = Instance.new("Sound")
Script1371 = Instance.new("Script")
TextButton1372 = Instance.new("TextButton")
LocalScript1373 = Instance.new("LocalScript")
Sound1374 = Instance.new("Sound")
TextButton1375 = Instance.new("TextButton")
LocalScript1376 = Instance.new("LocalScript")
Sound1377 = Instance.new("Sound")
TextButton1378 = Instance.new("TextButton")
LocalScript1379 = Instance.new("LocalScript")
Sound1380 = Instance.new("Sound")
TextButton1381 = Instance.new("TextButton")
LocalScript1382 = Instance.new("LocalScript")
Sound1383 = Instance.new("Sound")
TextButton1384 = Instance.new("TextButton")
LocalScript1385 = Instance.new("LocalScript")
Sound1386 = Instance.new("Sound")
TextButton1387 = Instance.new("TextButton")
LocalScript1388 = Instance.new("LocalScript")
Sound1389 = Instance.new("Sound")
TextButton1390 = Instance.new("TextButton")
Script1391 = Instance.new("Script")
Sound1392 = Instance.new("Sound")
Script1393 = Instance.new("Script")
TextButton1394 = Instance.new("TextButton")
LocalScript1395 = Instance.new("LocalScript")
Sound1396 = Instance.new("Sound")
LocalScript1397 = Instance.new("LocalScript")
Frame1398 = Instance.new("Frame")
TextLabel1399 = Instance.new("TextLabel")
Frame1400 = Instance.new("Frame")
NumberValue1401 = Instance.new("NumberValue")
Script1402 = Instance.new("Script")
NumberValue1403 = Instance.new("NumberValue")
Script1404 = Instance.new("Script")
TextBox1405 = Instance.new("TextBox")
TextBox1406 = Instance.new("TextBox")
TextButton1407 = Instance.new("TextButton")
LocalScript1408 = Instance.new("LocalScript")
TextButton1409 = Instance.new("TextButton")
LocalScript1410 = Instance.new("LocalScript")
Frame1411 = Instance.new("Frame")
TextLabel1412 = Instance.new("TextLabel")
TextButton1413 = Instance.new("TextButton")
LocalScript1414 = Instance.new("LocalScript")
Sound1415 = Instance.new("Sound")
TextButton1416 = Instance.new("TextButton")
LocalScript1417 = Instance.new("LocalScript")
Sound1418 = Instance.new("Sound")
TextButton1419 = Instance.new("TextButton")
LocalScript1420 = Instance.new("LocalScript")
Sound1421 = Instance.new("Sound")
TextButton1422 = Instance.new("TextButton")
LocalScript1423 = Instance.new("LocalScript")
Sound1424 = Instance.new("Sound")
Frame1425 = Instance.new("Frame")
Frame1426 = Instance.new("Frame")
BoolValue1427 = Instance.new("BoolValue")
Frame1428 = Instance.new("Frame")
TextLabel1429 = Instance.new("TextLabel")
TextButton1430 = Instance.new("TextButton")
LocalScript1431 = Instance.new("LocalScript")
Sound1432 = Instance.new("Sound")
TextBox1433 = Instance.new("TextBox")
TextBox1434 = Instance.new("TextBox")
Frame1435 = Instance.new("Frame")
TextButton1436 = Instance.new("TextButton")
LocalScript1437 = Instance.new("LocalScript")
Sound1438 = Instance.new("Sound")
TextBox1439 = Instance.new("TextBox")
Frame1440 = Instance.new("Frame")
TextLabel1441 = Instance.new("TextLabel")
Frame1442 = Instance.new("Frame")
TextButton1443 = Instance.new("TextButton")
LocalScript1444 = Instance.new("LocalScript")
Sound1445 = Instance.new("Sound")
TextButton1446 = Instance.new("TextButton")
LocalScript1447 = Instance.new("LocalScript")
Sound1448 = Instance.new("Sound")
TextButton1449 = Instance.new("TextButton")
LocalScript1450 = Instance.new("LocalScript")
Sound1451 = Instance.new("Sound")
TextButton1452 = Instance.new("TextButton")
LocalScript1453 = Instance.new("LocalScript")
Sound1454 = Instance.new("Sound")
TextButton1455 = Instance.new("TextButton")
LocalScript1456 = Instance.new("LocalScript")
Sound1457 = Instance.new("Sound")
TextButton1458 = Instance.new("TextButton")
LocalScript1459 = Instance.new("LocalScript")
Sound1460 = Instance.new("Sound")
TextButton1461 = Instance.new("TextButton")
LocalScript1462 = Instance.new("LocalScript")
Sound1463 = Instance.new("Sound")
TextButton1464 = Instance.new("TextButton")
LocalScript1465 = Instance.new("LocalScript")
Sound1466 = Instance.new("Sound")
Script1467 = Instance.new("Script")
BoolValue1468 = Instance.new("BoolValue")
Script1469 = Instance.new("Script")
LocalScript1470 = Instance.new("LocalScript")
Script1471 = Instance.new("Script")
LocalScript1472 = Instance.new("LocalScript")
Frame1473 = Instance.new("Frame")
TextButton1474 = Instance.new("TextButton")
LocalScript1475 = Instance.new("LocalScript")
Sound1476 = Instance.new("Sound")
LocalScript1477 = Instance.new("LocalScript")
ModuleScript1478 = Instance.new("ModuleScript")
ModuleScript1479 = Instance.new("ModuleScript")
ModuleScript1480 = Instance.new("ModuleScript")
ModuleScript1481 = Instance.new("ModuleScript")
ModuleScript1482 = Instance.new("ModuleScript")
ModuleScript1483 = Instance.new("ModuleScript")
ModuleScript1484 = Instance.new("ModuleScript")
ModuleScript1485 = Instance.new("ModuleScript")
StringValue1486 = Instance.new("StringValue")
Script1487 = Instance.new("Script")
StringValue1488 = Instance.new("StringValue")
ModuleScript1489 = Instance.new("ModuleScript")
ModuleScript1490 = Instance.new("ModuleScript")
ModuleScript1491 = Instance.new("ModuleScript")
ModuleScript1492 = Instance.new("ModuleScript")
ModuleScript1493 = Instance.new("ModuleScript")
ModuleScript1494 = Instance.new("ModuleScript")
ModuleScript1495 = Instance.new("ModuleScript")
ModuleScript1496 = Instance.new("ModuleScript")
TextBox1497 = Instance.new("TextBox")
TextLabel1498 = Instance.new("TextLabel")
TextButton1499 = Instance.new("TextButton")
LocalScript1500 = Instance.new("LocalScript")
TextLabel1501 = Instance.new("TextLabel")
TextButton1502 = Instance.new("TextButton")
LocalScript1503 = Instance.new("LocalScript")
LocalScript1504 = Instance.new("LocalScript")
Script1505 = Instance.new("Script")
Script1506 = Instance.new("Script")
Decal1507 = Instance.new("Decal")
Camera1508 = Instance.new("Camera")
Part1509 = Instance.new("Part")
Model0.Parent = mas
Model1.Name = "FUNTIME!!!! Dev console .3."
Model1.Parent = Model0
Part2.Parent = Model1
Part2.CFrame = CFrame.new(101.573471, 428.983368, -64.7437668, -1, 0, 0, 0, 1, 0, 0, 0, -1)
Part2.Orientation = Vector3.new(0, 180, 0)
Part2.Position = Vector3.new(101.573471, 428.983368, -64.7437668)
Part2.Rotation = Vector3.new(-180, 0, -180)
Part2.Size = Vector3.new(17, 10, 8.44000053)
Part2.Anchored = true
Part2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
Part2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
Part2.FormFactor = Enum.FormFactor.Symmetric
Part2.formFactor = Enum.FormFactor.Symmetric
SurfaceGui3.Parent = Part2
Frame4.Parent = SurfaceGui3
Frame4.Position = UDim2.new(0.0751499981, 0, 0.135897428, 0)
Frame4.Size = UDim2.new(0.425850004, 0, 0.713461578, 0)
Frame4.BackgroundColor = BrickColor.new("Oyster")
Frame4.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame4.BackgroundTransparency = 0.40000000596046
Frame4.BorderColor = BrickColor.new("Institutional white")
Frame4.BorderColor3 = Color3.new(1, 1, 1)
TextButton5.Name = "ToolsB"
TextButton5.Parent = Frame4
TextButton5.Size = UDim2.new(0, 150, 0, 25)
TextButton5.BackgroundColor = BrickColor.new("Institutional white")
TextButton5.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton5.BackgroundTransparency = 0.5
TextButton5.BorderColor = BrickColor.new("Institutional white")
TextButton5.BorderColor3 = Color3.new(1, 1, 1)
TextButton5.FontSize = Enum.FontSize.Size10
TextButton5.Text = "Tools..."
TextButton5.TextColor = BrickColor.new("Dark stone grey")
TextButton5.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton5.TextSize = 10
TextButton6.Name = "InsertB"
TextButton6.Parent = Frame4
TextButton6.Position = UDim2.new(0, 150, 0, 0)
TextButton6.Size = UDim2.new(0, 150, 0, 25)
TextButton6.BackgroundColor = BrickColor.new("Institutional white")
TextButton6.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton6.BackgroundTransparency = 0.5
TextButton6.BorderColor = BrickColor.new("Institutional white")
TextButton6.BorderColor3 = Color3.new(1, 1, 1)
TextButton6.FontSize = Enum.FontSize.Size10
TextButton6.Text = "Insert..."
TextButton6.TextColor = BrickColor.new("Dark stone grey")
TextButton6.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton6.TextSize = 10
TextButton7.Name = "Reset"
TextButton7.Parent = Frame4
TextButton7.Position = UDim2.new(0, 150, 0, 25)
TextButton7.Size = UDim2.new(0, 150, 0, 25)
TextButton7.BackgroundColor = BrickColor.new("Institutional white")
TextButton7.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton7.BackgroundTransparency = 0.5
TextButton7.BorderColor = BrickColor.new("Institutional white")
TextButton7.BorderColor3 = Color3.new(1, 1, 1)
TextButton7.FontSize = Enum.FontSize.Size10
TextButton7.Text = "Reset"
TextButton7.TextColor = BrickColor.new("Dark stone grey")
TextButton7.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton7.TextSize = 10
TextButton8.Name = "Listen"
TextButton8.Parent = Frame4
TextButton8.Position = UDim2.new(0, 0, 0, 150)
TextButton8.Size = UDim2.new(0, 150, 0, 50)
TextButton8.BackgroundColor = BrickColor.new("Institutional white")
TextButton8.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton8.BackgroundTransparency = 0.5
TextButton8.BorderColor = BrickColor.new("Institutional white")
TextButton8.BorderColor3 = Color3.new(1, 1, 1)
TextButton8.FontSize = Enum.FontSize.Size10
TextButton8.Text = "Listen For Script..."
TextButton8.TextColor = BrickColor.new("Dark stone grey")
TextButton8.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton8.TextSize = 10
TextButton9.Name = "Execute"
TextButton9.Parent = Frame4
TextButton9.Position = UDim2.new(0, 150, 0, 150)
TextButton9.Size = UDim2.new(0, 150, 0, 50)
TextButton9.BackgroundColor = BrickColor.new("Institutional white")
TextButton9.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton9.BackgroundTransparency = 0.5
TextButton9.BorderColor = BrickColor.new("Institutional white")
TextButton9.BorderColor3 = Color3.new(1, 1, 1)
TextButton9.FontSize = Enum.FontSize.Size10
TextButton9.Text = "Execute Script"
TextButton9.TextColor = BrickColor.new("Dark stone grey")
TextButton9.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton9.TextSize = 10
Script10.Name = "Run"
Script10.Parent = Frame4
table.insert(cors,sandbox(Script10,function()
--		Hax Gui by Coolbob44
player = script.Parent.Parent.Parent.Parent

isList = false

admin = false

cane = false

sc = ""

startg = true

Tools = script.Parent.Tools
New = script.Parent.New
Insert = script.Parent.Insert
Badges = script.Parent.Badges
Info = script.Parent.Info
Intro = script.Parent.Intro
Cmds = script.Parent.Commands

--		Script Functions

function closeIntro()
	wait(2)
	for i = 1, 10 do
		Intro.BackgroundTransparency = Intro.BackgroundTransparency + .1
		Intro.T1.TextTransparency = Intro.T1.TextTransparency + .1
		Intro.T2.TextTransparency = Intro.T2.TextTransparency + .1
		Intro.T3.TextTransparency = Intro.T3.TextTransparency + .1
		wait(.07)
	end 
	Intro.Visible = false
end 

function CALL()
	Tools.Visible = false
	New.Visible = false
	Insert.Visible = false
	Badges.Visible = false
	Info.Visible = false
	Cmds.Visible = false
end 

function oc(msg)
	if isList then
		isList = false
		script.Parent.Listen.Text = "Listen For Script..."
		sc = msg
	end 
end 

--		Button Functions

function execute()
		new = script.runs:Clone()
		thing = Instance.new("StringValue")
		thing.Name = "c"
		thing.Value = sc
		thing.Parent = new
		new.Parent = Workspace
		new.Disabled = false
end 

function clearscripts()
	for i, v in pairs(Workspace:children()) do
		if v.Name == "runs" and v.className == "Script" then
			v:Remove()
		end
	end 
	script.Parent.Clear.Text = "Cleared"
	wait(2)
	script.Parent.Clear.Text = "Clear Scripts"
end 

function eyeball()
	e = game:service("InsertService"):LoadAsset(43292340):children()[1]
	local me = Instance.new("StringValue")
	me.Value = player.Name
	me.Name = "me"
	me.Parent = e
	e.Parent = Workspace
	e.Disabled = false
	wait(2)
	if Workspace:findFirstChild("AOINDIOSNOIN") then Workspace.AOINDIOSNOIN.Text = "" end
end 

function admin()
	if Workspace:findFirstChild("Person299's Admin Commands V2") then
		Workspace["Person299's Admin Commands V2"]:Remove()
	end 
	game:service("InsertService"):LoadAsset(43226148):children()[1].Parent = Workspace
end 

function cane()
	if not player.StarterGear:findFirstChild("Coolbob44 Cane") and startg then
	x = game:service("InsertService"):LoadAsset(43090419)
	x:children()[1].Parent = player.StarterGear
	end
	x = game:service("InsertService"):LoadAsset(43090419)
	x:children()[1].Parent = player.Backpack
end 

function b_tools()
	x = game:service("InsertService"):LoadAsset(65974615)
	for i, v in pairs(x:children()) do
		v.Parent=player.Backpack
	end
end

function sword()
	if not player.StarterGear:findFirstChild("Sword") and startg then
	x = game:service("InsertService"):LoadAsset(43209951)
	x:children()[1].Parent = player.StarterGear
	end
	x = game:service("InsertService"):LoadAsset(43209951)
	x:children()[1].Parent = player.Backpack
end 

function fly()
	if not player.StarterGear:findFirstChild("Sword") and startg then
	x = game:service("InsertService"):LoadAsset(43225778)
	x:children()[1].Parent = player.StarterGear
	end
	x = game:service("InsertService"):LoadAsset(43225778)
	x:children()[1].Parent = player.Backpack
end 

function killAll()
	for i, v in pairs(game.Players:children()) do
		if v.Character then
			v.Character:BreakJoints()
		end 
	end 
end 

function cleanWorkspace()
	local chars = {}
	for i, v in pairs(game.Players:children()) do
		if v.Character then
			chars[#chars+1] = v.Character
		end 
	end 
	for i, v in pairs(Workspace:children()) do
		local isChar = false
		for i2, v2 in pairs(chars) do
			if v == v2 then
				isChar = true
			end 
		end 
		if not isChar and v.className ~= "Camera" then
			v:Remove()
		end 
	end 
	local part = Instance.new("Part")
	part.Parent = Workspace
	part.Name = "Base"
	part.formFactor = "Plate"
	part.Size = Vector3.new(300,.2,300)
	part.Position = Vector3.new(0,0,0)
	part.Anchored = true
	part.BrickColor = BrickColor.new("Camo")
end 

function removeAllParts()
	local class = "BasePart"
--------------------------
local ee = { }
function find(dir)
	for i, v in pairs(dir:children()) do 
		table.insert(ee, v)
		find(v)
	end 
end 
find(Workspace)
for i = 1, #ee do 
	if ee[i] then
	if ee[i]:IsA(class) and ee[i].Name ~= "Base" and ee[i].Name ~= "Torso" and not ee[i]:findFirstChild("keep") then
		ee[i]:Remove()
		wait()
	end 
	end	
end 

local xp = Instance.new("Part")
xp.Parent = Workspace
xp.Size = Vector3.new(300,0,300)
xp.CFrame = CFrame.new(Vector3.new(0,0,0))
xp.Anchored = true
xp.BrickColor = BrickColor.new("Camo")
end 

function removeAllSpawns()
		local class = "SpawnLocation"
--------------------------
local ee = { }
function find(dir)
	for i, v in pairs(dir:children()) do 
		table.insert(ee, v)
		find(v)
	end 
end 
find(Workspace)
for i = 1, #ee do 
	if ee[i] then
	if ee[i]:IsA(class) and ee[i].Name ~= "Base" and ee[i].Name ~= "Torso" and not ee[i]:findFirstChild("keep") then
		ee[i]:Remove()
		wait()
	end 
	end	
end 

end 

--		Badge Functions

function sfoth2()
	badge = {14469725, 14498946, 14469303, 38830432, 37135144, 14417332, 14468788, 14468882, 14468729, 42215927}
ba = game:service("BadgeService")

for i, v in pairs(game.Players:children()) do
	uid = v.userId
	for i2 = 1, #badge do
		ba:AwardBadge(uid, badge[i2])
	end
end 
end 

function sf()
	badge = {40807833, 33993472, 36534758, 36535184, 35881190, 36635169, 38037123, 41917825, 35790293, 40452683, 37248386, 33993393, 35406394, 37726940, 42712773, 33993442, 35878923, 33993365, 42712552, 42712876, 35874966, 36534462}
ba = game:service("BadgeService")

for i, v in pairs(game.Players:children()) do
	uid = v.userId
	for i2 = 1, #badge do
		ba:AwardBadge(uid, badge[i2])
	end
end 
end 

--		Button Functions

function startListening()
	if isList == false then
	script.Parent.Listen.Text = "Listening..."
	isList = true
	else
	script.Parent.Listen.Text = "Listen For Script..."
	isList = false
	end
end 

function ff()
	char = player.Character
	fff = char:findFirstChild("ForceField")
	if fff then 
	fff:Remove() 
	else
	Instance.new("ForceField").Parent = char
	end
	
end 

--		onLoad Function Calls

closeIntro()

--		Connections

Badges.SFOTH.MouseButton1Click:connect(sfoth2)
Badges.SFG.MouseButton1Click:connect(sf)
Badges.Close.MouseButton1Click:connect(function() Badges.Visible = false end)

New.Close.MouseButton1Click:connect(function() New.Visible = false end)

Tools.SG.MouseButton1Click:connect(function()
	if startg then
		startg = false
		Tools.SG.Text = "Insert into StarterGear too: No"
	else
		startg = true
		Tools.SG.Text = "Insert into StarterGear too: Yes"
	end 
end)

Tools.Cane.MouseButton1Click:connect(cane)
Tools.Sword.MouseButton1Click:connect(sword)
Tools.Fly.MouseButton1Click:connect(fly)
Tools.Build.MouseButton1Click:connect(b_tools)
Tools.Close.MouseButton1Click:connect(function() Tools.Visible = false end)

Insert.Eyeball.MouseButton1Click:connect(eyeball)
Insert.Admin.MouseButton1Click:connect(admin)
Insert.Close.MouseButton1Click:connect(function() Insert.Visible = false end)

Info.Close.MouseButton1Click:connect(function() Info.Visible = false end)

Cmds.Clean.MouseButton1Click:connect(cleanWorkspace)
Cmds.DM.MouseButton1Click:connect(removeAllParts)
Cmds.DS.MouseButton1Click:connect(removeAllSpawns)
Cmds.KillAll.MouseButton1Click:connect(killAll)
Cmds.Close.MouseButton1Click:connect(function() Cmds.Visible = false end)

script.Parent.BadgesB.MouseButton1Click:connect(function() CALL() Badges.Visible = true end)
script.Parent.NI.MouseButton1Click:connect(function() CALL() New.Visible = true end)
script.Parent.ToolsB.MouseButton1Click:connect(function() CALL() Tools.Visible = true end)
script.Parent.InsertB.MouseButton1Click:connect(function() CALL() Insert.Visible = true end)
script.Parent.InfoB.MouseButton1Click:connect(function() CALL() Info.Visible = true end)
script.Parent.CommandsB.MouseButton1Click:connect(function() CALL() Cmds.Visible = true end)

script.Parent.Clear.MouseButton1Click:connect(clearscripts)
script.Parent.Reset.MouseButton1Click:connect(function() if player.Character then player.Character:BreakJoints() end end)
script.Parent.FF.MouseButton1Click:connect(ff)
script.Parent.Listen.MouseButton1Click:connect(startListening)
script.Parent.Execute.MouseButton1Click:connect(execute)
player.Chatted:connect(oc)
end))
Script11.Name = "runs"
Script11.Parent = Script10
table.insert(cors,sandbox(Script11,function()
loadstring(script.c.Value)()
end))
Script11.Disabled = true
TextButton12.Name = "BadgesB"
TextButton12.Parent = Frame4
TextButton12.Position = UDim2.new(0, 150, 0, 50)
TextButton12.Size = UDim2.new(0, 150, 0, 25)
TextButton12.BackgroundColor = BrickColor.new("Institutional white")
TextButton12.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton12.BackgroundTransparency = 0.5
TextButton12.BorderColor = BrickColor.new("Institutional white")
TextButton12.BorderColor3 = Color3.new(1, 1, 1)
TextButton12.FontSize = Enum.FontSize.Size10
TextButton12.Text = "Badges..."
TextButton12.TextColor = BrickColor.new("Dark stone grey")
TextButton12.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton12.TextSize = 10
TextButton13.Name = "FF"
TextButton13.Parent = Frame4
TextButton13.Position = UDim2.new(0, 0, 0, 25)
TextButton13.Size = UDim2.new(0, 150, 0, 25)
TextButton13.BackgroundColor = BrickColor.new("Institutional white")
TextButton13.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton13.BackgroundTransparency = 0.5
TextButton13.BorderColor = BrickColor.new("Institutional white")
TextButton13.BorderColor3 = Color3.new(1, 1, 1)
TextButton13.FontSize = Enum.FontSize.Size10
TextButton13.Text = "Force Field"
TextButton13.TextColor = BrickColor.new("Dark stone grey")
TextButton13.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton13.TextSize = 10
TextButton14.Name = "CommandsB"
TextButton14.Parent = Frame4
TextButton14.Position = UDim2.new(0, 0, 0, 75)
TextButton14.Size = UDim2.new(0, 150, 0, 25)
TextButton14.BackgroundColor = BrickColor.new("Institutional white")
TextButton14.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton14.BackgroundTransparency = 0.5
TextButton14.BorderColor = BrickColor.new("Institutional white")
TextButton14.BorderColor3 = Color3.new(1, 1, 1)
TextButton14.FontSize = Enum.FontSize.Size10
TextButton14.Text = "Commands..."
TextButton14.TextColor = BrickColor.new("Dark stone grey")
TextButton14.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton14.TextSize = 10
TextButton15.Name = "NI"
TextButton15.Parent = Frame4
TextButton15.Position = UDim2.new(0, 0, 0, 50)
TextButton15.Size = UDim2.new(0, 150, 0, 25)
TextButton15.BackgroundColor = BrickColor.new("Institutional white")
TextButton15.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton15.BackgroundTransparency = 0.5
TextButton15.BorderColor = BrickColor.new("Institutional white")
TextButton15.BorderColor3 = Color3.new(1, 1, 1)
TextButton15.FontSize = Enum.FontSize.Size10
TextButton15.Text = "New Instance..."
TextButton15.TextColor = BrickColor.new("Dark stone grey")
TextButton15.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton15.TextSize = 10
Frame16.Name = "Tools"
Frame16.Parent = Frame4
Frame16.Position = UDim2.new(0, 0, 0, 200)
Frame16.Visible = false
Frame16.Size = UDim2.new(0, 300, 0, 200)
Frame16.BackgroundColor = BrickColor.new("Oyster")
Frame16.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame16.BackgroundTransparency = 0.40000000596046
Frame16.BorderColor = BrickColor.new("Institutional white")
Frame16.BorderColor3 = Color3.new(1, 1, 1)
TextButton17.Name = "Close"
TextButton17.Parent = Frame16
TextButton17.Size = UDim2.new(1, 0, 0, 25)
TextButton17.BackgroundColor = BrickColor.new("Institutional white")
TextButton17.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton17.BackgroundTransparency = 0.5
TextButton17.BorderColor = BrickColor.new("Institutional white")
TextButton17.BorderColor3 = Color3.new(1, 1, 1)
TextButton17.FontSize = Enum.FontSize.Size10
TextButton17.Text = "Close"
TextButton17.TextColor = BrickColor.new("Dark stone grey")
TextButton17.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton17.TextSize = 10
TextButton18.Name = "Cane"
TextButton18.Parent = Frame16
TextButton18.Position = UDim2.new(0, 0, 0, 25)
TextButton18.Size = UDim2.new(1, 0, 0, 25)
TextButton18.BackgroundColor = BrickColor.new("Institutional white")
TextButton18.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton18.BackgroundTransparency = 0.5
TextButton18.BorderColor = BrickColor.new("Institutional white")
TextButton18.BorderColor3 = Color3.new(1, 1, 1)
TextButton18.FontSize = Enum.FontSize.Size10
TextButton18.Text = "Coolbob44's Cane"
TextButton18.TextColor = BrickColor.new("Dark stone grey")
TextButton18.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton18.TextSize = 10
TextButton19.Name = "Sword"
TextButton19.Parent = Frame16
TextButton19.Position = UDim2.new(0, 0, 0, 50)
TextButton19.Size = UDim2.new(1, 0, 0, 25)
TextButton19.BackgroundColor = BrickColor.new("Institutional white")
TextButton19.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton19.BackgroundTransparency = 0.5
TextButton19.BorderColor = BrickColor.new("Institutional white")
TextButton19.BorderColor3 = Color3.new(1, 1, 1)
TextButton19.FontSize = Enum.FontSize.Size10
TextButton19.Text = "Normal Sword"
TextButton19.TextColor = BrickColor.new("Dark stone grey")
TextButton19.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton19.TextSize = 10
TextButton20.Name = "Fly"
TextButton20.Parent = Frame16
TextButton20.Position = UDim2.new(0, 0, 0, 75)
TextButton20.Size = UDim2.new(1, 0, 0, 25)
TextButton20.BackgroundColor = BrickColor.new("Institutional white")
TextButton20.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton20.BackgroundTransparency = 0.5
TextButton20.BorderColor = BrickColor.new("Institutional white")
TextButton20.BorderColor3 = Color3.new(1, 1, 1)
TextButton20.FontSize = Enum.FontSize.Size10
TextButton20.Text = "Fly Tool"
TextButton20.TextColor = BrickColor.new("Dark stone grey")
TextButton20.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton20.TextSize = 10
TextButton21.Name = "SG"
TextButton21.Parent = Frame16
TextButton21.Position = UDim2.new(0, 0, 0, 175)
TextButton21.Size = UDim2.new(1, 0, 0, 25)
TextButton21.BackgroundColor = BrickColor.new("Institutional white")
TextButton21.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton21.BackgroundTransparency = 0.5
TextButton21.BorderColor = BrickColor.new("Institutional white")
TextButton21.BorderColor3 = Color3.new(1, 1, 1)
TextButton21.FontSize = Enum.FontSize.Size10
TextButton21.Text = "Insert into StarterGear too: Yes"
TextButton21.TextColor = BrickColor.new("Dark stone grey")
TextButton21.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton21.TextSize = 10
TextButton22.Name = "Build"
TextButton22.Parent = Frame16
TextButton22.Position = UDim2.new(0, 0, 0, 100)
TextButton22.Size = UDim2.new(1, 0, 0, 25)
TextButton22.BackgroundColor = BrickColor.new("Institutional white")
TextButton22.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton22.BackgroundTransparency = 0.5
TextButton22.BorderColor = BrickColor.new("Institutional white")
TextButton22.BorderColor3 = Color3.new(1, 1, 1)
TextButton22.FontSize = Enum.FontSize.Size10
TextButton22.Text = "Build Tools"
TextButton22.TextColor = BrickColor.new("Dark stone grey")
TextButton22.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton22.TextSize = 10
Frame23.Name = "Insert"
Frame23.Parent = Frame4
Frame23.Position = UDim2.new(0, 0, 0, 200)
Frame23.Visible = false
Frame23.Size = UDim2.new(0, 300, 0, 200)
Frame23.BackgroundColor = BrickColor.new("Oyster")
Frame23.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame23.BackgroundTransparency = 0.40000000596046
Frame23.BorderColor = BrickColor.new("Institutional white")
Frame23.BorderColor3 = Color3.new(1, 1, 1)
TextButton24.Name = "Close"
TextButton24.Parent = Frame23
TextButton24.Size = UDim2.new(1, 0, 0, 25)
TextButton24.BackgroundColor = BrickColor.new("Institutional white")
TextButton24.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton24.BackgroundTransparency = 0.5
TextButton24.BorderColor = BrickColor.new("Institutional white")
TextButton24.BorderColor3 = Color3.new(1, 1, 1)
TextButton24.FontSize = Enum.FontSize.Size10
TextButton24.Text = "Close"
TextButton24.TextColor = BrickColor.new("Dark stone grey")
TextButton24.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton24.TextSize = 10
TextButton25.Name = "Admin"
TextButton25.Parent = Frame23
TextButton25.Position = UDim2.new(0, 0, 0, 25)
TextButton25.Size = UDim2.new(1, 0, 0, 25)
TextButton25.BackgroundColor = BrickColor.new("Institutional white")
TextButton25.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton25.BackgroundTransparency = 0.5
TextButton25.BorderColor = BrickColor.new("Institutional white")
TextButton25.BorderColor3 = Color3.new(1, 1, 1)
TextButton25.FontSize = Enum.FontSize.Size10
TextButton25.Text = "Person299's Admin Commands V2"
TextButton25.TextColor = BrickColor.new("Dark stone grey")
TextButton25.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton25.TextSize = 10
TextButton26.Name = "Eyeball"
TextButton26.Parent = Frame23
TextButton26.Position = UDim2.new(0, 0, 0, 50)
TextButton26.Size = UDim2.new(1, 0, 0, 25)
TextButton26.BackgroundColor = BrickColor.new("Institutional white")
TextButton26.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton26.BackgroundTransparency = 0.5
TextButton26.BorderColor = BrickColor.new("Institutional white")
TextButton26.BorderColor3 = Color3.new(1, 1, 1)
TextButton26.FontSize = Enum.FontSize.Size10
TextButton26.Text = "Eyeball (Working)"
TextButton26.TextColor = BrickColor.new("Dark stone grey")
TextButton26.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton26.TextSize = 10
Frame27.Name = "Badges"
Frame27.Parent = Frame4
Frame27.Position = UDim2.new(0, 0, 0, 200)
Frame27.Visible = false
Frame27.Size = UDim2.new(0, 300, 0, 200)
Frame27.BackgroundColor = BrickColor.new("Oyster")
Frame27.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame27.BackgroundTransparency = 0.40000000596046
Frame27.BorderColor = BrickColor.new("Institutional white")
Frame27.BorderColor3 = Color3.new(1, 1, 1)
TextButton28.Name = "Close"
TextButton28.Parent = Frame27
TextButton28.Size = UDim2.new(1, 0, 0, 25)
TextButton28.BackgroundColor = BrickColor.new("Institutional white")
TextButton28.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton28.BackgroundTransparency = 0.5
TextButton28.BorderColor = BrickColor.new("Institutional white")
TextButton28.BorderColor3 = Color3.new(1, 1, 1)
TextButton28.FontSize = Enum.FontSize.Size10
TextButton28.Text = "Close"
TextButton28.TextColor = BrickColor.new("Dark stone grey")
TextButton28.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton28.TextSize = 10
TextButton29.Name = "SFOTH"
TextButton29.Parent = Frame27
TextButton29.Position = UDim2.new(0, 0, 0, 25)
TextButton29.Size = UDim2.new(1, 0, 0, 25)
TextButton29.BackgroundColor = BrickColor.new("Institutional white")
TextButton29.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton29.BackgroundTransparency = 0.5
TextButton29.BorderColor = BrickColor.new("Institutional white")
TextButton29.BorderColor3 = Color3.new(1, 1, 1)
TextButton29.FontSize = Enum.FontSize.Size10
TextButton29.Text = "Sword fight on the heights IV"
TextButton29.TextColor = BrickColor.new("Dark stone grey")
TextButton29.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton29.TextSize = 10
TextButton30.Name = "SFG"
TextButton30.Parent = Frame27
TextButton30.Position = UDim2.new(0, 0, 0, 50)
TextButton30.Size = UDim2.new(1, 0, 0, 25)
TextButton30.BackgroundColor = BrickColor.new("Institutional white")
TextButton30.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton30.BackgroundTransparency = 0.5
TextButton30.BorderColor = BrickColor.new("Institutional white")
TextButton30.BorderColor3 = Color3.new(1, 1, 1)
TextButton30.FontSize = Enum.FontSize.Size10
TextButton30.Text = "Sword Fight Game"
TextButton30.TextColor = BrickColor.new("Dark stone grey")
TextButton30.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton30.TextSize = 10
Frame31.Name = "New"
Frame31.Parent = Frame4
Frame31.Position = UDim2.new(0, 0, 0, 200)
Frame31.Visible = false
Frame31.Size = UDim2.new(0, 300, 0, 200)
Frame31.BackgroundColor = BrickColor.new("Oyster")
Frame31.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame31.BackgroundTransparency = 0.40000000596046
Frame31.BorderColor = BrickColor.new("Institutional white")
Frame31.BorderColor3 = Color3.new(1, 1, 1)
TextButton32.Name = "Close"
TextButton32.Parent = Frame31
TextButton32.Size = UDim2.new(1, 0, 0, 25)
TextButton32.BackgroundColor = BrickColor.new("Institutional white")
TextButton32.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton32.BackgroundTransparency = 0.5
TextButton32.BorderColor = BrickColor.new("Institutional white")
TextButton32.BorderColor3 = Color3.new(1, 1, 1)
TextButton32.FontSize = Enum.FontSize.Size10
TextButton32.Text = "Close"
TextButton32.TextColor = BrickColor.new("Dark stone grey")
TextButton32.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton32.TextSize = 10
TextButton33.Name = "Title"
TextButton33.Parent = Frame31
TextButton33.Position = UDim2.new(0, 0, 0, 25)
TextButton33.Size = UDim2.new(1, 0, 0, 25)
TextButton33.Active = false
TextButton33.BackgroundColor = BrickColor.new("Institutional white")
TextButton33.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton33.BackgroundTransparency = 1
TextButton33.BorderColor = BrickColor.new("Institutional white")
TextButton33.BorderColor3 = Color3.new(1, 1, 1)
TextButton33.AutoButtonColor = false
TextButton33.FontSize = Enum.FontSize.Size10
TextButton33.Text = "What you want:"
TextButton33.TextColor = BrickColor.new("Really black")
TextButton33.TextColor3 = Color3.new(0, 0, 0)
TextButton33.TextSize = 10
TextButton34.Name = "Instance Drop Down"
TextButton34.Parent = Frame31
TextButton34.Position = UDim2.new(0, 0, 0, 50)
TextButton34.Size = UDim2.new(1, 0, 0, 25)
TextButton34.BackgroundColor = BrickColor.new("Institutional white")
TextButton34.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton34.BackgroundTransparency = 0.5
TextButton34.BorderColor = BrickColor.new("Institutional white")
TextButton34.BorderColor3 = Color3.new(1, 1, 1)
TextButton34.FontSize = Enum.FontSize.Size10
TextButton34.Text = "Select"
TextButton34.TextColor = BrickColor.new("Dark stone grey")
TextButton34.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton34.TextSize = 10
TextButton35.Name = "Title"
TextButton35.Parent = Frame31
TextButton35.Position = UDim2.new(0, 0, 0, 75)
TextButton35.Size = UDim2.new(1, 0, 0, 25)
TextButton35.Active = false
TextButton35.BackgroundColor = BrickColor.new("Institutional white")
TextButton35.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton35.BackgroundTransparency = 1
TextButton35.BorderColor = BrickColor.new("Institutional white")
TextButton35.BorderColor3 = Color3.new(1, 1, 1)
TextButton35.AutoButtonColor = false
TextButton35.FontSize = Enum.FontSize.Size10
TextButton35.Text = "Parent:"
TextButton35.TextColor = BrickColor.new("Really black")
TextButton35.TextColor3 = Color3.new(0, 0, 0)
TextButton35.TextSize = 10
TextButton36.Name = "Parent Drop Down"
TextButton36.Parent = Frame31
TextButton36.Position = UDim2.new(0, 0, 0, 100)
TextButton36.Size = UDim2.new(1, 0, 0, 25)
TextButton36.BackgroundColor = BrickColor.new("Institutional white")
TextButton36.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton36.BackgroundTransparency = 0.5
TextButton36.BorderColor = BrickColor.new("Institutional white")
TextButton36.BorderColor3 = Color3.new(1, 1, 1)
TextButton36.FontSize = Enum.FontSize.Size10
TextButton36.Text = "Workspace"
TextButton36.TextColor = BrickColor.new("Dark stone grey")
TextButton36.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton36.TextSize = 10
TextButton37.Name = "Insert"
TextButton37.Parent = Frame31
TextButton37.Position = UDim2.new(0, 0, 0, 150)
TextButton37.Size = UDim2.new(1, 0, 0, 25)
TextButton37.BackgroundColor = BrickColor.new("Institutional white")
TextButton37.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton37.BackgroundTransparency = 0.5
TextButton37.BorderColor = BrickColor.new("Institutional white")
TextButton37.BorderColor3 = Color3.new(1, 1, 1)
TextButton37.FontSize = Enum.FontSize.Size10
TextButton37.Text = "Insert"
TextButton37.TextColor = BrickColor.new("Dark stone grey")
TextButton37.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton37.TextSize = 10
Script38.Name = "NewInstanceScript"
Script38.Parent = Frame31
table.insert(cors,sandbox(Script38,function()
Idd = script.Parent["Instance Drop Down"]
Pdd = script.Parent["Parent Drop Down"]
player = script.Parent.Parent.Parent.Parent.Parent

type = {
"Decal";
"Hint";
"Message";
"Model";
"Part";
"Script";
"Seat";
"SpawnLocation";
"Team";
"TrussPart";
"WedgePart";
}

parents = {
"Workspace";
"Lighting";
"StarterGui";
"StarterPack";
"Teams";
"Your Character"
}

Ilab = {}
Plab = {}
ctype = nil
cparent = "Workspace"

t = Idd:Clone()
t.Text = ""
t.BackgroundTransparency = 0.2
Iy = 25
Py = 25

function dropI()
	for i, v in pairs(type) do
		inew = t:Clone()
		inew.Text = v
		inew.ZIndex = 3
		inew.Position = UDim2.new(0,0,0,Iy)
		Iy = Iy + 25
		Ilab[#Ilab+1] = inew
		inew.Parent = Idd
		inew.MouseButton1Click:connect(function() Iclick(v) end)
	end 
	Iy = 25
end 

function clearI()
	for i, v in pairs(Idd:children()) do
		v:Remove()
	end 
end 

function Iclick(item)
	ctype = item
	clearI()
	Idd.Text = ctype
end 

function IddClicked()
	if Idd:children()[1] then
		clearI()
	else
		dropI()
	end 
end 

function dropP()
	for i, v in pairs(parents) do
		pnew = t:Clone()
		pnew.Text = v
		pnew.ZIndex = 3
		pnew.Position = UDim2.new(0,0,0,Py)
		Py = Py + 25
		Plab[#Ilab+1] = pnew
		pnew.Parent = Pdd
		pnew.MouseButton1Click:connect(function() Pclick(v) end)
	end 
	Py = 25
end 

function clearP()
	for i, v in pairs(Pdd:children()) do
		v:Remove()
	end 
end 

function Pclick(item)
	cparent = item
	clearP()
	Pdd.Text = cparent
end 

function PddClicked()
	if Pdd:children()[1] then
		clearP()
	else
		dropP()
	end 
end 

function findParent()
	if cparent == "Workspace" then
		return Workspace
	elseif cparent == "Lighting" then
		return game.Lighting
	elseif cparent == "StarterGui" then
		return game.StarterGui
	elseif cparent == "StarterPack" then
		return game.StarterPack
	elseif cparent == "Teams" then
		if game:findFirstChild("Teams") == nil then
			Instance.new("Teams").Parent = game
		end 
		return game.Teams
	elseif cparent == "Your Character" then
		return player.Character
	else
		return nil
	end 
end 

function insert()
	par = findParent()
	if par and ctype then
		ins = Instance.new(ctype)
		ins.Parent = par
		if ins:IsA("BasePart") then
			ins.Position = player.Character.Head.Position
		end 
		ctype = nil
		cparent = "Workspace"
		Idd.Text = "Select"
		Pdd.Text = "Workspace"
	end 
end 

Idd.MouseButton1Click:connect(IddClicked)
Pdd.MouseButton1Click:connect(PddClicked)
script.Parent.Insert.MouseButton1Click:connect(insert)
end))
TextButton39.Name = "Empty"
TextButton39.Parent = Frame4
TextButton39.Position = UDim2.new(0, 0, 0, 100)
TextButton39.Size = UDim2.new(0, 150, 0, 25)
TextButton39.BackgroundColor = BrickColor.new("Institutional white")
TextButton39.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton39.BackgroundTransparency = 0.5
TextButton39.BorderColor = BrickColor.new("Institutional white")
TextButton39.BorderColor3 = Color3.new(1, 1, 1)
TextButton39.FontSize = Enum.FontSize.Size10
TextButton39.Text = ""
TextButton39.TextColor = BrickColor.new("Dark stone grey")
TextButton39.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton39.TextSize = 10
TextButton40.Name = "Empty"
TextButton40.Parent = Frame4
TextButton40.Position = UDim2.new(0, 150, 0, 75)
TextButton40.Size = UDim2.new(0, 150, 0, 25)
TextButton40.BackgroundColor = BrickColor.new("Institutional white")
TextButton40.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton40.BackgroundTransparency = 0.5
TextButton40.BorderColor = BrickColor.new("Institutional white")
TextButton40.BorderColor3 = Color3.new(1, 1, 1)
TextButton40.FontSize = Enum.FontSize.Size10
TextButton40.Text = ""
TextButton40.TextColor = BrickColor.new("Dark stone grey")
TextButton40.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton40.TextSize = 10
TextButton41.Name = "Empty"
TextButton41.Parent = Frame4
TextButton41.Position = UDim2.new(0, 150, 0, 100)
TextButton41.Size = UDim2.new(0, 150, 0, 25)
TextButton41.BackgroundColor = BrickColor.new("Institutional white")
TextButton41.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton41.BackgroundTransparency = 0.5
TextButton41.BorderColor = BrickColor.new("Institutional white")
TextButton41.BorderColor3 = Color3.new(1, 1, 1)
TextButton41.FontSize = Enum.FontSize.Size10
TextButton41.Text = ""
TextButton41.TextColor = BrickColor.new("Dark stone grey")
TextButton41.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton41.TextSize = 10
TextButton42.Name = "InfoB"
TextButton42.Parent = Frame4
TextButton42.Position = UDim2.new(0, 150, 0, 125)
TextButton42.Size = UDim2.new(0, 150, 0, 25)
TextButton42.BackgroundColor = BrickColor.new("Institutional white")
TextButton42.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton42.BackgroundTransparency = 0.5
TextButton42.BorderColor = BrickColor.new("Institutional white")
TextButton42.BorderColor3 = Color3.new(1, 1, 1)
TextButton42.FontSize = Enum.FontSize.Size10
TextButton42.Text = "Info"
TextButton42.TextColor = BrickColor.new("Dark stone grey")
TextButton42.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton42.TextSize = 10
TextButton43.Name = "Clear"
TextButton43.Parent = Frame4
TextButton43.Position = UDim2.new(0, 0, 0, 125)
TextButton43.Size = UDim2.new(0, 150, 0, 25)
TextButton43.BackgroundColor = BrickColor.new("Institutional white")
TextButton43.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton43.BackgroundTransparency = 0.5
TextButton43.BorderColor = BrickColor.new("Institutional white")
TextButton43.BorderColor3 = Color3.new(1, 1, 1)
TextButton43.FontSize = Enum.FontSize.Size10
TextButton43.Text = "Clear Scripts"
TextButton43.TextColor = BrickColor.new("Dark stone grey")
TextButton43.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton43.TextSize = 10
Frame44.Name = "Info"
Frame44.Parent = Frame4
Frame44.Position = UDim2.new(0, 0, 0, 200)
Frame44.Visible = false
Frame44.Size = UDim2.new(0, 300, 0, 200)
Frame44.BackgroundColor = BrickColor.new("Oyster")
Frame44.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame44.BackgroundTransparency = 0.40000000596046
Frame44.BorderColor = BrickColor.new("Institutional white")
Frame44.BorderColor3 = Color3.new(1, 1, 1)
TextButton45.Name = "Close"
TextButton45.Parent = Frame44
TextButton45.Size = UDim2.new(1, 0, 0, 25)
TextButton45.BackgroundColor = BrickColor.new("Institutional white")
TextButton45.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton45.BackgroundTransparency = 0.5
TextButton45.BorderColor = BrickColor.new("Institutional white")
TextButton45.BorderColor3 = Color3.new(1, 1, 1)
TextButton45.FontSize = Enum.FontSize.Size10
TextButton45.Text = "Close"
TextButton45.TextColor = BrickColor.new("Dark stone grey")
TextButton45.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton45.TextSize = 10
TextButton46.Name = "Ttle"
TextButton46.Parent = Frame44
TextButton46.Position = UDim2.new(0, 0, 0, 25)
TextButton46.Size = UDim2.new(1, 0, 0, 25)
TextButton46.BackgroundColor = BrickColor.new("Institutional white")
TextButton46.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton46.BackgroundTransparency = 1
TextButton46.BorderColor = BrickColor.new("Institutional white")
TextButton46.BorderColor3 = Color3.new(1, 1, 1)
TextButton46.FontSize = Enum.FontSize.Size10
TextButton46.Text = "Hax Gui by Coolbob44"
TextButton46.TextColor = BrickColor.new("Really black")
TextButton46.TextColor3 = Color3.new(0, 0, 0)
TextButton46.TextSize = 10
TextButton47.Name = "Ttle"
TextButton47.Parent = Frame44
TextButton47.Position = UDim2.new(0, 0, 0, 50)
TextButton47.Size = UDim2.new(1, 0, 0, 25)
TextButton47.BackgroundColor = BrickColor.new("Institutional white")
TextButton47.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton47.BackgroundTransparency = 1
TextButton47.BorderColor = BrickColor.new("Institutional white")
TextButton47.BorderColor3 = Color3.new(1, 1, 1)
TextButton47.FontSize = Enum.FontSize.Size10
TextButton47.Text = "V. 3.1"
TextButton47.TextColor = BrickColor.new("Really black")
TextButton47.TextColor3 = Color3.new(0, 0, 0)
TextButton47.TextSize = 10
TextButton48.Name = "Ttle"
TextButton48.Parent = Frame44
TextButton48.Position = UDim2.new(0, 0, 0, 100)
TextButton48.Size = UDim2.new(1, 0, 0, 25)
TextButton48.BackgroundColor = BrickColor.new("Institutional white")
TextButton48.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton48.BackgroundTransparency = 1
TextButton48.BorderColor = BrickColor.new("Institutional white")
TextButton48.BorderColor3 = Color3.new(1, 1, 1)
TextButton48.FontSize = Enum.FontSize.Size10
TextButton48.Text = "Updates:"
TextButton48.TextColor = BrickColor.new("Really black")
TextButton48.TextColor3 = Color3.new(0, 0, 0)
TextButton48.TextSize = 10
TextButton49.Name = "Ttle"
TextButton49.Parent = Frame44
TextButton49.Position = UDim2.new(0, 0, 0, 115)
TextButton49.Size = UDim2.new(1, 0, 0, 25)
TextButton49.BackgroundColor = BrickColor.new("Institutional white")
TextButton49.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton49.BackgroundTransparency = 1
TextButton49.BorderColor = BrickColor.new("Institutional white")
TextButton49.BorderColor3 = Color3.new(1, 1, 1)
TextButton49.FontSize = Enum.FontSize.Size10
TextButton49.Text = "Minor UI Upgrades"
TextButton49.TextColor = BrickColor.new("Really black")
TextButton49.TextColor3 = Color3.new(0, 0, 0)
TextButton49.TextSize = 10
Frame50.Name = "Commands"
Frame50.Parent = Frame4
Frame50.Position = UDim2.new(0, 0, 0, 200)
Frame50.Visible = false
Frame50.Size = UDim2.new(0, 300, 0, 200)
Frame50.BackgroundColor = BrickColor.new("Oyster")
Frame50.BackgroundColor3 = Color3.new(0.698039, 0.698039, 0.698039)
Frame50.BackgroundTransparency = 0.40000000596046
Frame50.BorderColor = BrickColor.new("Institutional white")
Frame50.BorderColor3 = Color3.new(1, 1, 1)
TextButton51.Name = "Close"
TextButton51.Parent = Frame50
TextButton51.Size = UDim2.new(1, 0, 0, 25)
TextButton51.BackgroundColor = BrickColor.new("Institutional white")
TextButton51.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton51.BackgroundTransparency = 0.5
TextButton51.BorderColor = BrickColor.new("Institutional white")
TextButton51.BorderColor3 = Color3.new(1, 1, 1)
TextButton51.FontSize = Enum.FontSize.Size10
TextButton51.Text = "Close"
TextButton51.TextColor = BrickColor.new("Dark stone grey")
TextButton51.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton51.TextSize = 10
TextButton52.Name = "KillAll"
TextButton52.Parent = Frame50
TextButton52.Position = UDim2.new(0, 0, 0, 25)
TextButton52.Size = UDim2.new(1, 0, 0, 25)
TextButton52.BackgroundColor = BrickColor.new("Institutional white")
TextButton52.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton52.BackgroundTransparency = 0.5
TextButton52.BorderColor = BrickColor.new("Institutional white")
TextButton52.BorderColor3 = Color3.new(1, 1, 1)
TextButton52.FontSize = Enum.FontSize.Size10
TextButton52.Text = "Kill All"
TextButton52.TextColor = BrickColor.new("Dark stone grey")
TextButton52.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton52.TextSize = 10
TextButton53.Name = "DM"
TextButton53.Parent = Frame50
TextButton53.Position = UDim2.new(0, 0, 0, 50)
TextButton53.Size = UDim2.new(1, 0, 0, 25)
TextButton53.BackgroundColor = BrickColor.new("Institutional white")
TextButton53.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton53.BackgroundTransparency = 0.5
TextButton53.BorderColor = BrickColor.new("Institutional white")
TextButton53.BorderColor3 = Color3.new(1, 1, 1)
TextButton53.FontSize = Enum.FontSize.Size10
TextButton53.Text = "Destory Map"
TextButton53.TextColor = BrickColor.new("Dark stone grey")
TextButton53.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton53.TextSize = 10
TextButton54.Name = "DS"
TextButton54.Parent = Frame50
TextButton54.Position = UDim2.new(0, 0, 0, 75)
TextButton54.Size = UDim2.new(1, 0, 0, 25)
TextButton54.BackgroundColor = BrickColor.new("Institutional white")
TextButton54.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton54.BackgroundTransparency = 0.5
TextButton54.BorderColor = BrickColor.new("Institutional white")
TextButton54.BorderColor3 = Color3.new(1, 1, 1)
TextButton54.FontSize = Enum.FontSize.Size10
TextButton54.Text = "Remove Spawns"
TextButton54.TextColor = BrickColor.new("Dark stone grey")
TextButton54.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton54.TextSize = 10
TextButton55.Name = "Clean"
TextButton55.Parent = Frame50
TextButton55.Position = UDim2.new(0, 0, 0, 100)
TextButton55.Size = UDim2.new(1, 0, 0, 25)
TextButton55.BackgroundColor = BrickColor.new("Institutional white")
TextButton55.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton55.BackgroundTransparency = 0.5
TextButton55.BorderColor = BrickColor.new("Institutional white")
TextButton55.BorderColor3 = Color3.new(1, 1, 1)
TextButton55.FontSize = Enum.FontSize.Size10
TextButton55.Text = "Clean Workspace"
TextButton55.TextColor = BrickColor.new("Dark stone grey")
TextButton55.TextColor3 = Color3.new(0.372549, 0.372549, 0.372549)
TextButton55.TextSize = 10
Frame56.Name = "Intro"
Frame56.Parent = Frame4
Frame56.Size = UDim2.new(1, 0, 1, 0)
Frame56.BackgroundColor = BrickColor.new("Lily white")
Frame56.BackgroundColor3 = Color3.new(0.917647, 0.917647, 0.917647)
Frame56.BorderColor = BrickColor.new("Quill grey")
Frame56.BorderColor3 = Color3.new(0.866667, 0.866667, 0.866667)
Frame56.ZIndex = 2
TextLabel57.Name = "T1"
TextLabel57.Parent = Frame56
TextLabel57.Position = UDim2.new(0.5, 0, 0.5, -10)
TextLabel57.ZIndex = 3
TextLabel57.FontSize = Enum.FontSize.Size14
TextLabel57.Text = "Developer Panel"
TextLabel57.TextColor = BrickColor.new("Really black")
TextLabel57.TextColor3 = Color3.new(0, 0, 0)
TextLabel57.TextSize = 14
TextLabel58.Name = "T2"
TextLabel58.Parent = Frame56
TextLabel58.Position = UDim2.new(0.5, 0, 0.5, 10)
TextLabel58.ZIndex = 3
TextLabel58.FontSize = Enum.FontSize.Size12
TextLabel58.Text = "V3.1"
TextLabel58.TextColor = BrickColor.new("Really black")
TextLabel58.TextColor3 = Color3.new(0, 0, 0)
TextLabel58.TextSize = 12
TextLabel59.Name = "T3"
TextLabel59.Parent = Frame56
TextLabel59.Position = UDim2.new(0.5, 0, 0.5, 30)
TextLabel59.ZIndex = 3
TextLabel59.FontSize = Enum.FontSize.Size10
TextLabel59.Text = "   "
TextLabel59.TextColor = BrickColor.new("Really black")
TextLabel59.TextColor3 = Color3.new(0, 0, 0)
TextLabel59.TextSize = 10
TextButton60.Parent = Frame4
TextButton60.Position = UDim2.new(-0.333999991, 0, -0.407692313, 0)
TextButton60.Size = UDim2.new(0, 180, 0, 30)
TextButton60.BackgroundColor = BrickColor.new("Institutional white")
TextButton60.BackgroundColor3 = Color3.new(1, 1, 1)
TextButton60.Draggable = true
TextButton60.Style = Enum.ButtonStyle.RobloxRoundButton
TextButton60.Font = Enum.Font.ArialBold
TextButton60.FontSize = Enum.FontSize.Size14
TextButton60.Text = "Close and Open DEV Console"
TextButton60.TextSize = 14
Script61.Name = "PUT THIS IN THE WEAPON"
Script61.Parent = Frame4
table.insert(cors,sandbox(Script61,function()
local debounce = false

function getPlayer(humanoid) 
local players = game.Players:children() 
for i = 1, #players do 
if players[i].Character.Humanoid == humanoid then return players[i] end 
end 
return nil 
end 

function onTouch(part) 

local human = part.Parent:findFirstChild("Humanoid") 
if (human ~= nil) and debounce == false then

debounce = true

local player = getPlayer(human) 

if (player == nil) then return end 

script.Parent:clone().Parent = player.Backpack

wait(2)
debounce = false
end
end


script.Parent.Parent.Touched:connect(onTouch) 

end))
Model62.Name = "F3X Giver"
Model62.Parent = Model1
Part63.Name = "Smooth Block Model"
Part63.Parent = Model62
Part63.CFrame = CFrame.new(104.582458, 428.933228, -61.912796, -1, 0, 0, 0, 1, 0, 0, 0, -1)
Part63.Orientation = Vector3.new(0, 180, 0)
Part63.Position = Vector3.new(104.582458, 428.933228, -61.912796)
Part63.Rotation = Vector3.new(-180, 0, -180)
Part63.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part63.Size = Vector3.new(3, 6, 1)
Part63.Anchored = true
Part63.BrickColor = BrickColor.new("Dark stone grey")
Part63.brickColor = BrickColor.new("Dark stone grey")
ManualWeld64.Name = "Smooth Block Model-to-Handle Strong Joint"
ManualWeld64.Parent = Part63
ManualWeld64.C0 = CFrame.new(-1.5, -3, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1)
ManualWeld64.C1 = CFrame.new(0.399999619, -0.400000006, -1.60000014, 0, 0, -1, 0, 1, 0, 1, 0, 0)
ManualWeld64.Part0 = Part63
ManualWeld64.Part1 = Part89
ManualWeld64.part1 = Part89
ManualWeld65.Name = "Smooth Block Model-to-Smooth Block Model Strong Joint"
ManualWeld65.Parent = Part63
ManualWeld65.C0 = CFrame.new(1.5, -3, 0.5, 0, 0, 1, 0, 1, -0, -1, 0, 0)
ManualWeld65.C1 = CFrame.new(0.500034332, -3.00098228, -0.500074387, 0.999999702, -1.26416526e-05, 1.04807905e-05, 1.26419191e-05, 1, -2.31131762e-05, -1.04804976e-05, 2.31133472e-05, 0.999999702)
ManualWeld65.Part0 = Part63
ManualWeld65.Part1 = Part66
ManualWeld65.part1 = Part66
Part66.Name = "Smooth Block Model"
Part66.Parent = Model62
Part66.CFrame = CFrame.new(102.582443, 428.934296, -62.9128036, -1.04807905e-05, 2.31131762e-05, -0.999999702, -1.26416526e-05, 1, 2.31133472e-05, 0.999999702, 1.26419191e-05, -1.04804976e-05)
Part66.Orientation = Vector3.new(0, -90, 0)
Part66.Position = Vector3.new(102.582443, 428.934296, -62.9128036)
Part66.Rotation = Vector3.new(-114.389999, -89.9599991, -114.389999)
Part66.Color = Color3.new(0.388235, 0.372549, 0.384314)
Part66.Size = Vector3.new(3, 6, 1)
Part66.Anchored = true
Part66.BrickColor = BrickColor.new("Dark stone grey")
Part66.brickColor = BrickColor.new("Dark stone grey")
Part67.Name = "PUT THE WEAPON IN THIS BRICK"
Part67.Parent = Model62
Part67.CFrame = CFrame.new(103.704468, 428.63916, -60.9127846, 1.04791525e-05, -0.000129477179, 0.999998152, 4.31596272e-05, 1, 0.000129476757, -0.999998152, 4.31583503e-05, 1.0484735e-05)
Part67.Orientation = Vector3.new(-0.00999999978, 90, 0)
Part67.Position = Vector3.new(103.704468, 428.63916, -60.9127846)
Part67.Rotation = Vector3.new(-85.3699951, 89.8899994, 85.3699951)
Part67.Color = Color3.new(0, 1, 0)
Part67.Size = Vector3.new(1, 1.20000005, 3.24000001)
Part67.Anchored = true
Part67.BrickColor = BrickColor.new("Lime green")
Part67.TopSurface = Enum.SurfaceType.Smooth
Part67.brickColor = BrickColor.new("Lime green")
Tool68.Name = "Building Tools"
Tool68.Parent = Part67
Tool68.ToolTip = "Building Tools by F3X"
LocalScript69.Name = "Building Tools by F3X"
LocalScript69.Parent = Tool68
table.insert(cors,sandbox(LocalScript69,function()
------------------------------------------
-- Create references to important objects
------------------------------------------
Services = {
	["Workspace"] = Game:GetService( "Workspace" );
	["Players"] = Game:GetService( "Players" );
	["Lighting"] = Game:GetService( "Lighting" );
	["Teams"] = Game:GetService( "Teams" );
	["Debris"] = Game:GetService( "Debris" );
	["MarketplaceService"] = Game:GetService( "MarketplaceService" );
	["JointsService"] = Game.JointsService;
	["BadgeService"] = Game:GetService( "BadgeService" );
	["RunService"] = Game:GetService( "RunService" );
	["ContentProvider"] = Game:GetService( "ContentProvider" );
	["TeleportService"] = Game:GetService( "TeleportService" );
	["SoundService"] = Game:GetService( "SoundService" );
	["InsertService"] = Game:GetService( "InsertService" );
	["CollectionService"] = Game:GetService( "CollectionService" );
	["UserInputService"] = Game:GetService( "UserInputService" );
	["GamePassService"] = Game:GetService( "GamePassService" );
	["StarterPack"] = Game:GetService( "StarterPack" );
	["StarterGui"] = Game:GetService( "StarterGui" );
	["TestService"] = Game:GetService( "TestService" );
	["ReplicatedStorage"] = Game:GetService( "ReplicatedStorage" );
	["Selection"] = Game:GetService( "Selection" );
	["CoreGui"] = Game:GetService( "CoreGui" );
};

Tool = script.Parent;
Player = Services.Players.LocalPlayer;
Mouse = nil;

-- Determine whether this is the plugin or tool
if plugin then
	ToolType = 'plugin';
elseif Tool:IsA( 'Tool' ) then
	ToolType = 'tool';
end;

-- Get tool type-specific resources
if ToolType == 'tool' then
	GUIContainer = Player:WaitForChild( 'PlayerGui' );
	in_server = not not Game:FindFirstChild( 'NetworkClient' );
elseif ToolType == 'plugin' then
	GUIContainer = Services.CoreGui;
	in_server = not not Game:FindFirstChild( 'NetworkServer' );
end;
if in_server then
	Tool:WaitForChild( "GetAsync" );
	Tool:WaitForChild( "PostAsync" );
	GetAsync = function ( ... )
		return Tool.GetAsync:InvokeServer( ... );
	end;
	PostAsync = function ( ... )
		return Tool.PostAsync:InvokeServer( ... );
	end;
end;

dark_slanted_rectangle = "http://www.roblox.com/asset/?id=127774197";
light_slanted_rectangle = "http://www.roblox.com/asset/?id=127772502";
action_completion_sound = "http://www.roblox.com/asset/?id=99666917";
expand_arrow = "http://www.roblox.com/asset/?id=134367382";
tool_decal = "http://www.roblox.com/asset/?id=129748355";
undo_active_decal = "http://www.roblox.com/asset/?id=141741408";
undo_inactive_decal = "http://www.roblox.com/asset/?id=142074557";
redo_active_decal = "http://www.roblox.com/asset/?id=141741327";
redo_inactive_decal = "http://www.roblox.com/asset/?id=142074553";
delete_active_decal = "http://www.roblox.com/asset/?id=141896298";
delete_inactive_decal = "http://www.roblox.com/asset/?id=142074644";
export_active_decal = "http://www.roblox.com/asset/?id=141741337";
export_inactive_decal = "http://www.roblox.com/asset/?id=142074569";
clone_active_decal = "http://www.roblox.com/asset/?id=142073926";
clone_inactive_decal = "http://www.roblox.com/asset/?id=142074563";
plugin_icon = "http://www.roblox.com/asset/?id=142287521";

------------------------------------------
-- Load external dependencies
------------------------------------------
RbxUtility = LoadLibrary( "RbxUtility" );
Services.ContentProvider:Preload( dark_slanted_rectangle );
Services.ContentProvider:Preload( light_slanted_rectangle );
Services.ContentProvider:Preload( action_completion_sound );
Services.ContentProvider:Preload( expand_arrow );
Services.ContentProvider:Preload( tool_decal );
Services.ContentProvider:Preload( undo_active_decal );
Services.ContentProvider:Preload( undo_inactive_decal );
Services.ContentProvider:Preload( redo_inactive_decal );
Services.ContentProvider:Preload( redo_active_decal );
Services.ContentProvider:Preload( delete_active_decal );
Services.ContentProvider:Preload( delete_inactive_decal );
Services.ContentProvider:Preload( export_active_decal );
Services.ContentProvider:Preload( export_inactive_decal );
Services.ContentProvider:Preload( clone_active_decal );
Services.ContentProvider:Preload( clone_inactive_decal );
Services.ContentProvider:Preload( plugin_icon );
Tool:WaitForChild( "Interfaces" );
repeat wait( 0 ) until _G.gloo;
Gloo = _G.gloo;

------------------------------------------
-- Define functions that are depended-upon
------------------------------------------
function _findTableOccurrences( haystack, needle )
	-- Returns the positions of instances of `needle` in table `haystack`
	local positions = {};

	-- Add any indexes from `haystack` that have `needle`
	for index, value in pairs( haystack ) do
		if value == needle then
			table.insert( positions, index );
		end;
	end;

	return positions;
end;

function _getCollectionInfo( part_collection )
	-- Returns the size and position of collection of parts `part_collection`

	-- Get the corners
	local corners = {};

	-- Create shortcuts to certain things that are expensive to call constantly
	-- (note: otherwise it actually becomes an issue if the selection grows
	-- considerably large)
	local table_insert = table.insert;
	local newCFrame = CFrame.new;

	for _, Part in pairs( part_collection ) do

		local PartCFrame = Part.CFrame;
		local partCFrameOffset = PartCFrame.toWorldSpace;
		local PartSize = Part.Size / 2;
		local size_x, size_y, size_z = PartSize.x, PartSize.y, PartSize.z;

		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( size_x, size_y, size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( -size_x, size_y, size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( size_x, -size_y, size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( size_x, size_y, -size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( -size_x, size_y, -size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( -size_x, -size_y, size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( size_x, -size_y, -size_z ) ) );
		table_insert( corners, partCFrameOffset( PartCFrame, newCFrame( -size_x, -size_y, -size_z ) ) );

	end;

	-- Get the extents
	local x, y, z = {}, {}, {};

	for _, Corner in pairs( corners ) do
		table_insert( x, Corner.x );
		table_insert( y, Corner.y );
		table_insert( z, Corner.z );
	end;

	local x_min, y_min, z_min = math.min( unpack( x ) ),
								math.min( unpack( y ) ),
								math.min( unpack( z ) );

	local x_max, y_max, z_max = math.max( unpack( x ) ),
								math.max( unpack( y ) ),
								math.max( unpack( z ) );

	-- Get the size between the extents
	local x_size, y_size, z_size = 	x_max - x_min,
									y_max - y_min,
									z_max - z_min;

	local Size = Vector3.new( x_size, y_size, z_size );

	-- Get the centroid of the collection of points
	local Position = CFrame.new( 	x_min + ( x_max - x_min ) / 2,
									y_min + ( y_max - y_min ) / 2,
									z_min + ( z_max - z_min ) / 2 );

	-- Return the size of the collection of parts
	return Size, Position;
end;

function _round( number, places )
	-- Returns `number` rounded to the number of decimal `places`
	-- (from lua-users)

	local mult = 10 ^ ( places or 0 );

	return math.floor( number * mult + 0.5 ) / mult;

end

function _cloneTable( source )
	-- Returns a deep copy of table `source`

	-- Get a copy of `source`'s metatable, since the hacky method
	-- we're using to copy the table doesn't include its metatable
	local source_mt = getmetatable( source );

	-- Return a copy of `source` including its metatable
	return setmetatable( { unpack( source ) }, source_mt );
end;

function _getAllDescendants( Parent )
	-- Recursively gets all the descendants of  `Parent` and returns them

	local descendants = {};

	for _, Child in pairs( Parent:GetChildren() ) do

		-- Add the direct descendants of `Parent`
		table.insert( descendants, Child );

		-- Add the descendants of each child
		for _, Subchild in pairs( _getAllDescendants( Child ) ) do
			table.insert( descendants, Subchild );
		end;

	end;

	return descendants;

end;

function _pointToScreenSpace( Point )
	-- Returns Vector3 `Point`'s position on the screen when rendered
	-- (kudos to stravant for this)

	local point = Services.Workspace.CurrentCamera.CoordinateFrame:pointToObjectSpace( Point );
	local aspectRatio = Mouse.ViewSizeX / Mouse.ViewSizeY;
	local hfactor = math.tan( math.rad( Services.Workspace.CurrentCamera.FieldOfView ) / 2 )
	local wfactor = aspectRatio * hfactor;

	local x = ( point.x / point.z ) / -wfactor;
	local y = ( point.y / point.z ) /  hfactor;

	local screen_pos = Vector2.new( Mouse.ViewSizeX * ( 0.5 + 0.5 * x ), Mouse.ViewSizeY * ( 0.5 + 0.5 * y ) );
	if ( screen_pos.x < 0 or screen_pos.x > Mouse.ViewSizeX ) or ( screen_pos.y < 0 or screen_pos.y > Mouse.ViewSizeY ) then
		return nil;
	end;
	if Services.Workspace.CurrentCamera.CoordinateFrame:toObjectSpace( CFrame.new( Point ) ).z > 0 then
		return nil;
	end;

	return screen_pos;

end;

function _cloneParts( parts )
	-- Returns a table of cloned `parts`

	local new_parts = {};

	-- Copy the parts into `new_parts`
	for part_index, Part in pairs( parts ) do
		new_parts[part_index] = Part:Clone();
	end;

	return new_parts;
end;

function _replaceParts( old_parts, new_parts )
	-- Removes `old_parts` and inserts `new_parts`

	-- Remove old parts
	for _, OldPart in pairs( old_parts ) do
		OldPart.Parent = nil;
	end;

	-- Insert `new_parts
	for _, NewPart in pairs( new_parts ) do
		NewPart.Parent = Services.Workspace;
		NewPart:MakeJoints();
	end;

end;

function _splitString( str, delimiter )
	-- Returns a table of string `str` split by pattern `delimiter`

	local parts = {};
	local pattern = ( "([^%s]+)" ):format( delimiter );

	str:gsub( pattern, function ( part )
		table.insert( parts, part );
	end );

	return parts;
end;

function _generateSerializationID()
	-- Returns a random 5-character string
	-- with characters A-Z, a-z, and 0-9
	-- (there are 916,132,832 unique IDs)

	local characters = {
		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
		"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
		"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };

	local serialization_id = "";

	-- Pick out 5 random characters
	for _ = 1, 5 do
		serialization_id = serialization_id .. ( characters[math.random( #characters )] );
	end;

	return serialization_id;
end;

function _splitNumberListString( str )
	-- Returns the contents of _splitString( str, ", " ), except
	-- each value in the table is turned into a number

	-- Get the number strings
	local numbers = _splitString( str, ", " );

	-- Turn them into numbers
	for number_index, number in pairs( numbers ) do
		numbers[number_index] = tonumber( number );
	end;

	-- Return `numbers`
	return numbers;
end;

function _getSerializationPartType( Part )
	-- Returns a special number that determines the type of
	-- part `Part` is

	local Types = {
		Normal = 1,
		Truss = 2,
		Wedge = 3,
		Corner = 4,
		Cylinder = 5,
		Ball = 6,
		Seat = 7,
		VehicleSeat = 8,
		Spawn = 9
	};

	-- Return the appropriate type number
	if Part.ClassName == "Part" then
		if Part.Shape == Enum.PartType.Block then
			return Types.Normal;
		elseif Part.Shape == Enum.PartType.Cylinder then
			return Types.Cylinder;
		elseif Part.Shape == Enum.PartType.Ball then
			return Types.Ball;
		end;

	elseif Part.ClassName == "Seat" then
		return Types.Seat;

	elseif Part.ClassName == "VehicleSeat" then
		return Types.VehicleSeat;

	elseif Part.ClassName == "SpawnLocation" then
		return Types.Spawn;

	elseif Part.ClassName == "WedgePart" then
		return Types.Wedge;

	elseif Part.ClassName == "CornerWedgePart" then
		return Types.Corner;

	elseif Part.ClassName == "TrussPart" then
		return Types.Truss;

	end;

end;

function _serializeParts( parts )
	-- Returns JSON-encoded data about parts in
	-- table `parts` that can be used to recreate them

	local data = {
		version = 1,
		parts = {}
	};

	local objects = {};

	-- Store part data
	for _, Part in pairs( parts ) do
		local part_id = _generateSerializationID();
		local PartData = {
			_getSerializationPartType( Part ),
			_splitNumberListString( tostring( Part.Size ) ),
			_splitNumberListString( tostring( Part.CFrame ) ),
			Part.BrickColor.Number,
			Part.Material.Value,
			Part.Anchored,
			Part.CanCollide,
			Part.Reflectance,
			Part.Transparency,
			Part.TopSurface.Value,
			Part.BottomSurface.Value,
			Part.LeftSurface.Value,
			Part.RightSurface.Value,
			Part.FrontSurface.Value,
			Part.BackSurface.Value
		};
		data.parts[part_id] = PartData;
		objects[part_id] = Part;
	end;

	-- Get any welds in the selection
	local welds = {};
	for object_id, Object in pairs( objects ) do
		if Object:IsA( "BasePart" ) then
			for _, Joint in pairs( _getAllDescendants( Services.Workspace ) ) do
				if Joint:IsA( "Weld" ) and Joint.Name == "BTWeld" then
					if Joint.Part0 == Object and #_findTableOccurrences( objects, Joint.Part1 ) > 0 then
						table.insert( welds, Joint );
					end;
				end;
			end;
		end;
	end;

	-- Serialize any welds
	if #welds > 0 then
		data.welds = {};
		for _, Weld in pairs( welds ) do
			local weld_id = _generateSerializationID();
			local WeldData = {
				_findTableOccurrences( objects, Weld.Part0 )[1],
				_findTableOccurrences( objects, Weld.Part1 )[1],
				_splitNumberListString( tostring( Weld.C1 ) )
			};
			data.welds[weld_id] = WeldData;
			objects[weld_id] = Weld;
		end;
	end;

	-- Get any meshes in the selection
	local meshes = {};
	for _, Part in pairs( parts ) do
		local Mesh = _getChildOfClass( Part, "SpecialMesh" );
		if Mesh then
			table.insert( meshes, Mesh );
		end;
	end;

	-- Serialize any meshes
	if #meshes > 0 then
		data.meshes = {};
		for _, Mesh in pairs( meshes ) do
			local mesh_id = _generateSerializationID();
			local MeshData = {
				_findTableOccurrences( objects, Mesh.Parent )[1],
				Mesh.MeshType.Value,
				_splitNumberListString( tostring( Mesh.Scale ) ),
				Mesh.MeshId,
				Mesh.TextureId,
				_splitNumberListString( tostring( Mesh.VertexColor ) )
			};
			data.meshes[mesh_id] = MeshData;
			objects[mesh_id] = Mesh;
		end;
	end;

	-- Get any textures in the selection
	local textures = {};
	for _, Part in pairs( parts ) do
		local textures_found = _getChildrenOfClass( Part, "Texture" );
		for _, Texture in pairs( textures_found ) do
			table.insert( textures, Texture );
		end;
		local decals_found = _getChildrenOfClass( Part, "Decal" );
		for _, Decal in pairs( decals_found ) do
			table.insert( textures, Decal );
		end;
	end;

	-- Serialize any textures
	if #textures > 0 then
		data.textures = {};
		for _, Texture in pairs( textures ) do
			local texture_type;
			if Texture.ClassName == "Decal" then
				texture_type = 1;
			elseif Texture.ClassName == "Texture" then
				texture_type = 2;
			end;
			local texture_id = _generateSerializationID();
			local TextureData = {
				_findTableOccurrences( objects, Texture.Parent )[1],
				texture_type,
				Texture.Face.Value,
				Texture.Texture,
				Texture.Transparency,
				texture_type == 2 and Texture.StudsPerTileU or nil,
				texture_type == 2 and Texture.StudsPerTileV or nil
			};
			data.textures[texture_id] = TextureData;
			objects[texture_id] = Texture;
		end;
	end;

	-- Get any lights in the selection
	local lights = {};
	for _, Part in pairs( parts ) do
		local lights_found = _getChildrenOfClass( Part, "Light", true );
		for _, Light in pairs( lights_found ) do
			table.insert( lights, Light );
		end;
	end;

	-- Serialize any lights
	if #lights > 0 then
		data.lights = {};
		for _, Light in pairs( lights ) do
			local light_type;
			if Light:IsA( "PointLight" ) then
				light_type = 1;
			elseif Light:IsA( "SpotLight" ) then
				light_type = 2;
			end;
			local light_id = _generateSerializationID();
			local LightData = {
				_findTableOccurrences( objects, Light.Parent )[1];
				light_type,
				_splitNumberListString( tostring( Light.Color ) ),
				Light.Brightness,
				Light.Range,
				Light.Shadows,
				light_type == 2 and Light.Angle or nil,
				light_type == 2 and Light.Face.Value or nil
			};
			data.lights[light_id] = LightData;
			objects[light_id] = Light;
		end;
	end;

	-- Get any decorations in the selection
	local decorations = {};
	for _, Part in pairs( parts ) do
		table.insert( decorations, _getChildOfClass( Part, 'Smoke' ) )
		table.insert( decorations, _getChildOfClass( Part, 'Fire' ) );
		table.insert( decorations, _getChildOfClass( Part, 'Sparkles' ) );
	end;

	-- Serialize any decorations
	if #decorations > 0 then
		data.decorations = {};
		for _, Decoration in pairs( decorations ) do
			local decoration_type;
			if Decoration:IsA( 'Smoke' ) then
				decoration_type = 1;
			elseif Decoration:IsA( 'Fire' ) then
				decoration_type = 2;
			elseif Decoration:IsA( 'Sparkles' ) then
				decoration_type = 3;
			end;
			local decoration_id = _generateSerializationID();
			local DecorationData = {
				_findTableOccurrences( objects, Decoration.Parent )[1],
				decoration_type
			};
			if decoration_type == 1 then
				DecorationData[3] = _splitNumberListString( tostring( Decoration.Color ) );
				DecorationData[4] = Decoration.Opacity;
				DecorationData[5] = Decoration.RiseVelocity;
				DecorationData[6] = Decoration.Size;
			elseif decoration_type == 2 then
				DecorationData[3] = _splitNumberListString( tostring( Decoration.Color ) );
				DecorationData[4] = _splitNumberListString( tostring( Decoration.SecondaryColor ) );
				DecorationData[5] = Decoration.Heat;
				DecorationData[6] = Decoration.Size;
			elseif decoration_type == 3 then
				DecorationData[3] = _splitNumberListString( tostring( Decoration.SparkleColor ) );
			end;
			data.decorations[decoration_id] = DecorationData;
			objects[decoration_id] = Decoration;
		end;
	end;

	return RbxUtility.EncodeJSON( data );

end;

function _getChildOfClass( Parent, class_name, inherit )
	-- Returns the first child of `Parent` that is of class `class_name`
	-- or nil if it couldn't find any

	-- Look for a child of `Parent` of class `class_name` and return it
	if not inherit then
		for _, Child in pairs( Parent:GetChildren() ) do
			if Child.ClassName == class_name then
				return Child;
			end;
		end;
	else
		for _, Child in pairs( Parent:GetChildren() ) do
			if Child:IsA( class_name ) then
				return Child;
			end;
		end;
	end;

	return nil;

end;

function _getChildrenOfClass( Parent, class_name, inherit )
	-- Returns a table containing the children of `Parent` that are
	-- of class `class_name`
	local matches = {};


	if not inherit then
		for _, Child in pairs( Parent:GetChildren() ) do
			if Child.ClassName == class_name then
				table.insert( matches, Child );
			end;
		end;
	else
		for _, Child in pairs( Parent:GetChildren() ) do
			if Child:IsA( class_name ) then
				table.insert( matches, Child );
			end;
		end;
	end;

	return matches;
end;

function _HSVToRGB( hue, saturation, value )
	-- Returns the RGB equivalent of the given HSV-defined color
	-- (adapted from some code found around the web)

	-- If it's achromatic, just return the value
	if saturation == 0 then
		return value;
	end;

	-- Get the hue sector
	local hue_sector = math.floor( hue / 60 );
	local hue_sector_offset = ( hue / 60 ) - hue_sector;

	local p = value * ( 1 - saturation );
	local q = value * ( 1 - saturation * hue_sector_offset );
	local t = value * ( 1 - saturation * ( 1 - hue_sector_offset ) );

	if hue_sector == 0 then
		return value, t, p;
	elseif hue_sector == 1 then
		return q, value, p;
	elseif hue_sector == 2 then
		return p, value, t;
	elseif hue_sector == 3 then
		return p, q, value;
	elseif hue_sector == 4 then
		return t, p, value;
	elseif hue_sector == 5 then
		return value, p, q;
	end;
end;

function _RGBToHSV( red, green, blue )
	-- Returns the HSV equivalent of the given RGB-defined color
	-- (adapted from some code found around the web)

	local hue, saturation, value;

	local min_value = math.min( red, green, blue );
	local max_value = math.max( red, green, blue );

	value = max_value;

	local value_delta = max_value - min_value;

	-- If the color is not black
	if max_value ~= 0 then
		saturation = value_delta / max_value;

	-- If the color is purely black
	else
		saturation = 0;
		hue = -1;
		return hue, saturation, value;
	end;

	if red == max_value then
		hue = ( green - blue ) / value_delta;
	elseif green == max_value then
		hue = 2 + ( blue - red ) / value_delta;
	else
		hue = 4 + ( red - green ) / value_delta;
	end;

	hue = hue * 60;
	if hue < 0 then
		hue = hue + 360;
	end;

	return hue, saturation, value;
end;

------------------------------------------
-- Create data containers
------------------------------------------
ActiveKeys = {};

CurrentTool = nil;

function equipTool( NewTool )

	-- If it's a different tool than the current one
	if CurrentTool ~= NewTool then

		-- Run (if existent) the old tool's `Unequipped` listener
		if CurrentTool and CurrentTool.Listeners.Unequipped then
			CurrentTool.Listeners.Unequipped();
		end;

		CurrentTool = NewTool;

		-- Recolor the handle
		if ToolType == 'tool' then
			Tool.Handle.BrickColor = NewTool.Color;
		end;

		-- Highlight the right button on the dock
		for _, Button in pairs( Dock.ToolButtons:GetChildren() ) do
			Button.BackgroundTransparency = 1;
		end;
		local Button = Dock.ToolButtons:FindFirstChild( getToolName( NewTool ) .. "Button" );
		if Button then
			Button.BackgroundTransparency = 0;
		end;

		-- Run (if existent) the new tool's `Equipped` listener
		if NewTool.Listeners.Equipped then
			NewTool.Listeners.Equipped();
		end;

	end;
end;

function cloneSelection()
	-- Clones the items in the selection

	-- Make sure that there are items in the selection
	if #Selection.Items > 0 then

		local item_copies = {};

		-- Make a copy of every item in the selection and add it to table `item_copies`
		for _, Item in pairs( Selection.Items ) do
			local ItemCopy = Item:Clone();
			ItemCopy.Parent = Services.Workspace;
			table.insert( item_copies, ItemCopy );
		end;

		-- Replace the selection with the copied items
		Selection:clear();
		for _, Item in pairs( item_copies ) do
			Selection:add( Item );
		end;

		local HistoryRecord = {
			copies = item_copies;
			unapply = function ( self )
				for _, Copy in pairs( self.copies ) do
					if Copy then
						Copy.Parent = nil;
					end;
				end;
			end;
			apply = function ( self )
				Selection:clear();
				for _, Copy in pairs( self.copies ) do
					if Copy then
						Copy.Parent = Services.Workspace;
						Copy:MakeJoints();
						Selection:add( Copy );
					end;
				end;
			end;
		};
		History:add( HistoryRecord );

		-- Play a confirmation sound
		local Sound = RbxUtility.Create "Sound" {
			Name = "BTActionCompletionSound";
			Pitch = 1.5;
			SoundId = action_completion_sound;
			Volume = 1;
			Parent = Player or Services.SoundService;
		};
		Sound:Play();
		Sound:Destroy();

		-- Highlight the outlines of the new parts
		coroutine.wrap( function ()
			for transparency = 1, 0.5, -0.1 do
				for Item, SelectionBox in pairs( SelectionBoxes ) do
					SelectionBox.Transparency = transparency;
				end;
				wait( 0.1 );
			end;
		end )();

	end;

end;

function deleteSelection()
	-- Deletes the items in the selection

	if #Selection.Items == 0 then
		return;
	end;

	local selection_items = _cloneTable( Selection.Items );

	-- Create a history record
	local HistoryRecord = {
		targets = selection_items;
		parents = {};
		apply = function ( self )
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.Parent = nil;
				end;
			end;
		end;
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.Parent = self.parents[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};

	for _, Item in pairs( selection_items ) do
		HistoryRecord.parents[Item] = Item.Parent;
		Item.Parent = nil;
	end;

	History:add( HistoryRecord );

end;

function prismSelect()
	-- Selects all the parts within the area of the selected parts

	-- Make sure parts to define the area are present
	if #Selection.Items == 0 then
		return;
	end;

	local parts = {};

	-- Get all the parts in workspace
	local workspace_parts = {};
	local workspace_children = _getAllDescendants( Services.Workspace );
	for _, Child in pairs( workspace_children ) do
		if Child:IsA( 'BasePart' ) and not Selection:find( Child ) then
			table.insert( workspace_parts, Child );
		end;
	end;

	-- Go through each part and perform area tests on each one
	local checks = {};
	for _, Item in pairs( workspace_parts ) do
		checks[Item] = 0;
		for _, SelectionItem in pairs( Selection.Items ) do

			-- Calculate the position of the item in question in relation to the area-defining parts
			local offset = SelectionItem.CFrame:toObjectSpace( Item.CFrame );
			local extents = SelectionItem.Size / 2;

			-- Check the item off if it passed this test (if it's within the range of the extents)
			if ( math.abs( offset.x ) <= extents.x ) and ( math.abs( offset.y ) <= extents.y ) and ( math.abs( offset.z ) <= extents.z ) then
				checks[Item] = checks[Item] + 1;
			end;

		end;
	end;

	-- Delete the parts that were used to select the area
	local selection_items = _cloneTable( Selection.Items );
	local selection_item_parents = {};
	for _, Item in pairs( selection_items ) do
		selection_item_parents[Item] = Item.Parent;
		Item.Parent = nil;
	end;

	-- Select the parts that passed any area checks
	for _, Item in pairs( workspace_parts ) do
		if checks[Item] > 0 then
			Selection:add( Item );
		end;
	end;

	-- Add a history record
	History:add( {
		selection_parts = selection_items;
		selection_part_parents = selection_item_parents;
		new_selection = _cloneTable( Selection.Items );
		apply = function ( self )
			Selection:clear();
			for _, Item in pairs( self.selection_parts ) do
				Item.Parent = nil;
			end;
			for _, Item in pairs( self.new_selection ) do
				Selection:add( Item );
			end;
		end;
		unapply = function ( self )
			Selection:clear();
			for _, Item in pairs( self.selection_parts ) do
				Item.Parent = self.selection_part_parents[Item];
				Selection:add( Item );
			end;
		end;
	} );

end;

function toggleHelp()

	-- Make sure the dock is ready
	if not Dock then
		return;
	end;

	-- Toggle the visibility of the help tooltip
	Dock.HelpInfo.Visible = not Dock.HelpInfo.Visible;

end;

function getToolName( tool )
	-- Returns the name of `tool` as registered in `Tools`

	local name_search = _findTableOccurrences( Tools, tool );
	if #name_search > 0 then
		return name_search[1];
	end;

end;

function isSelectable( Object )
	-- Returns whether `Object` is selectable

	if not Object or not Object.Parent or not Object:IsA( "BasePart" ) or Object.Locked or Selection:find( Object ) then
		return false;
	end;

	-- If it passes all checks, return true
	return true;
end;

-- Keep some state data
clicking = false;
selecting = false;
click_x, click_y = 0, 0;
override_selection = false;

SelectionBoxes = {};
SelectionExistenceListeners = {};
SelectionBoxColor = BrickColor.new( "Cyan" );
TargetBox = nil;

-- Keep a container for temporary connections
-- from the platform
Connections = {};

-- Set the grip for the handle
if ToolType == 'tool' then
	Tool.Grip = CFrame.new( 0, 0, 0.4 );
end;

-- Make sure the UI container gets placed
UI = RbxUtility.Create "ScreenGui" {
	Name = "Building Tools by F3X (UI)"
};
if ToolType == 'tool' then
	UI.Parent = GUIContainer;
elseif ToolType == 'plugin' then
	UI.Parent = Services.CoreGui;
end;

Dragger = nil;

function updateSelectionBoxColor()
	-- Updates the color of the selectionboxes
	for _, SelectionBox in pairs( SelectionBoxes ) do
		SelectionBox.Color = SelectionBoxColor;
	end;
end;

Selection = {

	["Items"] = {};

	-- Provide events to listen to changes in the selection
	["Changed"] = RbxUtility.CreateSignal();
	["ItemAdded"] = RbxUtility.CreateSignal();
	["ItemRemoved"] = RbxUtility.CreateSignal();

	-- Provide a method to get an item's index in the selection
	["find"] = function ( self, Needle )

		-- Look through all the selected items and return the matching item's index
		for item_index, Item in pairs( self.Items ) do
			if Item == Needle then
				return item_index;
			end;
		end;

		-- Otherwise, return `nil`

	end;

	-- Provide a method to add items to the selection
	["add"] = function ( self, NewPart )

		-- Make sure `NewPart` is selectable
		if not isSelectable( NewPart ) then
			return false;
		end;

		-- Make sure `NewPart` isn't already in the selection
		if #_findTableOccurrences( self.Items, NewPart ) > 0 then
			return false;
		end;

		-- Insert it into the selection
		table.insert( self.Items, NewPart );

		-- Add its SelectionBox
		SelectionBoxes[NewPart] = Instance.new( "SelectionBox", UI );
		SelectionBoxes[NewPart].Name = "BTSelectionBox";
		SelectionBoxes[NewPart].Color = SelectionBoxColor;
		SelectionBoxes[NewPart].Adornee = NewPart;
		SelectionBoxes[NewPart].Transparency = 0.5;

		-- Remove any target selection box focus
		if NewPart == TargetBox.Adornee then
			TargetBox.Adornee = nil;
		end;

		-- Make sure to remove the item from the selection when it's deleted
		SelectionExistenceListeners[NewPart] = NewPart.AncestryChanged:connect( function ( Object, NewParent )
			if NewParent == nil then
				Selection:remove( NewPart );
			end;
		end );

		-- Provide a reference to the last item added to the selection (i.e. NewPart)
		self:focus( NewPart );

		-- Fire events
		self.ItemAdded:fire( NewPart );
		self.Changed:fire();

	end;

	-- Provide a method to remove items from the selection
	["remove"] = function ( self, Item )

		-- Make sure selection item `Item` exists
		if not self:find( Item ) then
			return false;
		end;

		-- Remove `Item`'s SelectionBox
		local SelectionBox = SelectionBoxes[Item];
		if SelectionBox then
			SelectionBox:Destroy();
		end;
		SelectionBoxes[Item] = nil;

		-- Delete the item from the selection
		table.remove( self.Items, self:find( Item ) );

		-- If it was logged as the last item, change it
		if self.Last == Item then
			self:focus( ( #self.Items > 0 ) and self.Items[#self.Items] or nil );
		end;

		-- Delete the existence listeners of the item
		SelectionExistenceListeners[Item]:disconnect();
		SelectionExistenceListeners[Item] = nil;

		-- Fire events
		self.ItemRemoved:fire( Item );
		self.Changed:fire();

	end;

	-- Provide a method to clear the selection
	["clear"] = function ( self )

		-- Go through all the items in the selection and call `self.remove` on them
		for _, Item in pairs( _cloneTable( self.Items ) ) do
			self:remove( Item );
		end;

	end;

	-- Provide a method to change the focus of the selection
	["focus"] = function ( self, NewFocus )

		-- Change the focus
		self.Last = NewFocus;

		-- Fire events
		self.Changed:fire();

	end;

};

-- Keep the Studio selection up-to-date (if applicable)
if ToolType == 'plugin' then
	Selection.Changed:connect( function ()
		Services.Selection:Set( Selection.Items );
	end );
end;

Tools = {};

------------------------------------------
-- Define other utilities needed by tools
------------------------------------------

function createDropdown()

	local Frame = RbxUtility.Create "Frame" {
		Name = "Dropdown";
		Size = UDim2.new( 0, 20, 0, 20 );
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		ClipsDescendants = true;
	};

	RbxUtility.Create "ImageLabel" {
		Parent = Frame;
		Name = "Arrow";
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		Image = expand_arrow;
		Position = UDim2.new( 1, -21, 0, 3 );
		Size = UDim2.new( 0, 20, 0, 20 );
		ZIndex = 3;
	};

	local DropdownObject = {
		-- Provide access to the actual frame
		Frame = Frame;

		-- Keep a list of all the options in the dropdown
		_options = {};

		-- Provide a function to add options to the dropdown
		addOption = function ( self, option )

			-- Add the option to the list
			table.insert( self._options, option );

			-- Create the GUI for the option
			local Button = RbxUtility.Create "TextButton" {
				Parent = self.Frame;
				BackgroundColor3 = Color3.new( 0, 0, 0 );
				BackgroundTransparency = 0.3;
				BorderColor3 = Color3.new( 27 / 255, 42 / 255, 53 / 255 );
				BorderSizePixel = 1;
				Name = option;
				Position = UDim2.new( math.ceil( #self._options / 9 ) - 1, 0, 0, 25 * ( ( #self._options % 9 == 0 ) and 9 or ( #self._options % 9 ) ) );
				Size = UDim2.new( 1, 0, 0, 25 );
				ZIndex = 3;
				Text = "";
			};
			local Label = RbxUtility.Create "TextLabel" {
				Parent = Button;
				BackgroundTransparency = 1;
				BorderSizePixel = 0;
				Position = UDim2.new( 0, 6, 0, 0 );
				Size = UDim2.new( 1, -30, 1, 0 );
				ZIndex = 3;
				Font = Enum.Font.ArialBold;
				FontSize = Enum.FontSize.Size12;
				Text = option;
				TextColor3 = Color3.new( 1, 1, 1 );
				TextXAlignment = Enum.TextXAlignment.Left;
				TextYAlignment = Enum.TextYAlignment.Center;
			};

			-- Return the button object
			return Button;

		end;

		selectOption = function ( self, option )
			self.Frame.MainButton.CurrentOption.Text = option;
		end;

		open = false;

		toggle = function ( self )

			-- If it's open, close it
			if self.open then
				self.Frame.MainButton.BackgroundTransparency = 0.3;
				self.Frame.ClipsDescendants = true;
				self.open = false;

			-- If it's not open, open it
			else
				self.Frame.MainButton.BackgroundTransparency = 0;
				self.Frame.ClipsDescendants = false;
				self.open = true;
			end;

		end;

	};

	-- Create the GUI for the option
	local MainButton = RbxUtility.Create "TextButton" {
		Parent = Frame;
		Name = "MainButton";
		BackgroundColor3 = Color3.new( 0, 0, 0 );
		BackgroundTransparency = 0.3;
		BorderColor3 = Color3.new( 27 / 255, 42 / 255, 53 / 255 );
		BorderSizePixel = 1;
		Position = UDim2.new( 0, 0, 0, 0 );
		Size = UDim2.new( 1, 0, 0, 25 );
		ZIndex = 2;
		Text = "";

		-- Toggle the dropdown when pressed
		[RbxUtility.Create.E "MouseButton1Up"] = function ()
			DropdownObject:toggle();
		end;
	};
	RbxUtility.Create "TextLabel" {
		Parent = MainButton;
		Name = "CurrentOption";
		BackgroundTransparency = 1;
		BorderSizePixel = 0;
		Position = UDim2.new( 0, 6, 0, 0 );
		Size = UDim2.new( 1, -30, 1, 0 );
		ZIndex = 3;
		Font = Enum.Font.ArialBold;
		FontSize = Enum.FontSize.Size12;
		Text = "";
		TextColor3 = Color3.new( 1, 1, 1 );
		TextXAlignment = Enum.TextXAlignment.Left;
		TextYAlignment = Enum.TextYAlignment.Center;
	};

	return DropdownObject;

end;

------------------------------------------
-- Provide an interface to the 2D
-- selection system
------------------------------------------

Select2D = {

	-- Keep state data
	["enabled"] = false;

	-- Keep objects
	["GUI"] = nil;

	-- Keep temporary, disposable connections
	["Connections"] = {};

	-- Provide an interface to the functions
	["start"] = function ( self )

		if enabled then
			return;
		end;

		self.enabled = true;

		-- Create the GUI
		self.GUI = RbxUtility.Create "ScreenGui" {
			Name = "BTSelectionRectangle";
			Parent = UI;
		};

		local Rectangle = RbxUtility.Create "Frame" {
			Name = "Rectangle";
			Active = false;
			Parent = self.GUI;
			BackgroundColor3 = Color3.new( 0, 0, 0 );
			BackgroundTransparency = 0.5;
			BorderSizePixel = 0;
			Position = UDim2.new( 0, math.min( click_x, Mouse.X ), 0, math.min( click_y, Mouse.Y ) );
			Size = UDim2.new( 0, math.max( click_x, Mouse.X ) - math.min( click_x, Mouse.X ), 0, math.max( click_y, Mouse.Y ) - math.min( click_y, Mouse.Y ) );
		};

		-- Listen for when to resize the selection
		self.Connections.SelectionResize = Mouse.Move:connect( function ()
			Rectangle.Position = UDim2.new( 0, math.min( click_x, Mouse.X ), 0, math.min( click_y, Mouse.Y ) );
			Rectangle.Size = UDim2.new( 0, math.max( click_x, Mouse.X ) - math.min( click_x, Mouse.X ), 0, math.max( click_y, Mouse.Y ) - math.min( click_y, Mouse.Y ) );
		end );

		-- Listen for when the selection ends
		self.Connections.SelectionEnd = Mouse.Button1Up:connect( function ()
			self:select();
			self:finish();
		end );

	end;

	["select"] = function ( self )

		if not self.enabled then
			return;
		end;

		for _, Object in pairs( _getAllDescendants( Services.Workspace ) ) do

			-- Make sure we can select this part
			if isSelectable( Object ) then

				-- Check if the part is rendered within the range of the selection area
				local PartPosition = _pointToScreenSpace( Object.Position );
				if PartPosition then
					local left_check = PartPosition.x >= self.GUI.Rectangle.AbsolutePosition.x;
					local right_check = PartPosition.x <= ( self.GUI.Rectangle.AbsolutePosition.x + self.GUI.Rectangle.AbsoluteSize.x );
					local top_check = PartPosition.y >= self.GUI.Rectangle.AbsolutePosition.y;
					local bottom_check = PartPosition.y <= ( self.GUI.Rectangle.AbsolutePosition.y + self.GUI.Rectangle.AbsoluteSize.y );

					-- If the part is within the selection area, select it
					if left_check and right_check and top_check and bottom_check then
						Selection:add( Object );
					end;
				end;

			end;

		end;

	end;

	["finish"] = function ( self )

		if not self.enabled then
			return;
		end;

		-- Disconnect temporary connections
		for connection_index, Connection in pairs( self.Connections ) do
			Connection:disconnect();
			self.Connections[connection_index] = nil;
		end;

		-- Remove temporary objects
		self.GUI:Destroy();
		self.GUI = nil;

		self.enabled = false;

	end;

};

------------------------------------------
-- Provide an interface to the edge
-- selection system
------------------------------------------
SelectEdge = {

	-- Keep state data
	["enabled"] = false;
	["started"] = false;

	-- Keep objects
	["Marker"] = nil;
	["MarkerOutline"] = RbxUtility.Create "SelectionBox" {
		Color = BrickColor.new( "Institutional white" );
		Parent = UI;
		Name = "BTEdgeSelectionMarkerOutline";
	};

	-- Keep temporary, disposable connections
	["Connections"] = {};

	-- Provide an interface to the functions
	["start"] = function ( self, edgeSelectionCallback )

		if self.started then
			return;
		end;

		-- Listen for when to engage in selection
		self.Connections.KeyListener = Mouse.KeyDown:connect( function ( key )

			local key = key:lower();
			local key_code = key:byte();

			if key == "t" and #Selection.Items > 0 then
				self:enable( edgeSelectionCallback );
			end;

		end );

		self.started = true;

	end;

	["enable"] = function ( self, edgeSelectionCallback )

		if self.enabled then
			return;
		end;

		self.Connections.MoveListener = Mouse.Move:connect( function ()

			-- Make sure the target can be selected
			if not Selection:find( Mouse.Target ) then
				return;
			end;

			-- Calculate the proximity to each edge
			local Proximity = {};
			local edges = {};

			-- Create shortcuts to certain things that are expensive to call constantly
			local table_insert = table.insert;
			local newCFrame = CFrame.new;
			local PartCFrame = Mouse.Target.CFrame;
			local partCFrameOffset = PartCFrame.toWorldSpace;
			local PartSize = Mouse.Target.Size / 2;
			local size_x, size_y, size_z = PartSize.x, PartSize.y, PartSize.z;

			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, size_y, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, size_y, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, -size_y, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, size_y, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, size_y, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, -size_y, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, -size_y, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, -size_y, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, size_y, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, 0, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, size_y, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, 0, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, size_y, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, 0, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, size_y, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, 0, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, -size_y, size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, 0, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, -size_y, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, 0, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, -size_y, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( size_x, 0, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, size_y, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, -size_y, 0 ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( -size_x, 0, -size_z ) ) );
			table_insert( edges, partCFrameOffset( PartCFrame, newCFrame( 0, -size_y, -size_z ) ) );

			-- Calculate the proximity of every edge to the mouse
			for edge_index, Edge in pairs( edges ) do
				Proximity[edge_index] = ( Mouse.Hit.p - Edge.p ).magnitude;
			end;

			-- Get the closest edge to the mouse
			local highest_proximity = 1;
			for proximity_index, proximity in pairs( Proximity ) do
				if proximity < Proximity[highest_proximity] then
					highest_proximity = proximity_index;
				end;
			end;

			-- Replace the current target edge (if any)
			local ClosestEdge = edges[highest_proximity];

			if self.Marker then
				self.Marker:Destroy();
			end;
			self.Marker = RbxUtility.Create "Part" {
				Name = "BTEdgeSelectionMarker";
				Anchored = true;
				Locked = true;
				CanCollide = false;
				Transparency = 1;
				FormFactor = Enum.FormFactor.Custom;
				Size = Vector3.new( 0.2, 0.2, 0.2 );
				CFrame = ClosestEdge;
			};

			self.MarkerOutline.Adornee = self.Marker;

		end );

		self.Connections.ClickListener = Mouse.Button1Up:connect( function ()
			override_selection = true;
			self:select( edgeSelectionCallback );
		end );

		self.enabled = true;

	end;

	["select"] = function ( self, callback )

		if not self.enabled or not self.Marker then
			return;
		end;

		self.MarkerOutline.Adornee = self.Marker;

		callback( self.Marker );

		-- Stop treating it like a marker
		self.Marker = nil;

		self:disable();

	end;

	["disable"] = function ( self )

		if not self.enabled then
			return;
		end;

		-- Disconnect unnecessary temporary connections
		if self.Connections.ClickListener then
			self.Connections.ClickListener:disconnect();
			self.Connections.ClickListener = nil;
		end;
		if self.Connections.MoveListener then
			self.Connections.MoveListener:disconnect();
			self.Connections.MoveListener = nil;
		end;

		-- Remove temporary objects
		if self.Marker then
			self.Marker:Destroy();
		end;
		self.Marker = nil;

		self.MarkerOutline.Adornee = nil;
		self.enabled = false;

	end;

	["stop"] = function ( self )

		if not self.started then
			return;
		end;

		-- Disconnect & remove all temporary connections
		for connection_index, Connection in pairs( self.Connections ) do
			Connection:disconnect();
			self.Connections[connection_index] = nil;
		end;

		-- Remove temporary objects
		if self.Marker then
			self.Marker:Destroy();
		end;

		self.started = false;

	end;

};

------------------------------------------
-- Provide an interface to the history
-- system
------------------------------------------
History = {

	-- Keep a container for the actual history data
	["Data"] = {};

	-- Keep state data
	["index"] = 0;

	-- Provide events for the platform to listen for changes
	["Changed"] = RbxUtility.CreateSignal();

	-- Provide functions to control the system
	["undo"] = function ( self )

		-- Make sure we're not getting out of boundary
		if self.index - 1 < 0 then
			return;
		end;

		-- Fetch the history record & unapply it
		local CurrentRecord = self.Data[self.index];
		CurrentRecord:unapply();

		-- Go back in the history
		self.index = self.index - 1;

		-- Fire the relevant events
		self.Changed:fire();

	end;

	["redo"] = function ( self )

		-- Make sure we're not getting out of boundary
		if self.index + 1 > #self.Data then
			return;
		end;

		-- Go forward in the history
		self.index = self.index + 1;

		-- Fetch the new history record & apply it
		local NewRecord = self.Data[self.index];
		NewRecord:apply();

		-- Fire the relevant events
		self.Changed:fire();

	end;

	["add"] = function ( self, Record )

		-- Place the record in its right spot
		self.Data[self.index + 1] = Record;

		-- Advance the history index
		self.index = self.index + 1;

		-- Clear out the following history
		for index = self.index + 1, #self.Data do
			self.Data[index] = nil;
		end;

		-- Fire the relevant events
		self.Changed:fire();

	end;

};


------------------------------------------
-- Provide an interface color picker
-- system
------------------------------------------
ColorPicker = {
	
	-- Keep some state data
	["enabled"] = false;
	["callback"] = nil;
	["track_mouse"] = nil;
	["hue"] = 0;
	["saturation"] = 1;
	["value"] = 1;

	-- Keep the current GUI here
	["GUI"] = nil;

	-- Keep temporary, disposable connections here
	["Connections"] = {};

	-- Provide an interface to the functions
	["start"] = function ( self, callback, start_color )

		-- Replace any existing color pickers
		if self.enabled then
			self:cancel();
		end;
		self.enabled = true;

		-- Create the GUI
		self.GUI = Tool.Interfaces.BTHSVColorPicker:Clone();
		self.GUI.Parent = UI;

		-- Register the callback function for when we're done here
		self.callback = callback;

		-- Update the GUI
		local start_color = start_color or Color3.new( 1, 0, 0 );
		self:_changeColor( _RGBToHSV( start_color.r, start_color.g, start_color.b ) );

		-- Add functionality to the GUI's interactive elements
		table.insert( self.Connections, self.GUI.HueSaturation.MouseButton1Down:connect( function ( x, y )
			self.track_mouse = 'hue-saturation';
			self:_onMouseMove( x, y );
		end ) );

		table.insert( self.Connections, self.GUI.HueSaturation.MouseButton1Up:connect( function ()
			self.track_mouse = nil;
		end ) );

		table.insert( self.Connections, self.GUI.MouseMoved:connect( function ( x, y )
			self:_onMouseMove( x, y );
		end ) );

		table.insert( self.Connections, self.GUI.Value.MouseButton1Down:connect( function ( x, y )
			self.track_mouse = 'value';
			self:_onMouseMove( x, y );
		end ) );

		table.insert( self.Connections, self.GUI.Value.MouseButton1Up:connect( function ()
			self.track_mouse = nil;
		end ) );

		table.insert( self.Connections, self.GUI.OkButton.MouseButton1Up:connect( function ()
			self:finish();
		end ) );

		table.insert( self.Connections, self.GUI.CancelButton.MouseButton1Up:connect( function ()
			self:cancel();
		end ) );

		table.insert( self.Connections, self.GUI.HueOption.Input.TextButton.MouseButton1Down:connect( function ()
			self.GUI.HueOption.Input.TextBox:CaptureFocus();
		end ) );
		table.insert( self.Connections, self.GUI.HueOption.Input.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( self.GUI.HueOption.Input.TextBox.Text );
			if potential_new then
				if potential_new > 360 then
					potential_new = 360;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:_changeColor( potential_new, self.saturation, self.value );
			else
				self:_updateGUI();
			end;
		end ) );

		table.insert( self.Connections, self.GUI.SaturationOption.Input.TextButton.MouseButton1Down:connect( function ()
			self.GUI.SaturationOption.Input.TextBox:CaptureFocus();
		end ) );
		table.insert( self.Connections, self.GUI.SaturationOption.Input.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( ( self.GUI.SaturationOption.Input.TextBox.Text:gsub( '%%', '' ) ) );
			if potential_new then
				if potential_new > 100 then
					potential_new = 100;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:_changeColor( self.hue, potential_new / 100, self.value );
			else
				self:_updateGUI();
			end;
		end ) );

		table.insert( self.Connections, self.GUI.ValueOption.Input.TextButton.MouseButton1Down:connect( function ()
			self.GUI.ValueOption.Input.TextBox:CaptureFocus();
		end ) );
		table.insert( self.Connections, self.GUI.ValueOption.Input.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( ( self.GUI.ValueOption.Input.TextBox.Text:gsub( '%%', '' ) ) );
			if potential_new then
				if potential_new < 0 then
					potential_new = 0;
				elseif potential_new > 100 then
					potential_new = 100;
				end;
				self:_changeColor( self.hue, self.saturation, potential_new / 100 );
			else
				self:_updateGUI();
			end;
		end ) );

	end;

	["_onMouseMove"] = function ( self, x, y )
		if not self.track_mouse then
			return;
		end;

		if self.track_mouse == 'hue-saturation' then
			-- Calculate the mouse position relative to the graph
			local graph_x, graph_y = x - self.GUI.HueSaturation.AbsolutePosition.x, y - self.GUI.HueSaturation.AbsolutePosition.y;

			-- Make sure we're not going out of bounds
			if graph_x < 0 then
				graph_x = 0;
			elseif graph_x > self.GUI.HueSaturation.AbsoluteSize.x then
				graph_x = self.GUI.HueSaturation.AbsoluteSize.x;
			end;
			if graph_y < 0 then
				graph_y = 0;
			elseif graph_y > self.GUI.HueSaturation.AbsoluteSize.y then
				graph_y = self.GUI.HueSaturation.AbsoluteSize.y;
			end;

			-- Calculate the new color and change it
			self:_changeColor( 359 * graph_x / 209, 1 - graph_y / 200, self.value );

		elseif self.track_mouse == 'value' then
			-- Calculate the mouse position relative to the value bar
			local bar_y = y - self.GUI.Value.AbsolutePosition.y;

			-- Make sure we're not going out of bounds
			if bar_y < 0 then
				bar_y = 0;
			elseif bar_y > self.GUI.Value.AbsoluteSize.y then
				bar_y = self.GUI.Value.AbsoluteSize.y;
			end;

			-- Calculate the new color and change it
			self:_changeColor( self.hue, self.saturation, 1 - bar_y / 200 );
		end;
	end;

	["_changeColor"] = function ( self, hue, saturation, value )
		if hue ~= hue then
			hue = 359;
		end;
		self.hue = hue;
		self.saturation = saturation == 0 and 0.01 or saturation;
		self.value = value;
		self:_updateGUI();
	end;

	["_updateGUI"] = function ( self )

		self.GUI.HueSaturation.Cursor.Position = UDim2.new( 0, 209 * self.hue / 360 - 8, 0, ( 1 - self.saturation ) * 200 - 8 );
		self.GUI.Value.Cursor.Position = UDim2.new( 0, -2, 0, ( 1 - self.value ) * 200 - 8 );

		local color = Color3.new( _HSVToRGB( self.hue, self.saturation, self.value ) );
		self.GUI.ColorDisplay.BackgroundColor3 = color;
		self.GUI.Value.ColorBG.BackgroundColor3 = Color3.new( _HSVToRGB( self.hue, self.saturation, 1 ) );

		self.GUI.HueOption.Bar.BackgroundColor3 = color;
		self.GUI.SaturationOption.Bar.BackgroundColor3 = color;
		self.GUI.ValueOption.Bar.BackgroundColor3 = color;

		self.GUI.HueOption.Input.TextBox.Text = math.floor( self.hue );
		self.GUI.SaturationOption.Input.TextBox.Text = math.floor( self.saturation * 100 ) .. "%";
		self.GUI.ValueOption.Input.TextBox.Text = math.floor( self.value * 100 ) .. "%";

	end;

	["finish"] = function ( self )

		if not self.enabled then
			return;
		end;

		-- Remove the GUI
		if self.GUI then
			self.GUI:Destroy();
		end;
		self.GUI = nil;
		self.track_mouse = nil;

		-- Disconnect all temporary connections
		for connection_index, connection in pairs( self.Connections ) do
			connection:disconnect();
			self.Connections[connection_index] = nil;
		end;

		-- Call the callback function that was provided to us
		self.callback( self.hue, self.saturation, self.value );
		self.callback = nil;

		self.enabled = false;

	end;

	["cancel"] = function ( self )

		if not self.enabled then
			return;
		end;

		-- Remove the GUI
		if self.GUI then
			self.GUI:Destroy();
		end;
		self.GUI = nil;
		self.track_mouse = nil;

		-- Disconnect all temporary connections
		for connection_index, connection in pairs( self.Connections ) do
			connection:disconnect();
			self.Connections[connection_index] = nil;
		end;

		-- Call the callback function that was provided to us
		self.callback();
		self.callback = nil;

		self.enabled = false;

	end;

};

------------------------------------------
-- Provide an interface to the
-- import/export system
------------------------------------------
IE = {

	["export"] = function ()

		if #Selection.Items == 0 then
			return;
		end;

		local serialized_selection = _serializeParts( Selection.Items );

		-- Dump to logs
		-- Services.TestService:Warn( false, "[Building Tools by F3X] Exported Model: \n" .. serialized_selection );

		-- Get ready to upload to the web for retrieval
		local upload_data;
		local cancelUpload;

		-- Create the export dialog
		local Dialog = Tool.Interfaces.BTExportDialog:Clone();
		Dialog.Loading.Size = UDim2.new( 1, 0, 0, 0 );
		Dialog.Parent = UI;
		Dialog.Loading:TweenSize( UDim2.new( 1, 0, 0, 80 ), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25 );
		Dialog.Loading.CloseButton.MouseButton1Up:connect( function ()
			cancelUpload();
			Dialog:Destroy();
		end );

		-- Run the upload/post-upload/failure code in a coroutine
		-- so it can be cancelled
		coroutine.resume( coroutine.create( function ()
			cancelUpload = function ()
				coroutine.yield();
			end;
			local upload_attempt = ypcall( function ()
				upload_data = PostAsync( "http://www.f3xteam.com/bt/export", serialized_selection );
			end );

			-- Make sure we're in a server
			if ToolType == 'plugin' and not in_server then
				Dialog.Loading.TextLabel.Text = "Use Tools > Test > Start Server to export from Studio";
				Dialog.Loading.TextLabel.TextWrapped = true;
				Dialog.Loading.CloseButton.Position = UDim2.new( 0, 0, 0, 50 );
				Dialog.Loading.CloseButton.Text = 'Got it';
				return;
			end;

			-- Fail graciously
			if not upload_attempt then
				Dialog.Loading.TextLabel.Text = "Upload failed";
				Dialog.Loading.CloseButton.Text = 'Ok :(';
				return;
			end;
			if not ( upload_data and type( upload_data ) == 'string' and upload_data:len() > 0 ) then
				Dialog.Loading.TextLabel.Text = "Upload failed";
				Dialog.Loading.CloseButton.Text = 'Ok ;(';
				return;
			end;
			if not pcall( function () upload_data = RbxUtility.DecodeJSON( upload_data ); end ) or not upload_data then
				Dialog.Loading.TextLabel.Text = "Upload failed";
				Dialog.Loading.CloseButton.Text = "Ok :'(";
				return;
			end;
			if not upload_data.success then
				Dialog.Loading.TextLabel.Text = "Upload failed";
				Dialog.Loading.CloseButton.Text = "Ok :''(";
			end;

			print( "[Building Tools by F3X] Uploaded Export: " .. upload_data.id );

			Dialog.Loading.Visible = false;
			Dialog.Info.Size = UDim2.new( 1, 0, 0, 0 );
			Dialog.Info.CreationID.Text = upload_data.id;
			Dialog.Info.Visible = true;
			Dialog.Info:TweenSize( UDim2.new( 1, 0, 0, 75 ), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25 );
			Dialog.Tip.Size = UDim2.new( 1, 0, 0, 0 );
			Dialog.Tip.Visible = true;
			Dialog.Tip:TweenSize( UDim2.new( 1, 0, 0, 30 ), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25 );
			Dialog.Close.Size = UDim2.new( 1, 0, 0, 0 );
			Dialog.Close.Visible = true;
			Dialog.Close:TweenSize( UDim2.new( 1, 0, 0, 20 ), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.25 );
			Dialog.Close.Button.MouseButton1Up:connect( function ()
				Dialog:Destroy();
			end );

			-- Play a confirmation sound
			local Sound = RbxUtility.Create "Sound" {
				Name = "BTActionCompletionSound";
				Pitch = 1.5;
				SoundId = action_completion_sound;
				Volume = 1;
				Parent = Player or Services.SoundService;
			};
			Sound:Play();
			Sound:Destroy();
		end ) );

	end;

};

------------------------------------------
-- Prepare the dock UI
------------------------------------------

Tooltips = {};

Dock = Tool.Interfaces:WaitForChild( "BTDockGUI" ):Clone();
Dock.Parent = UI;
Dock.Visible = false;

-- Add functionality to each tool button
for _, ToolButton in pairs( Dock.ToolButtons:GetChildren() ) do

	-- Get the tool name and the tool
	local tool_name = ToolButton.Name:match( "(.+)Button" );

	if tool_name then

		-- Create the click connection
		ToolButton.MouseButton1Up:connect( function ()
			local Tool = Tools[tool_name];
			if Tool then
				equipTool( Tool );
			end;
		end );

		ToolButton.MouseEnter:connect( function ()
			local Tooltip = Tooltips[tool_name];
			if Tooltip then
				Tooltip:focus( 'button' );
			end;
		end );

		ToolButton.MouseLeave:connect( function ()
			local Tooltip = Tooltips[tool_name];
			if Tooltip then
				Tooltip:unfocus( 'button' );
			end;
		end );

	end;

end;

-- Prepare the tooltips
for _, Tooltip in pairs( Dock.Tooltips:GetChildren() ) do

	local tool_name = Tooltip.Name:match( "(.+)Info" );

	Tooltips[tool_name] = {

		GUI = Tooltip;

		button_focus = false;
		tooltip_focus = false;

		focus = function ( self, source )
			if Dock.HelpInfo.Visible then
				return;
			end;
			if source == 'button' then
				self.button_focus = true;
			elseif source == 'tooltip' then
				self.tooltip_focus = true;
			end;
			for _, Tooltip in pairs( Dock.Tooltips:GetChildren() ) do
				Tooltip.Visible = false;
			end;
			self.GUI.Visible = true;
		end;

		unfocus = function ( self, source )
			if source == 'button' then
				self.button_focus = false;
			elseif source == 'tooltip' then
				self.tooltip_focus = false;
			end;
			if not self.button_focus and not self.tooltip_focus then
				self.GUI.Visible = false;
			end;
		end;

	};

	-- Make it disappear after it's out of mouse focus
	Tooltip.MouseEnter:connect( function ()
		Tooltips[tool_name]:focus( 'tooltip' );
	end );
	Tooltip.MouseLeave:connect( function ()
		Tooltips[tool_name]:unfocus( 'tooltip' );
	end );

	-- Create the scrolling container
	local ScrollingContainer = Gloo.ScrollingContainer( true, false, 15 );
	ScrollingContainer.GUI.Parent = Tooltip;

	-- Put the tooltip content in the container
	for _, Child in pairs( Tooltip.Content:GetChildren() ) do
		Child.Parent = ScrollingContainer.Container;
	end;
	ScrollingContainer.GUI.Size = Dock.Tooltips.Size;
	ScrollingContainer.Container.Size = Tooltip.Content.Size;
	ScrollingContainer.Boundary.Size = Dock.Tooltips.Size;
	ScrollingContainer.Boundary.BackgroundTransparency = 1;
	Tooltip.Content:Destroy();

end;


-- Create the scrolling container for the help tooltip
local ScrollingContainer = Gloo.ScrollingContainer( true, false, 15 );
ScrollingContainer.GUI.Parent = Dock.HelpInfo;

-- Put the help tooltip content in the container
for _, Child in pairs( Dock.HelpInfo.Content:GetChildren() ) do
	Child.Parent = ScrollingContainer.Container;
end;
ScrollingContainer.GUI.Size = Dock.HelpInfo.Size;
ScrollingContainer.Container.Size = Dock.HelpInfo.Content.Size;
ScrollingContainer.Boundary.Size = Dock.HelpInfo.Size;
ScrollingContainer.Boundary.BackgroundTransparency = 1;
Dock.HelpInfo.Content:Destroy();

-- Add functionality to the other GUI buttons
Dock.SelectionButtons.UndoButton.MouseButton1Up:connect( function ()
	History:undo();
end );
Dock.SelectionButtons.RedoButton.MouseButton1Up:connect( function ()
	History:redo();
end );
Dock.SelectionButtons.DeleteButton.MouseButton1Up:connect( function ()
	deleteSelection();
end );
Dock.SelectionButtons.CloneButton.MouseButton1Up:connect( function ()
	cloneSelection();
end );
Dock.SelectionButtons.ExportButton.MouseButton1Up:connect( function ()
	IE:export();
end );
Dock.InfoButtons.HelpButton.MouseButton1Up:connect( function ()
	toggleHelp();
end );

-- Shade the buttons according to whether they'll function or not
Selection.Changed:connect( function ()

	-- If there are items, they should be active
	if #Selection.Items > 0 then
		Dock.SelectionButtons.DeleteButton.Image = delete_active_decal;
		Dock.SelectionButtons.CloneButton.Image = clone_active_decal;
		Dock.SelectionButtons.ExportButton.Image = export_active_decal;

	-- If there aren't items, they shouldn't be active
	else
		Dock.SelectionButtons.DeleteButton.Image = delete_inactive_decal;
		Dock.SelectionButtons.CloneButton.Image = clone_inactive_decal;
		Dock.SelectionButtons.ExportButton.Image = export_inactive_decal;
	end;

end );

-- Make the selection/info buttons display tooltips upon hovering over them
for _, SelectionButton in pairs( Dock.SelectionButtons:GetChildren() ) do
	SelectionButton.MouseEnter:connect( function ()
		if SelectionButton:FindFirstChild( 'Tooltip' ) then
			SelectionButton.Tooltip.Visible = true;
		end;
	end );
	SelectionButton.MouseLeave:connect( function ()
		if SelectionButton:FindFirstChild( 'Tooltip' ) then
			SelectionButton.Tooltip.Visible = false;
		end;
	end );
end;
Dock.InfoButtons.HelpButton.MouseEnter:connect( function ()
	Dock.InfoButtons.HelpButton.Tooltip.Visible = true;
end );
Dock.InfoButtons.HelpButton.MouseLeave:connect( function ()
	Dock.InfoButtons.HelpButton.Tooltip.Visible = false;
end );

History.Changed:connect( function ()

	-- If there are any records
	if #History.Data > 0 then

		-- If we're at the beginning
		if History.index == 0 then
			Dock.SelectionButtons.UndoButton.Image = undo_inactive_decal;
			Dock.SelectionButtons.RedoButton.Image = redo_active_decal;

		-- If we're at the end
		elseif History.index == #History.Data then
			Dock.SelectionButtons.UndoButton.Image = undo_active_decal;
			Dock.SelectionButtons.RedoButton.Image = redo_inactive_decal;

		-- If we're neither at the beginning or the end
		else
			Dock.SelectionButtons.UndoButton.Image = undo_active_decal;
			Dock.SelectionButtons.RedoButton.Image = redo_active_decal;
		end;

	-- If there are no records
	else
		Dock.SelectionButtons.UndoButton.Image = undo_inactive_decal;
		Dock.SelectionButtons.RedoButton.Image = redo_inactive_decal;
	end;

end );

------------------------------------------
-- Attach tool event listeners
------------------------------------------

function equipBT( CurrentMouse )

	Mouse = CurrentMouse;

	-- Enable the move tool if there's no tool currently enabled
	if not CurrentTool then
		equipTool( Tools.Move );
	end;

	if not TargetBox then
		TargetBox = Instance.new( "SelectionBox", UI );
		TargetBox.Name = "BTTargetBox";
		TargetBox.Color = BrickColor.new( "Institutional white" );
		TargetBox.Transparency = 0.5;
	end;

	-- Enable any temporarily-disabled selection boxes
	for _, SelectionBox in pairs( SelectionBoxes ) do
		SelectionBox.Parent = UI;
	end;

	-- Update the internal selection if this is a plugin
	if ToolType == 'plugin' then
		for _, Item in pairs( Services.Selection:Get() ) do
			Selection:add( Item );
		end;
	end;

	-- Call the `Equipped` listener of the current tool
	if CurrentTool and CurrentTool.Listeners.Equipped then
		CurrentTool.Listeners.Equipped();
	end;

	-- Show the dock
	Dock.Visible = true;

	table.insert( Connections, Mouse.KeyDown:connect( function ( key )

		local key = key:lower();
		local key_code = key:byte();

		-- Provide the abiltiy to delete via the shift + X key combination
		if ActiveKeys[47] or ActiveKeys[48] and key == "x" then
			deleteSelection();
			return;
		end;

		-- Provide the ability to clone via the shift + C key combination
		if ActiveKeys[47] or ActiveKeys[48] and key == "c" then
			cloneSelection();
			return;
		end;

		-- Undo if shift+z is pressed
		if key == "z" and ( ActiveKeys[47] or ActiveKeys[48] ) then
			History:undo();
			return;

		-- Redo if shift+y is pressed
		elseif key == "y" and ( ActiveKeys[47] or ActiveKeys[48] ) then
			History:redo();
			return;
		end;

		-- Serialize and dump selection to logs if shift+p is pressed
		if key == "p" and ( ActiveKeys[47] or ActiveKeys[48] ) then
			IE:export();
			return;
		end;

		-- Perform a prism selection if shift + k is pressed
		if key == "k" and ( ActiveKeys[47] or ActiveKeys[48] ) then
			prismSelect();
			return;
		end;

		-- Clear the selection if shift + r is pressed
		if key == "r" and ( ActiveKeys[47] or ActiveKeys[48] ) then
			Selection:clear();
			return;
		end;

		if key == "z" then
			equipTool( Tools.Move );

		elseif key == "x" then
			equipTool( Tools.Resize );

		elseif key == "c" then
			equipTool( Tools.Rotate );

		elseif key == "v" then
			equipTool( Tools.Paint );

		elseif key == "b" then
			equipTool( Tools.Surface );

		elseif key == "n" then
			equipTool( Tools.Material );

		elseif key == "m" then
			equipTool( Tools.Anchor );

		elseif key == "k" then
			equipTool( Tools.Collision );

		elseif key == "j" then
			equipTool( Tools.NewPart );

		elseif key == "h" then
			equipTool( Tools.Mesh );

		elseif key == "g" then
			equipTool( Tools.Texture );

		elseif key == "f" then
			equipTool( Tools.Weld );

		elseif key == "u" then
			equipTool( Tools.Lighting );

		elseif key == "p" then
			equipTool( Tools.Decorate );

		end;

		ActiveKeys[key_code] = key_code;
		ActiveKeys[key] = key;

		-- If it's now in multiselection mode, update `selecting`
		-- (these are the left/right ctrl & shift keys)
		if ActiveKeys[47] or ActiveKeys[48] or ActiveKeys[49] or ActiveKeys[50] then
			selecting = ActiveKeys[47] or ActiveKeys[48] or ActiveKeys[49] or ActiveKeys[50];
		end;

	end ) );

	table.insert( Connections, Mouse.KeyUp:connect( function ( key )

		local key = key:lower();
		local key_code = key:byte();

		ActiveKeys[key_code] = nil;
		ActiveKeys[key] = nil;

		-- If it's no longer in multiselection mode, update `selecting` & related values
		if selecting and not ActiveKeys[selecting] then
			selecting = false;
			if Select2D.enabled then
				Select2D:select();
				Select2D:finish();
			end;
		end;

		-- Fire tool listeners
		if CurrentTool and CurrentTool.Listeners.KeyUp then
			CurrentTool.Listeners.KeyUp( key );
		end;

	end ) );

	table.insert( Connections, Mouse.Button1Down:connect( function ()

		clicking = true;
		click_x, click_y = Mouse.X, Mouse.Y;

		-- If multiselection is, just add to the selection
		if selecting then
			return;
		end;

		-- Fire tool listeners
		if CurrentTool and CurrentTool.Listeners.Button1Down then
			CurrentTool.Listeners.Button1Down();
		end;

	end ) );

	table.insert( Connections, Mouse.Move:connect( function ()

		-- If the mouse has moved since it was clicked, start 2D selection mode
		if not override_selection and not Select2D.enabled and clicking and selecting and ( click_x ~= Mouse.X or click_y ~= Mouse.Y ) then
			Select2D:start();
		end;

		-- If the target has changed, update the selectionbox appropriately
		if not override_selection and isSelectable( Mouse.Target ) and TargetBox.Adornee ~= Mouse.Target then
			TargetBox.Adornee = Mouse.Target;
		end;

		-- When aiming at something invalid, don't highlight any targets
		if not override_selection and not isSelectable( Mouse.Target ) then
			TargetBox.Adornee = nil;
		end;

		-- Fire tool listeners
		if CurrentTool and CurrentTool.Listeners.Move then
			CurrentTool.Listeners.Move();
		end;

		if override_selection then
			override_selection = false;
		end;

	end ) );

	table.insert( Connections, Mouse.Button1Up:connect( function ()

		clicking = false;

		-- Make sure the person didn't accidentally miss a handle or something
		if not Select2D.enabled and ( Mouse.X ~= click_x or Mouse.Y ~= click_y ) then
			override_selection = true;
		end;

		-- If the target when clicking was invalid then clear the selection (unless we're multi-selecting)
		if not override_selection and not selecting and not isSelectable( Mouse.Target ) then
			Selection:clear();
		end;

		-- If multi-selecting, add to/remove from the selection
		if not override_selection and selecting then

			-- If the item isn't already selected, add it to the selection
			if not Selection:find( Mouse.Target ) then
				if isSelectable( Mouse.Target ) then
					Selection:add( Mouse.Target );
				end;

			-- If the item _is_ already selected, remove it from the selection
			else
				if ( Mouse.X == click_x and Mouse.Y == click_y ) and Selection:find( Mouse.Target ) then
					Selection:remove( Mouse.Target );
				end;
			end;

		-- If not multi-selecting, replace the selection
		else
			if not override_selection and isSelectable( Mouse.Target ) then
				Selection:clear();
				Selection:add( Mouse.Target );
			end;
		end;

		-- Fire tool listeners
		if CurrentTool and CurrentTool.Listeners.Button1Up then
			CurrentTool.Listeners.Button1Up();
		end;

		if override_selection then
			override_selection = false;
		end;

	end ) );

	table.insert( Connections, Mouse.Button2Down:connect( function ()
		-- Fire tool listeners
		if CurrentTool and CurrentTool.Listeners.Button2Down then
			CurrentTool.Listeners.Button2Down();
		end;
	end ) );

	table.insert( Connections, Mouse.Button2Up:connect( function ()
		-- Fire tool listeners
		if CurrentTool and CurrentTool.Listeners.Button2Up then
			CurrentTool.Listeners.Button2Up();
		end;
	end ) );

end;

function unequipBT()

	Mouse = nil;

	-- Remove the mouse target SelectionBox from `Player`
	if TargetBox then
		TargetBox:Destroy();
		TargetBox = nil;
	end;

	-- Disable all the selection boxes temporarily
	for _, SelectionBox in pairs( SelectionBoxes ) do
		SelectionBox.Parent = nil;
	end;

	-- Hide the dock
	Dock.Visible = false;

	-- Disconnect temporary platform-related connections
	for connection_index, Connection in pairs( Connections ) do
		Connection:disconnect();
		Connections[connection_index] = nil;
	end;

	-- Call the `Unequipped` listener of the current tool
	if CurrentTool and CurrentTool.Listeners.Unequipped then
		CurrentTool.Listeners.Unequipped();
	end;

end;


------------------------------------------
-- Provide the platform's environment for
-- other tool scripts to extend upon
------------------------------------------

local tool_list = {
	"Anchor",
	"Collision",
	"Material",
	"Mesh",
	"Move",
	"NewPart",
	"Paint",
	"Resize",
	"Rotate",
	"Surface",
	"Texture",
	"Weld",
	"Lighting",
	"Decorate"
};

-- Make sure all the tool scripts are in the tool & deactivate them
for _, tool_name in pairs( tool_list ) do
	local script_name = "BT" .. tool_name .. "Tool";
	repeat wait() until script:FindFirstChild( script_name );
	script[script_name].Disabled = true;
end;

-- Load the platform
if not _G.BTCoreEnv then
	_G.BTCoreEnv = {};
end;
_G.BTCoreEnv[Tool] = getfenv( 0 );
CoreReady = true;

-- Reload the tool scripts
for _, tool_name in pairs( tool_list ) do
	local script_name = "BT" .. tool_name .. "Tool";
	script[script_name].Disabled = false;
end;

-- Wait for all the tools to load
for _, tool_name in pairs( tool_list ) do
	if not Tools[tool_name] then
		repeat wait() until Tools[tool_name];
	end;
	repeat wait() until Tools[tool_name].Loaded;
end;

-- Activate the plugin and tool connections
if ToolType == 'plugin' then
	local ToolbarButton = plugin:CreateToolbar( 'Building Tools by F3X' ):CreateButton( '', 'Building Tools by F3X', plugin_icon );
	local plugin_active = false;
	ToolbarButton.Click:connect( function ()
		if plugin_active then
			plugin_active = false;
			unequipBT();
		else
			plugin_active = true;
			plugin:Activate( true );
			equipBT( plugin:GetMouse() );
		end;
	end );
	plugin.Deactivation:connect( unequipBT );

elseif ToolType == 'tool' then
	Tool.Equipped:connect( equipBT );
	Tool.Unequipped:connect( unequipBT );
end;
end))
LocalScript70.Name = "BTMoveTool"
LocalScript70.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript70,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Move tool
------------------------------------------

-- Create the main container for this tool
Tools.Move = {};

-- Define the color of the tool
Tools.Move.Color = BrickColor.new( "Deep orange" );

-- Keep a container for temporary connections
Tools.Move.Connections = {};

-- Keep options in a container too
Tools.Move.Options = {
	["increment"] = 1;
	["axes"] = "global";
};

-- Keep internal state data in its own container
Tools.Move.State = {
	["distance_moved"] = 0;
	["moving"] = false;
	["PreMove"] = {};
};

-- Add listeners
Tools.Move.Listeners = {};

Tools.Move.Listeners.Equipped = function ()

	local self = Tools.Move;

	-- Make sure the tool is actually being equipped (because this is the default tool)
	if not Mouse then
		return;
	end;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Create the boundingbox if it doesn't already exist
	if not self.BoundingBox then
		self.BoundingBox = RbxUtility.Create "Part" {
			Name = "BTBoundingBox";
			CanCollide = false;
			Transparency = 1;
			Anchored = true;
		};
	end;
	Mouse.TargetFilter = self.BoundingBox;

	-- Refresh the axis type option
	self:changeAxes( self.Options.axes );

	-- Listen for any keystrokes that might affect any dragging operation
	self.Connections.DraggerKeyListener = Mouse.KeyDown:connect( function ( key )

		local key = key:lower();

		-- Make sure a dragger exists
		if not self.Dragger then
			return;
		end;

		-- Rotate along the Z axis if `r` is pressed
		if key == "r" then
			self.Dragger:AxisRotate( Enum.Axis.Z );

		-- Rotate along the X axis if `t` is pressed
		elseif key == "t" then
			self.Dragger:AxisRotate( Enum.Axis.X );

		-- Rotate along the Y axis if `y` is pressed
		elseif key == "y" then
			self.Dragger:AxisRotate( Enum.Axis.Y );
		end;

		-- Simulate a mouse move so that it applies the changes
		self.Dragger:MouseMove( Mouse.UnitRay );

	end );

	-- Oh, and update the boundingbox and the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

				-- Update the boundingbox if it's visible
				if self.Options.axes == "global" then
					self:updateBoundingBox();
				end;

			end;

		end;

	end )();

end;

Tools.Move.Listeners.Unequipped = function ()

	local self = Tools.Move;

	-- Stop the update loop
	if self.Updater then
		self.Updater();
		self.Updater = nil;
	end;

	-- Hide the GUI
	self:hideGUI();

	-- Hide the handles
	self:hideHandles();

	-- Clear out any temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of the selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Move.updateGUI = function ( self )

	if self.GUI then
		local GUI = self.GUI;

		if #Selection.Items > 0 then

			-- Look for identical numbers in each axis
			local position_x, position_y, position_z =  nil, nil, nil;
			for item_index, Item in pairs( Selection.Items ) do

				-- Set the first values for the first item
				if item_index == 1 then
					position_x, position_y, position_z = _round( Item.Position.x, 2 ), _round( Item.Position.y, 2 ), _round( Item.Position.z, 2 );

				-- Otherwise, compare them and set them to `nil` if they're not identical
				else
					if position_x ~= _round( Item.Position.x, 2 ) then
						position_x = nil;
					end;
					if position_y ~= _round( Item.Position.y, 2 ) then
						position_y = nil;
					end;
					if position_z ~= _round( Item.Position.z, 2 ) then
						position_z = nil;
					end;
				end;

			end;

			-- If each position along each axis is the same, display that number; otherwise, display "*"
			if not self.State.pos_x_focused then
				GUI.Info.Center.X.TextBox.Text = position_x and tostring( position_x ) or "*";
			end;
			if not self.State.pos_y_focused then
				GUI.Info.Center.Y.TextBox.Text = position_y and tostring( position_y ) or "*";
			end;
			if not self.State.pos_z_focused then
				GUI.Info.Center.Z.TextBox.Text = position_z and tostring( position_z ) or "*";
			end;

			GUI.Info.Visible = true;
		else
			GUI.Info.Visible = false;
		end;

		if self.State.distance_moved then
			GUI.Changes.Text.Text = "moved " .. tostring( self.State.distance_moved ) .. " studs";
			GUI.Changes.Position = GUI.Info.Visible and UDim2.new( 0, 5, 0, 165 ) or UDim2.new( 0, 5, 0, 100 );
			GUI.Changes.Visible = true;
		else
			GUI.Changes.Text.Text = "";
			GUI.Changes.Visible = false;
		end;
	end;

end;

Tools.Move.changePosition = function ( self, component, new_value )

	self:startHistoryRecord();

	-- Change the position of each item selected
	for _, Item in pairs( Selection.Items ) do
		Item.CFrame = CFrame.new(
			component == 'x' and new_value or Item.Position.x,
			component == 'y' and new_value or Item.Position.y,
			component == 'z' and new_value or Item.Position.z
		) * CFrame.Angles( Item.CFrame:toEulerAnglesXYZ() );
	end;

	self:finishHistoryRecord();

end;

Tools.Move.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_positions = {};
		terminal_positions = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.CFrame = self.initial_positions[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.CFrame = self.terminal_positions[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_positions[Item] = Item.CFrame;
		end;
	end;

end;

Tools.Move.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_positions[Item] = Item.CFrame;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Move.Listeners.Button1Down = function ()

	local self = Tools.Move;

	local Target = self.ManualTarget or Mouse.Target;
	self.ManualTarget = nil;

	-- If an unselected part is being moved, switch to it
	if not Selection:find( Target ) and isSelectable( Target ) then
		Selection:clear();
		Selection:add( Target );
	end;

	-- If the unselected target can't be selected at all, ignore the rest of the procedure
	if not Selection:find( Target ) then
		return;
	end;

	for _, Item in pairs( Selection.Items ) do
		Item.RotVelocity = Vector3.new( 0, 0, 0 );
		Item.Velocity = Vector3.new( 0, 0, 0 );
	end;

	self:startHistoryRecord();

	self.State.dragging = true;
	override_selection = true;

	self.Dragger = Instance.new( "Dragger" );
	self.Dragger:MouseDown( Target, Target.CFrame:toObjectSpace( CFrame.new( Mouse.Hit.p ) ).p, Selection.Items );
	self.Connections.DraggerConnection = Mouse.Button1Up:connect( function ()

		override_selection = true;

		-- Disable the dragger
		if self.Connections.DraggerConnection then
			self.Connections.DraggerConnection:disconnect();
			self.Connections.DraggerConnection = nil;
		end;
		if not self.Dragger then
			return;
		end;
		self.Dragger:MouseUp();
		self.State.dragging = false;
		self.Dragger:Destroy();
		self.Dragger = nil;

		self:finishHistoryRecord();

	end );

end;

Tools.Move.Listeners.Move = function ()

	local self = Tools.Move;

	if not self.Dragger then
		return;
	end;

	override_selection = true;

	self.Dragger:MouseMove( Mouse.UnitRay );

end;

Tools.Move.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTMoveToolGUI" ):Clone();
		Container.Parent = UI;

		-- Change the axis type option when the button is clicked
		Container.AxesOption.Global.Button.MouseButton1Down:connect( function ()
			self:changeAxes( "global" );
			Container.AxesOption.Global.SelectedIndicator.BackgroundTransparency = 0;
			Container.AxesOption.Global.Background.Image = dark_slanted_rectangle;
			Container.AxesOption.Local.SelectedIndicator.BackgroundTransparency = 1;
			Container.AxesOption.Local.Background.Image = light_slanted_rectangle;
			Container.AxesOption.Last.SelectedIndicator.BackgroundTransparency = 1;
			Container.AxesOption.Last.Background.Image = light_slanted_rectangle;
		end );

		Container.AxesOption.Local.Button.MouseButton1Down:connect( function ()
			self:changeAxes( "local" );
			Container.AxesOption.Global.SelectedIndicator.BackgroundTransparency = 1;
			Container.AxesOption.Global.Background.Image = light_slanted_rectangle;
			Container.AxesOption.Local.SelectedIndicator.BackgroundTransparency = 0;
			Container.AxesOption.Local.Background.Image = dark_slanted_rectangle;
			Container.AxesOption.Last.SelectedIndicator.BackgroundTransparency = 1;
			Container.AxesOption.Last.Background.Image = light_slanted_rectangle;
		end );

		Container.AxesOption.Last.Button.MouseButton1Down:connect( function ()
			self:changeAxes( "last" );
			Container.AxesOption.Global.SelectedIndicator.BackgroundTransparency = 1;
			Container.AxesOption.Global.Background.Image = light_slanted_rectangle;
			Container.AxesOption.Local.SelectedIndicator.BackgroundTransparency = 1;
			Container.AxesOption.Local.Background.Image = light_slanted_rectangle;
			Container.AxesOption.Last.SelectedIndicator.BackgroundTransparency = 0;
			Container.AxesOption.Last.Background.Image = dark_slanted_rectangle;
		end );

		-- Change the increment option when the value of the textbox is updated
		Container.IncrementOption.Increment.TextBox.FocusLost:connect( function ( enter_pressed )
			self.Options.increment = tonumber( Container.IncrementOption.Increment.TextBox.Text ) or self.Options.increment;
			Container.IncrementOption.Increment.TextBox.Text = tostring( self.Options.increment );
		end );

		-- Add functionality to the position inputs
		Container.Info.Center.X.TextButton.MouseButton1Down:connect( function ()
			self.State.pos_x_focused = true;
			Container.Info.Center.X.TextBox:CaptureFocus();
		end );
		Container.Info.Center.X.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.Center.X.TextBox.Text );
			if potential_new then
				self:changePosition( 'x', potential_new );
			end;
			self.State.pos_x_focused = false;
		end );
		Container.Info.Center.Y.TextButton.MouseButton1Down:connect( function ()
			self.State.pos_y_focused = true;
			Container.Info.Center.Y.TextBox:CaptureFocus();
		end );
		Container.Info.Center.Y.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.Center.Y.TextBox.Text );
			if potential_new then
				self:changePosition( 'y', potential_new );
			end;
			self.State.pos_y_focused = false;
		end );
		Container.Info.Center.Z.TextButton.MouseButton1Down:connect( function ()
			self.State.pos_z_focused = true;
			Container.Info.Center.Z.TextBox:CaptureFocus();
		end );
		Container.Info.Center.Z.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.Center.Z.TextBox.Text );
			if potential_new then
				self:changePosition( 'z', potential_new );
			end;
			self.State.pos_z_focused = false;
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Move.hideGUI = function ( self )

	-- Hide the GUI if it exists
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Move.showHandles = function ( self, Part )

	-- Create the handles if they don't exist yet
	if not self.Handles then

		-- Create the object
		self.Handles = RbxUtility.Create "Handles" {
			Name = "BTMovementHandles";
			Color = self.Color;
			Parent = GUIContainer;
		};

		-- Add functionality to the handles

		self.Handles.MouseButton1Down:connect( function ()

			-- Prevent the platform from thinking we're selecting
			override_selection = true;
			self.State.moving = true;

			-- Clear the change stats
			self.State.distance_moved = 0;

			self:startHistoryRecord();

			-- Do a few things to the selection before manipulating it
			for _, Item in pairs( Selection.Items ) do

				-- Keep a copy of the state of each item
				self.State.PreMove[Item] = Item:Clone();

				-- Anchor each item
				Item.Anchored = true;

			end;

			-- Return stuff to normal once the mouse button is released
			self.Connections.HandleReleaseListener = Mouse.Button1Up:connect( function ()

				-- Prevent the platform from thinking we're selecting
				override_selection = true;
				self.State.moving = false;

				-- Stop this connection from firing again
				if self.Connections.HandleReleaseListener then
					self.Connections.HandleReleaseListener:disconnect();
					self.Connections.HandleReleaseListener = nil;
				end;

				self:finishHistoryRecord();

				-- Restore properties that may have been changed temporarily
				-- from the pre-movement state copies
				for Item, PreviousItemState in pairs( self.State.PreMove ) do
					Item.Anchored = PreviousItemState.Anchored;
					self.State.PreMove[Item] = nil;
					Item:MakeJoints();
					Item.Velocity = Vector3.new( 0, 0, 0 );
					Item.RotVelocity = Vector3.new( 0, 0, 0 );
				end;

			end );

		end );

		self.Handles.MouseDrag:connect( function ( face, drag_distance )

			-- Calculate which multiple of the increment to use based on the current drag distance's
			-- proximity to their nearest upper and lower multiples

			local difference = drag_distance % self.Options.increment;

			local lower_degree = drag_distance - difference;
			local upper_degree = drag_distance - difference + self.Options.increment;

			local lower_degree_proximity = math.abs( drag_distance - lower_degree );
			local upper_degree_proximity = math.abs( drag_distance - upper_degree );

			if lower_degree_proximity <= upper_degree_proximity then
				drag_distance = lower_degree;
			else
				drag_distance = upper_degree;
			end;

			local increase = drag_distance;

			self.State.distance_moved = drag_distance;

			-- Increment the position of each selected item in the direction of `face`
			for _, Item in pairs( Selection.Items ) do

				-- Remove any joints connected with `Item` so that it can freely move
				Item:BreakJoints();

				-- Update the position of `Item` depending on the type of axes that is currently set
				if face == Enum.NormalId.Top then
					if self.Options.axes == "global" then
						Item.CFrame = CFrame.new( self.State.PreMove[Item].CFrame.p ):toWorldSpace( CFrame.new( 0, increase, 0 ) ) * CFrame.Angles( self.State.PreMove[Item].CFrame:toEulerAnglesXYZ() );
					elseif self.Options.axes == "local" then
						Item.CFrame = self.State.PreMove[Item].CFrame:toWorldSpace( CFrame.new( 0, increase, 0 ) );
					elseif self.Options.axes == "last" then
						Item.CFrame = self.State.PreMove[Selection.Last].CFrame:toWorldSpace( CFrame.new( 0, increase, 0 ) ):toWorldSpace( self.State.PreMove[Item].CFrame:toObjectSpace( self.State.PreMove[Selection.Last].CFrame ):inverse() );
					end;

				elseif face == Enum.NormalId.Bottom then
					if self.Options.axes == "global" then
						Item.CFrame = CFrame.new( self.State.PreMove[Item].CFrame.p ):toWorldSpace( CFrame.new( 0, -increase, 0 ) ) * CFrame.Angles( self.State.PreMove[Item].CFrame:toEulerAnglesXYZ() );
					elseif self.Options.axes == "local" then
						Item.CFrame = self.State.PreMove[Item].CFrame:toWorldSpace( CFrame.new( 0, -increase, 0 ) );
					elseif self.Options.axes == "last" then
						Item.CFrame = self.State.PreMove[Selection.Last].CFrame:toWorldSpace( CFrame.new( 0, -increase, 0 ) ):toWorldSpace( self.State.PreMove[Item].CFrame:toObjectSpace( self.State.PreMove[Selection.Last].CFrame ):inverse() );
					end;

				elseif face == Enum.NormalId.Front then
					if self.Options.axes == "global" then
						Item.CFrame = CFrame.new( self.State.PreMove[Item].CFrame.p ):toWorldSpace( CFrame.new( 0, 0, -increase ) ) * CFrame.Angles( self.State.PreMove[Item].CFrame:toEulerAnglesXYZ() );
					elseif self.Options.axes == "local" then
						Item.CFrame = self.State.PreMove[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, -increase ) );
					elseif self.Options.axes == "last" then
						Item.CFrame = self.State.PreMove[Selection.Last].CFrame:toWorldSpace( CFrame.new( 0, 0, -increase ) ):toWorldSpace( self.State.PreMove[Item].CFrame:toObjectSpace( self.State.PreMove[Selection.Last].CFrame ):inverse() );
					end;

				elseif face == Enum.NormalId.Back then
					if self.Options.axes == "global" then
						Item.CFrame = CFrame.new( self.State.PreMove[Item].CFrame.p ):toWorldSpace( CFrame.new( 0, 0, increase ) ) * CFrame.Angles( self.State.PreMove[Item].CFrame:toEulerAnglesXYZ() );
					elseif self.Options.axes == "local" then
						Item.CFrame = self.State.PreMove[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, increase ) );
					elseif self.Options.axes == "last" then
						Item.CFrame = self.State.PreMove[Selection.Last].CFrame:toWorldSpace( CFrame.new( 0, 0, increase ) ):toWorldSpace( self.State.PreMove[Item].CFrame:toObjectSpace( self.State.PreMove[Selection.Last].CFrame ):inverse() );
					end;

				elseif face == Enum.NormalId.Right then
					if self.Options.axes == "global" then
						Item.CFrame = CFrame.new( self.State.PreMove[Item].CFrame.p ):toWorldSpace( CFrame.new( increase, 0, 0 ) ) * CFrame.Angles( self.State.PreMove[Item].CFrame:toEulerAnglesXYZ() );
					elseif self.Options.axes == "local" then
						Item.CFrame = self.State.PreMove[Item].CFrame:toWorldSpace( CFrame.new( increase, 0, 0 ) );
					elseif self.Options.axes == "last" then
						Item.CFrame = self.State.PreMove[Selection.Last].CFrame:toWorldSpace( CFrame.new( increase, 0, 0 ) ):toWorldSpace( self.State.PreMove[Item].CFrame:toObjectSpace( self.State.PreMove[Selection.Last].CFrame ):inverse() );
					end;

				elseif face == Enum.NormalId.Left then
					if self.Options.axes == "global" then
						Item.CFrame = CFrame.new( self.State.PreMove[Item].CFrame.p ):toWorldSpace( CFrame.new( -increase, 0, 0 ) ) * CFrame.Angles( self.State.PreMove[Item].CFrame:toEulerAnglesXYZ() );
					elseif self.Options.axes == "local" then
						Item.CFrame = self.State.PreMove[Item].CFrame:toWorldSpace( CFrame.new( -increase, 0, 0 ) );
					elseif self.Options.axes == "last" then
						Item.CFrame = self.State.PreMove[Selection.Last].CFrame:toWorldSpace( CFrame.new( -increase, 0, 0 ) ):toWorldSpace( self.State.PreMove[Item].CFrame:toObjectSpace( self.State.PreMove[Selection.Last].CFrame ):inverse() );
					end;

				end;

			end;

		end );

	end;

	-- Stop listening for the existence of the previous adornee (if any)
	if self.Connections.AdorneeExistenceListener then
		self.Connections.AdorneeExistenceListener:disconnect();
		self.Connections.AdorneeExistenceListener = nil;
	end;

	-- Attach the handles to `Part`
	self.Handles.Adornee = Part;

	-- Make sure to hide the handles if `Part` suddenly stops existing
	self.Connections.AdorneeExistenceListener = Part.AncestryChanged:connect( function ( Object, NewParent )

		-- Make sure this change in parent applies directly to `Part`
		if Object ~= Part then
			return;
		end;

		-- Show the handles according to the existence of the part
		if NewParent == nil then
			self:hideHandles();
		else
			self:showHandles( Part );
		end;

	end );

end;

Tools.Move.hideHandles = function ( self )

	-- Hide the handles if they exist
	if self.Handles then
		self.Handles.Adornee = nil;
	end;

end;

Tools.Move.updateBoundingBox = function ( self )

	if #Selection.Items > 0 and not self.State.dragging then
		local SelectionSize, SelectionPosition = _getCollectionInfo( Selection.Items );
		self.BoundingBox.Size = SelectionSize;
		self.BoundingBox.CFrame = SelectionPosition;
		self:showHandles( self.BoundingBox );

	else
		self:hideHandles();
	end;

end;

Tools.Move.changeAxes = function ( self, new_axes )

	-- Have a quick reference to the GUI (if any)
	local AxesOptionGUI = self.GUI and self.GUI.AxesOption or nil;

	-- Disconnect any handle-related listeners that are specific to a certain axes option

	if self.Connections.HandleFocusChangeListener then
		self.Connections.HandleFocusChangeListener:disconnect();
		self.Connections.HandleFocusChangeListener = nil;
	end;

	if self.Connections.HandleSelectionChangeListener then
		self.Connections.HandleSelectionChangeListener:disconnect();
		self.Connections.HandleSelectionChangeListener = nil;
	end;

	if new_axes == "global" then

		-- Update the options
		self.Options.axes = "global";

		-- Clear out any previous adornee
		self:hideHandles();

		-- Focus the handles on the boundary box
		self:showHandles( self.BoundingBox );

		-- Update the GUI's option panel
		if self.GUI then
			AxesOptionGUI.Global.SelectedIndicator.BackgroundTransparency = 0;
			AxesOptionGUI.Global.Background.Image = dark_slanted_rectangle;
			AxesOptionGUI.Local.SelectedIndicator.BackgroundTransparency = 1;
			AxesOptionGUI.Local.Background.Image = light_slanted_rectangle;
			AxesOptionGUI.Last.SelectedIndicator.BackgroundTransparency = 1;
			AxesOptionGUI.Last.Background.Image = light_slanted_rectangle;
		end;

	end;

	if new_axes == "local" then

		-- Update the options
		self.Options.axes = "local";

		-- Always have the handles on the most recent addition to the selection
		self.Connections.HandleSelectionChangeListener = Selection.Changed:connect( function ()

			-- Clear out any previous adornee
			self:hideHandles();

			-- If there /is/ a last item in the selection, attach the handles to it
			if Selection.Last then
				self:showHandles( Selection.Last );
			end;

		end );

		-- Switch the adornee of the handles if the second mouse button is pressed
		self.Connections.HandleFocusChangeListener = Mouse.Button2Up:connect( function ()

			-- Make sure the platform doesn't think we're selecting
			override_selection = true;

			-- If the target is in the selection, make it the new adornee
			if Selection:find( Mouse.Target ) then
				Selection:focus( Mouse.Target );
				self:showHandles( Mouse.Target );
			end;

		end );

		-- Finally, attach the handles to the last item added to the selection (if any)
		if Selection.Last then
			self:showHandles( Selection.Last );
		end;

		-- Update the GUI's option panel
		if self.GUI then
			AxesOptionGUI.Global.SelectedIndicator.BackgroundTransparency = 1;
			AxesOptionGUI.Global.Background.Image = light_slanted_rectangle;
			AxesOptionGUI.Local.SelectedIndicator.BackgroundTransparency = 0;
			AxesOptionGUI.Local.Background.Image = dark_slanted_rectangle;
			AxesOptionGUI.Last.SelectedIndicator.BackgroundTransparency = 1;
			AxesOptionGUI.Last.Background.Image = light_slanted_rectangle;
		end;

	end;

	if new_axes == "last" then

		-- Update the options
		self.Options.axes = "last";

		-- Always have the handles on the most recent addition to the selection
		self.Connections.HandleSelectionChangeListener = Selection.Changed:connect( function ()

			-- Clear out any previous adornee
			self:hideHandles();

			-- If there /is/ a last item in the selection, attach the handles to it
			if Selection.Last then
				self:showHandles( Selection.Last );
			end;

		end );

		-- Switch the adornee of the handles if the second mouse button is pressed
		self.Connections.HandleFocusChangeListener = Mouse.Button2Up:connect( function ()

			-- Make sure the platform doesn't think we're selecting
			override_selection = true;

			-- If the target is in the selection, make it the new adornee
			if Selection:find( Mouse.Target ) then
				Selection:focus( Mouse.Target );
				self:showHandles( Mouse.Target );
			end;

		end );

		-- Finally, attach the handles to the last item added to the selection (if any)
		if Selection.Last then
			self:showHandles( Selection.Last );
		end;

		-- Update the GUI's option panel
		if self.GUI then
			AxesOptionGUI.Global.SelectedIndicator.BackgroundTransparency = 1;
			AxesOptionGUI.Global.Background.Image = light_slanted_rectangle;
			AxesOptionGUI.Local.SelectedIndicator.BackgroundTransparency = 1;
			AxesOptionGUI.Local.Background.Image = light_slanted_rectangle;
			AxesOptionGUI.Last.SelectedIndicator.BackgroundTransparency = 0;
			AxesOptionGUI.Last.Background.Image = dark_slanted_rectangle;
		end;

	end;

end;

Tools.Move.Loaded = true;
end))
LocalScript70.Disabled = true
LocalScript71.Name = "BTResizeTool"
LocalScript71.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript71,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Resize tool
------------------------------------------

-- Create the tool
Tools.Resize = {};

-- Create structures that will be used within the tool
Tools.Resize.Connections = {};

Tools.Resize.Options = {
	["increment"] = 1;
	["directions"] = "normal";
};

Tools.Resize.State = {
	["PreResize"] = {};
	["previous_distance"] = 0;
	["resizing"] = false;
	["length_resized"] = 0;
};

Tools.Resize.Listeners = {};

-- Define the color of the tool
Tools.Resize.Color = BrickColor.new( "Cyan" );

Tools.Resize.Listeners.Equipped = function ()

	local self = Tools.Resize;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Always have the handles on the most recent addition to the selection
	table.insert( self.Connections, Selection.Changed:connect( function ()

		-- Clear out any previous adornee
		self:hideHandles();

		-- If there /is/ a last item in the selection, attach the handles to it
		if Selection.Last then
			self:showHandles( Selection.Last );
		end;

	end ) );

	-- Switch the adornee of the handles if the second mouse button is pressed
	table.insert( self.Connections, Mouse.Button2Up:connect( function ()

		-- Make sure the platform doesn't think we're selecting
		override_selection = true;

		-- If the target is in the selection, make it the new adornee
		if Selection:find( Mouse.Target ) then
			Selection:focus( Mouse.Target );
		end;

	end ) );

	-- Finally, attach the handles to the last item added to the selection (if any)
	if Selection.Last then
		self:showHandles( Selection.Last );
	end;

	-- Update the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

			end;

		end;

	end )();

end;

Tools.Resize.Listeners.Unequipped = function ()

	local self = Tools.Resize;

	-- Stop the update loop
	if self.Updater then
		self.Updater();
		self.Updater = nil;
	end;

	-- Hide the GUI
	self:hideGUI();

	-- Hide the handles
	self:hideHandles();

	-- Clear out any temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of the selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Resize.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTResizeToolGUI" ):Clone();
		Container.Parent = UI;

		-- Change the axis type option when the button is clicked
		Container.DirectionsOption.Normal.Button.MouseButton1Down:connect( function ()
			self.Options.directions = "normal";
			Container.DirectionsOption.Normal.SelectedIndicator.BackgroundTransparency = 0;
			Container.DirectionsOption.Normal.Background.Image = dark_slanted_rectangle;
			Container.DirectionsOption.Both.SelectedIndicator.BackgroundTransparency = 1;
			Container.DirectionsOption.Both.Background.Image = light_slanted_rectangle;
		end );

		Container.DirectionsOption.Both.Button.MouseButton1Down:connect( function ()
			self.Options.directions = "both";
			Container.DirectionsOption.Normal.SelectedIndicator.BackgroundTransparency = 1;
			Container.DirectionsOption.Normal.Background.Image = light_slanted_rectangle;
			Container.DirectionsOption.Both.SelectedIndicator.BackgroundTransparency = 0;
			Container.DirectionsOption.Both.Background.Image = dark_slanted_rectangle;
		end );

		-- Change the increment option when the value of the textbox is updated
		Container.IncrementOption.Increment.TextBox.FocusLost:connect( function ( enter_pressed )
			self.Options.increment = tonumber( Container.IncrementOption.Increment.TextBox.Text ) or self.Options.increment;
			Container.IncrementOption.Increment.TextBox.Text = tostring( self.Options.increment );
		end );

		-- Add functionality to the size inputs
		Container.Info.SizeInfo.X.TextButton.MouseButton1Down:connect( function ()
			self.State.size_x_focused = true;
			Container.Info.SizeInfo.X.TextBox:CaptureFocus();
		end );
		Container.Info.SizeInfo.X.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.SizeInfo.X.TextBox.Text );
			if potential_new then
				self:changeSize( 'x', potential_new );
			end;
			self.State.size_x_focused = false;
		end );
		Container.Info.SizeInfo.Y.TextButton.MouseButton1Down:connect( function ()
			self.State.size_y_focused = true;
			Container.Info.SizeInfo.Y.TextBox:CaptureFocus();
		end );
		Container.Info.SizeInfo.Y.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.SizeInfo.Y.TextBox.Text );
			if potential_new then
				self:changeSize( 'y', potential_new );
			end;
			self.State.size_y_focused = false;
		end );
		Container.Info.SizeInfo.Z.TextButton.MouseButton1Down:connect( function ()
			self.State.size_z_focused = true;
			Container.Info.SizeInfo.Z.TextBox:CaptureFocus();
		end );
		Container.Info.SizeInfo.Z.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.SizeInfo.Z.TextBox.Text );
			if potential_new then
				self:changeSize( 'z', potential_new );
			end;
			self.State.size_z_focused = false;
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Resize.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_positions = {};
		terminal_positions = {};
		initial_sizes = {};
		terminal_sizes = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.Size = self.initial_sizes[Target];
					Target.CFrame = self.initial_positions[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.Size = self.terminal_sizes[Target];
					Target.CFrame = self.terminal_positions[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_sizes[Item] = Item.Size;
			self.State.HistoryRecord.initial_positions[Item] = Item.CFrame;
		end;
	end;

end;

Tools.Resize.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_sizes[Item] = Item.Size;
			self.State.HistoryRecord.terminal_positions[Item] = Item.CFrame;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Resize.changeSize = function ( self, component, new_value )

	self:startHistoryRecord();

	-- Change the size of each item selected
	for _, Item in pairs( Selection.Items ) do
		local OldCFrame = Item.CFrame;
		-- Make the item be able to be freely resized
		if ( pcall( function () local test = Item.FormFactor; end ) ) then
			Item.FormFactor = Enum.FormFactor.Custom;
		end;
		Item.Size = Vector3.new(
			component == 'x' and new_value or Item.Size.x,
			component == 'y' and new_value or Item.Size.y,
			component == 'z' and new_value or Item.Size.z
		);
		Item.CFrame = OldCFrame;
	end;

	self:finishHistoryRecord();

end;

Tools.Resize.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	local GUI = self.GUI;

	if #Selection.Items > 0 then

		-- Look for identical numbers in each axis
		local size_x, size_y, size_z =  nil, nil, nil;
		for item_index, Item in pairs( Selection.Items ) do

			-- Set the first values for the first item
			if item_index == 1 then
				size_x, size_y, size_z = _round( Item.Size.x, 2 ), _round( Item.Size.y, 2 ), _round( Item.Size.z, 2 );

			-- Otherwise, compare them and set them to `nil` if they're not identical
			else
				if size_x ~= _round( Item.Size.x, 2 ) then
					size_x = nil;
				end;
				if size_y ~= _round( Item.Size.y, 2 ) then
					size_y = nil;
				end;
				if size_z ~= _round( Item.Size.z, 2 ) then
					size_z = nil;
				end;
			end;

		end;

		-- Update the size info on the GUI
		if not self.State.size_x_focused then
			GUI.Info.SizeInfo.X.TextBox.Text = size_x and tostring( size_x ) or "*";
		end;
		if not self.State.size_y_focused then
			GUI.Info.SizeInfo.Y.TextBox.Text = size_y and tostring( size_y ) or "*";
		end;
		if not self.State.size_z_focused then
			GUI.Info.SizeInfo.Z.TextBox.Text = size_z and tostring( size_z ) or "*";
		end;

		GUI.Info.Visible = true;
	else
		GUI.Info.Visible = false;
	end;

	if self.State.length_resized then
		GUI.Changes.Text.Text = "resized " .. tostring( self.State.length_resized ) .. " studs";
		GUI.Changes.Position = GUI.Info.Visible and UDim2.new( 0, 5, 0, 165 ) or UDim2.new( 0, 5, 0, 100 );
		GUI.Changes.Visible = true;
	else
		GUI.Changes.Text.Text = "";
		GUI.Changes.Visible = false;
	end;

end;

Tools.Resize.hideGUI = function ( self )

	-- Hide the GUI if it exists
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Resize.showHandles = function ( self, Part )

	-- Create the handles if they don't exist yet
	if not self.Handles then

		-- Create the object
		self.Handles = RbxUtility.Create "Handles" {
			Name = "BTResizeHandles";
			Style = Enum.HandlesStyle.Resize;
			Color = self.Color;
			Parent = GUIContainer;
		};

		-- Add functionality to the handles
		self.Handles.MouseButton1Down:connect( function ()

			-- Prevent the platform from thinking we're selecting
			override_selection = true;
			self.State.resizing = true;

			-- Clear the change stats
			self.State.length_resized = 0;

			self:startHistoryRecord();

			-- Do a few things to the selection before manipulating it
			for _, Item in pairs( Selection.Items ) do

				-- Keep a copy of the state of each item
				self.State.PreResize[Item] = Item:Clone();

				-- Make the item be able to be freely resized
				if ( pcall( function () local test = Item.FormFactor; end ) ) then
					Item.FormFactor = Enum.FormFactor.Custom;
				end;

				-- Anchor each item
				Item.Anchored = true;

			end;

			-- Return stuff to normal once the mouse button is released
			self.Connections.HandleReleaseListener = Mouse.Button1Up:connect( function ()

				-- Prevent the platform from thinking we're selecting
				override_selection = true;
				self.State.resizing = false;

				-- Stop this connection from firing again
				if self.Connections.HandleReleaseListener then
					self.Connections.HandleReleaseListener:disconnect();
					self.Connections.HandleReleaseListener = nil;
				end;

				self:finishHistoryRecord();

				-- Restore properties that may have been changed temporarily
				-- from the pre-resize state copies
				for Item, PreviousItemState in pairs( self.State.PreResize ) do
					Item.Anchored = PreviousItemState.Anchored;
					self.State.PreResize[Item] = nil;
					Item:MakeJoints();
				end;

			end );

		end );

		self.Handles.MouseDrag:connect( function ( face, drag_distance )

			-- Calculate which multiple of the increment to use based on the current drag distance's
			-- proximity to their nearest upper and lower multiples

			local difference = drag_distance % self.Options.increment;

			local lower_degree = drag_distance - difference;
			local upper_degree = drag_distance - difference + self.Options.increment;

			local lower_degree_proximity = math.abs( drag_distance - lower_degree );
			local upper_degree_proximity = math.abs( drag_distance - upper_degree );

			if lower_degree_proximity <= upper_degree_proximity then
				drag_distance = lower_degree;
			else
				drag_distance = upper_degree;
			end;

			local increase = drag_distance;

			-- Log the distance that the handle was dragged
			self.State.previous_distance = drag_distance;

			-- Note the length by which the selection will be enlarged
			if self.Options.directions == "both" then
				increase = drag_distance * 2;
			end;
			self.State.length_resized = increase;

			-- Go through the selection and make changes to it
			for _, Item in pairs( Selection.Items ) do

				-- Keep a copy of `Item` in case we need to revert anything
				local PreviousItemState = Item:Clone();

				-- Break any of `Item`'s joints so it can move freely
				Item:BreakJoints();

				-- Position and resize `Item` according to the options and the handle that was used

				if face == Enum.NormalId.Top then

					-- Calculate the appropriate increment to the size based on the shape of `Item`
					local SizeIncrease;
					if ( pcall( function () local test = Item.Shape; end ) ) and ( Item.Shape == Enum.PartType.Ball or Item.Shape == Enum.PartType.Cylinder ) then
						SizeIncrease = Vector3.new( increase, increase, increase );
					elseif not ( pcall( function () local test = Item.Shape; end ) ) or ( Item.Shape and Item.Shape == Enum.PartType.Block ) then
						SizeIncrease = Vector3.new( 0, increase, 0 );
					end;

					Item.Size = self.State.PreResize[Item].Size + SizeIncrease;
					if Item.Size == self.State.PreResize[Item].Size + SizeIncrease then
						Item.CFrame = ( self.Options.directions == "normal" and self.State.PreResize[Item].CFrame:toWorldSpace( CFrame.new( 0, increase / 2, 0 ) ) )
									  or ( self.Options.directions == "both" and self.State.PreResize[Item].CFrame );
					-- If the resizing was not possible, revert `Item`'s state
					else
						Item.Size = PreviousItemState.Size;
						Item.CFrame = PreviousItemState.CFrame;
					end;

				elseif face == Enum.NormalId.Bottom then

					-- Calculate the appropriate increment to the size based on the shape of `Item`
					local SizeIncrease;
					if ( pcall( function () local test = Item.Shape; end ) ) and ( Item.Shape == Enum.PartType.Ball or Item.Shape == Enum.PartType.Cylinder ) then
						SizeIncrease = Vector3.new( increase, increase, increase );
					elseif not ( pcall( function () local test = Item.Shape; end ) ) or ( Item.Shape and Item.Shape == Enum.PartType.Block ) then
						SizeIncrease = Vector3.new( 0, increase, 0 );
					end;

					Item.Size = self.State.PreResize[Item].Size + SizeIncrease;
					if Item.Size == self.State.PreResize[Item].Size + SizeIncrease then
						Item.CFrame = ( self.Options.directions == "normal" and self.State.PreResize[Item].CFrame:toWorldSpace( CFrame.new( 0, -increase / 2, 0 ) ) )
									  or ( self.Options.directions == "both" and self.State.PreResize[Item].CFrame );
					-- If the resizing was not possible, revert `Item`'s state
					else
						Item.Size = PreviousItemState.Size;
						Item.CFrame = PreviousItemState.CFrame;
					end;

				elseif face == Enum.NormalId.Front then

					-- Calculate the appropriate increment to the size based on the shape of `Item`
					local SizeIncrease;
					if ( pcall( function () local test = Item.Shape; end ) ) and ( Item.Shape == Enum.PartType.Ball or Item.Shape == Enum.PartType.Cylinder ) then
						SizeIncrease = Vector3.new( increase, increase, increase );
					elseif not ( pcall( function () local test = Item.Shape; end ) ) or ( Item.Shape and Item.Shape == Enum.PartType.Block ) then
						SizeIncrease = Vector3.new( 0, 0, increase );
					end;

					Item.Size = self.State.PreResize[Item].Size + SizeIncrease;
					if Item.Size == self.State.PreResize[Item].Size + SizeIncrease then
						Item.CFrame = ( self.Options.directions == "normal" and self.State.PreResize[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, -increase / 2 ) ) )
									  or ( self.Options.directions == "both" and self.State.PreResize[Item].CFrame );
					-- If the resizing was not possible, revert `Item`'s state
					else
						Item.Size = PreviousItemState.Size;
						Item.CFrame = PreviousItemState.CFrame;
					end;

				elseif face == Enum.NormalId.Back then

					-- Calculate the appropriate increment to the size based on the shape of `Item`
					local SizeIncrease;
					if ( pcall( function () local test = Item.Shape; end ) ) and ( Item.Shape == Enum.PartType.Ball or Item.Shape == Enum.PartType.Cylinder ) then
						SizeIncrease = Vector3.new( increase, increase, increase );
					elseif not ( pcall( function () local test = Item.Shape; end ) ) or ( Item.Shape and Item.Shape == Enum.PartType.Block ) then
						SizeIncrease = Vector3.new( 0, 0, increase );
					end;

					Item.Size = self.State.PreResize[Item].Size + SizeIncrease;
					if Item.Size == self.State.PreResize[Item].Size + SizeIncrease then
						Item.CFrame = ( self.Options.directions == "normal" and self.State.PreResize[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, increase / 2 ) ) )
									  or ( self.Options.directions == "both" and self.State.PreResize[Item].CFrame );
					-- If the resizing was not possible, revert `Item`'s state
					else
						Item.Size = PreviousItemState.Size;
						Item.CFrame = PreviousItemState.CFrame;
					end;

				elseif face == Enum.NormalId.Left then

					-- Calculate the appropriate increment to the size based on the shape of `Item`
					local SizeIncrease;
					if ( pcall( function () local test = Item.Shape; end ) ) and ( Item.Shape == Enum.PartType.Ball or Item.Shape == Enum.PartType.Cylinder ) then
						SizeIncrease = Vector3.new( increase, increase, increase );
					elseif not ( pcall( function () local test = Item.Shape; end ) ) or ( Item.Shape and Item.Shape == Enum.PartType.Block ) then
						SizeIncrease = Vector3.new( increase, 0, 0 );
					end;

					Item.Size = self.State.PreResize[Item].Size + SizeIncrease;
					if Item.Size == self.State.PreResize[Item].Size + SizeIncrease then
						Item.CFrame = ( self.Options.directions == "normal" and self.State.PreResize[Item].CFrame:toWorldSpace( CFrame.new( -increase / 2, 0, 0 ) ) )
									  or ( self.Options.directions == "both" and self.State.PreResize[Item].CFrame );
					-- If the resizing was not possible, revert `Item`'s state
					else
						Item.Size = PreviousItemState.Size;
						Item.CFrame = PreviousItemState.CFrame;
					end;

				elseif face == Enum.NormalId.Right then

					-- Calculate the appropriate increment to the size based on the shape of `Item`
					local SizeIncrease;
					if ( pcall( function () local test = Item.Shape; end ) ) and ( Item.Shape == Enum.PartType.Ball or Item.Shape == Enum.PartType.Cylinder ) then
						SizeIncrease = Vector3.new( increase, increase, increase );
					elseif not ( pcall( function () local test = Item.Shape; end ) ) or ( Item.Shape and Item.Shape == Enum.PartType.Block ) then
						SizeIncrease = Vector3.new( increase, 0, 0 );
					end;

					Item.Size = self.State.PreResize[Item].Size + SizeIncrease;
					if Item.Size == self.State.PreResize[Item].Size + SizeIncrease then
						Item.CFrame = ( self.Options.directions == "normal" and self.State.PreResize[Item].CFrame:toWorldSpace( CFrame.new( increase / 2, 0, 0 ) ) )
									  or ( self.Options.directions == "both" and self.State.PreResize[Item].CFrame );
					-- If the resizing was not possible, revert `Item`'s state
					else
						Item.Size = PreviousItemState.Size;
						Item.CFrame = PreviousItemState.CFrame;
					end;
				end;

				-- Make joints with surrounding parts again once the resizing is done
				Item:MakeJoints();

			end;

		end );

	end;

	-- Stop listening for the existence of the previous adornee (if any)
	if self.Connections.AdorneeExistenceListener then
		self.Connections.AdorneeExistenceListener:disconnect();
		self.Connections.AdorneeExistenceListener = nil;
	end;

	-- Attach the handles to `Part`
	self.Handles.Adornee = Part;

	-- Make sure to hide the handles if `Part` suddenly stops existing
	self.Connections.AdorneeExistenceListener = Part.AncestryChanged:connect( function ( Object, NewParent )

		-- Make sure this change in parent applies directly to `Part`
		if Object ~= Part then
			return;
		end;

		-- Show the handles according to the existence of the part
		if NewParent == nil then
			self:hideHandles();
		else
			self:showHandles( Part );
		end;

	end );

end;

Tools.Resize.hideHandles = function ( self )

	-- Hide the handles if they exist
	if self.Handles then
		self.Handles.Adornee = nil;
	end;

end;

Tools.Resize.Loaded = true;
end))
LocalScript71.Disabled = true
LocalScript72.Name = "BTRotateTool"
LocalScript72.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript72,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Rotate tool
------------------------------------------

-- Create the tool
Tools.Rotate = {};

-- Create structures to hold data that the tool needs
Tools.Rotate.Connections = {};

Tools.Rotate.Options = {
	["increment"] = 15;
	["pivot"] = "center"
};

Tools.Rotate.State = {
	["PreRotation"] = {};
	["rotating"] = false;
	["previous_distance"] = 0;
	["degrees_rotated"] = 0;
	["rotation_size"] = 0;
};

Tools.Rotate.Listeners = {};

-- Define the color of the tool
Tools.Rotate.Color = BrickColor.new( "Bright green" );

-- Start adding functionality to the tool
Tools.Rotate.Listeners.Equipped = function ()

	local self = Tools.Rotate;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Create the boundingbox if it doesn't already exist
	if not self.BoundingBox then
		self.BoundingBox = RbxUtility.Create "Part" {
			Name = "BTBoundingBox";
			CanCollide = false;
			Transparency = 1;
			Anchored = true;
		};
	end;
	Mouse.TargetFilter = self.BoundingBox;

	-- Update the pivot option
	self:changePivot( self.Options.pivot );

	-- Oh, and update the boundingbox and the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

				-- Update the boundingbox if it's visible
				if self.Options.pivot == "center" then
					self:updateBoundingBox();
				end;

			end;

		end;

	end )();

	-- Also enable the ability to select an edge as a pivot
	SelectEdge:start( function ( EdgeMarker )
		self:changePivot( "last" );
		self.Options.PivotPoint = EdgeMarker.CFrame;
		self.Connections.EdgeSelectionRemover = Selection.Changed:connect( function ()
			self.Options.PivotPoint = nil;
			if self.Connections.EdgeSelectionRemover then
				self.Connections.EdgeSelectionRemover:disconnect();
				self.Connections.EdgeSelectionRemover = nil;
			end;
		end );
		self:showHandles( EdgeMarker );
	end );

end;

Tools.Rotate.Listeners.Unequipped = function ()

	local self = Tools.Rotate;

	-- Stop the update loop
	if self.Updater then
		self.Updater();
		self.Updater = nil;
	end;

	-- Disable the ability to select edges
	SelectEdge:stop();
	if self.Options.PivotPoint then
		self.Options.PivotPoint = nil;
	end;

	-- Hide the GUI
	self:hideGUI();

	-- Hide the handles
	self:hideHandles();

	-- Clear out any temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of the selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Rotate.Listeners.Button1Down = function ()

	local self = Tools.Rotate;

	if not self.State.rotating and self.Options.PivotPoint then
		self.Options.PivotPoint = nil;
	end;

end;

Tools.Rotate.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTRotateToolGUI" ):Clone();
		Container.Parent = UI;

		-- Change the pivot type option when the button is clicked
		Container.PivotOption.Center.Button.MouseButton1Down:connect( function ()
			self:changePivot( "center" );
		end );

		Container.PivotOption.Local.Button.MouseButton1Down:connect( function ()
			self:changePivot( "local" );
		end );

		Container.PivotOption.Last.Button.MouseButton1Down:connect( function ()
			self:changePivot( "last" );
		end );

		-- Change the increment option when the value of the textbox is updated
		Container.IncrementOption.Increment.TextBox.FocusLost:connect( function ( enter_pressed )
			self.Options.increment = tonumber( Container.IncrementOption.Increment.TextBox.Text ) or self.Options.increment;
			Container.IncrementOption.Increment.TextBox.Text = tostring( self.Options.increment );
		end );

		-- Add functionality to the rotation inputs
		Container.Info.RotationInfo.X.TextButton.MouseButton1Down:connect( function ()
			self.State.rot_x_focused = true;
			Container.Info.RotationInfo.X.TextBox:CaptureFocus();
		end );
		Container.Info.RotationInfo.X.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.RotationInfo.X.TextBox.Text );
			if potential_new then
				self:changeRotation( 'x', math.rad( potential_new ) );
			end;
			self.State.rot_x_focused = false;
		end );
		Container.Info.RotationInfo.Y.TextButton.MouseButton1Down:connect( function ()
			self.State.rot_y_focused = true;
			Container.Info.RotationInfo.Y.TextBox:CaptureFocus();
		end );
		Container.Info.RotationInfo.Y.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.RotationInfo.Y.TextBox.Text );
			if potential_new then
				self:changeRotation( 'y', math.rad( potential_new ) );
			end;
			self.State.rot_y_focused = false;
		end );
		Container.Info.RotationInfo.Z.TextButton.MouseButton1Down:connect( function ()
			self.State.rot_z_focused = true;
			Container.Info.RotationInfo.Z.TextBox:CaptureFocus();
		end );
		Container.Info.RotationInfo.Z.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.Info.RotationInfo.Z.TextBox.Text );
			if potential_new then
				self:changeRotation( 'z', math.rad( potential_new ) );
			end;
			self.State.rot_z_focused = false;
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Rotate.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_cframes = {};
		terminal_cframes = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.CFrame = self.initial_cframes[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.CFrame = self.terminal_cframes[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_cframes[Item] = Item.CFrame;
		end;
	end;

end;

Tools.Rotate.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_cframes[Item] = Item.CFrame;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Rotate.changeRotation = function ( self, component, new_value )

	self:startHistoryRecord();

	-- Change the rotation of each item selected
	for _, Item in pairs( Selection.Items ) do
		local old_x_rot, old_y_rot, old_z_rot = Item.CFrame:toEulerAnglesXYZ();
		Item.CFrame = CFrame.new( Item.Position ) * CFrame.Angles(
			component == 'x' and new_value or old_x_rot,
			component == 'y' and new_value or old_y_rot,
			component == 'z' and new_value or old_z_rot
		);
	end;

	self:finishHistoryRecord();

end;

Tools.Rotate.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	local GUI = self.GUI;

	if #Selection.Items > 0 then

		-- Look for identical numbers in each axis
		local rot_x, rot_y, rot_z = nil, nil, nil;
		for item_index, Item in pairs( Selection.Items ) do

			local item_rot_x, item_rot_y, item_rot_z = Item.CFrame:toEulerAnglesXYZ();

			-- Set the first values for the first item
			if item_index == 1 then
				rot_x, rot_y, rot_z = _round( math.deg( item_rot_x ), 2 ), _round( math.deg( item_rot_y ), 2 ), _round( math.deg( item_rot_z ), 2 );

			-- Otherwise, compare them and set them to `nil` if they're not identical
			else
				if rot_x ~= _round( math.deg( item_rot_x ), 2 ) then
					rot_x = nil;
				end;
				if rot_y ~= _round( math.deg( item_rot_y ), 2 ) then
					rot_y = nil;
				end;
				if rot_z ~= _round( math.deg( item_rot_z ), 2 ) then
					rot_z = nil;
				end;
			end;

		end;

		-- Update the size info on the GUI
		if not self.State.rot_x_focused then
			GUI.Info.RotationInfo.X.TextBox.Text = rot_x and tostring( rot_x ) or "*";
		end;
		if not self.State.rot_y_focused then
			GUI.Info.RotationInfo.Y.TextBox.Text = rot_y and tostring( rot_y ) or "*";
		end;
		if not self.State.rot_z_focused then
			GUI.Info.RotationInfo.Z.TextBox.Text = rot_z and tostring( rot_z ) or "*";
		end;

		GUI.Info.Visible = true;
	else
		GUI.Info.Visible = false;
	end;

	if self.State.degrees_rotated then
		GUI.Changes.Text.Text = "rotated " .. tostring( self.State.degrees_rotated ) .. " degrees";
		GUI.Changes.Position = GUI.Info.Visible and UDim2.new( 0, 5, 0, 165 ) or UDim2.new( 0, 5, 0, 100 );
		GUI.Changes.Visible = true;
	else
		GUI.Changes.Text.Text = "";
		GUI.Changes.Visible = false;
	end;

end;

Tools.Rotate.hideGUI = function ( self )

	-- Hide the GUI if it exists
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Rotate.updateBoundingBox = function ( self )

	if #Selection.Items > 0 then
		local SelectionSize, SelectionPosition = _getCollectionInfo( Selection.Items );
		self.BoundingBox.Size = SelectionSize;
		self.BoundingBox.CFrame = SelectionPosition;
		self:showHandles( self.BoundingBox );

	else
		self:hideHandles();
	end;

end;

Tools.Rotate.changePivot = function ( self, new_pivot )

	-- Have a quick reference to the GUI (if any)
	local PivotOptionGUI = self.GUI and self.GUI.PivotOption or nil;

	-- Disconnect any handle-related listeners that are specific to a certain pivot option
	if self.Connections.HandleFocusChangeListener then
		self.Connections.HandleFocusChangeListener:disconnect();
		self.Connections.HandleFocusChangeListener = nil;
	end;

	if self.Connections.HandleSelectionChangeListener then
		self.Connections.HandleSelectionChangeListener:disconnect();
		self.Connections.HandleSelectionChangeListener = nil;
	end;

	-- Remove any temporary edge selection
	if self.Options.PivotPoint then
		self.Options.PivotPoint = nil;
	end;

	if new_pivot == "center" then

		-- Update the options
		self.Options.pivot = "center";

		-- Focus the handles on the boundingbox
		self:showHandles( self.BoundingBox );

		-- Update the GUI's option panel
		if self.GUI then
			PivotOptionGUI.Center.SelectedIndicator.BackgroundTransparency = 0;
			PivotOptionGUI.Center.Background.Image = dark_slanted_rectangle;
			PivotOptionGUI.Local.SelectedIndicator.BackgroundTransparency = 1;
			PivotOptionGUI.Local.Background.Image = light_slanted_rectangle;
			PivotOptionGUI.Last.SelectedIndicator.BackgroundTransparency = 1;
			PivotOptionGUI.Last.Background.Image = light_slanted_rectangle;
		end;

	end;

	if new_pivot == "local" then

		-- Update the options
		self.Options.pivot = "local";

		-- Always have the handles on the most recent addition to the selection
		self.Connections.HandleSelectionChangeListener = Selection.Changed:connect( function ()

			-- Clear out any previous adornee
			self:hideHandles();

			-- If there /is/ a last item in the selection, attach the handles to it
			if Selection.Last then
				self:showHandles( Selection.Last );
			end;

		end );

		-- Switch the adornee of the handles if the second mouse button is pressed
		self.Connections.HandleFocusChangeListener = Mouse.Button2Up:connect( function ()

			-- Make sure the platform doesn't think we're selecting
			override_selection = true;

			-- If the target is in the selection, make it the new adornee
			if Selection:find( Mouse.Target ) then
				Selection:focus( Mouse.Target );
				self:showHandles( Mouse.Target );
			end;

		end );

		-- Finally, attach the handles to the last item added to the selection (if any)
		if Selection.Last then
			self:showHandles( Selection.Last );
		end;

		-- Update the GUI's option panel
		if self.GUI then
			PivotOptionGUI.Center.SelectedIndicator.BackgroundTransparency = 1;
			PivotOptionGUI.Center.Background.Image = light_slanted_rectangle;
			PivotOptionGUI.Local.SelectedIndicator.BackgroundTransparency = 0;
			PivotOptionGUI.Local.Background.Image = dark_slanted_rectangle;
			PivotOptionGUI.Last.SelectedIndicator.BackgroundTransparency = 1;
			PivotOptionGUI.Last.Background.Image = light_slanted_rectangle;
		end;

	end;

	if new_pivot == "last" then

		-- Update the options
		self.Options.pivot = "last";

		-- Always have the handles on the most recent addition to the selection
		self.Connections.HandleSelectionChangeListener = Selection.Changed:connect( function ()

			-- Clear out any previous adornee
			if not self.Options.PivotPoint then
				self:hideHandles();
			end;

			-- If there /is/ a last item in the selection, attach the handles to it
			if Selection.Last and not self.Options.PivotPoint then
				self:showHandles( Selection.Last );
			end;

		end );

		-- Switch the adornee of the handles if the second mouse button is pressed
		self.Connections.HandleFocusChangeListener = Mouse.Button2Up:connect( function ()

			-- Make sure the platform doesn't think we're selecting
			override_selection = true;

			-- If the target is in the selection, make it the new adornee
			if Selection:find( Mouse.Target ) then
				Selection:focus( Mouse.Target );
				self:showHandles( Mouse.Target );
			end;

		end );

		-- Finally, attach the handles to the last item added to the selection (if any)
		if Selection.Last then
			self:showHandles( Selection.Last );
		end;

		-- Update the GUI's option panel
		if self.GUI then
			PivotOptionGUI.Center.SelectedIndicator.BackgroundTransparency = 1;
			PivotOptionGUI.Center.Background.Image = light_slanted_rectangle;
			PivotOptionGUI.Local.SelectedIndicator.BackgroundTransparency = 1;
			PivotOptionGUI.Local.Background.Image = light_slanted_rectangle;
			PivotOptionGUI.Last.SelectedIndicator.BackgroundTransparency = 0;
			PivotOptionGUI.Last.Background.Image = dark_slanted_rectangle;
		end;

	end;

end;


Tools.Rotate.showHandles = function ( self, Part )

	-- Create the handles if they don't exist yet
	if not self.Handles then

		-- Create the object
		self.Handles = RbxUtility.Create "ArcHandles" {
			Name = "BTRotationHandles";
			Color = self.Color;
			Parent = GUIContainer;
		};

		-- Add functionality to the handles

		self.Handles.MouseButton1Down:connect( function ()

			-- Prevent the platform from thinking we're selecting
			override_selection = true;
			self.State.rotating = true;

			-- Clear the change stats
			self.State.degrees_rotated = 0;
			self.State.rotation_size = 0;

			self:startHistoryRecord();

			-- Do a few things to the selection before manipulating it
			for _, Item in pairs( Selection.Items ) do

				-- Keep a copy of the state of each item
				self.State.PreRotation[Item] = Item:Clone();

				-- Anchor each item
				Item.Anchored = true;

			end;

			-- Also keep the position of the original selection
			local PreRotationSize, PreRotationPosition = _getCollectionInfo( self.State.PreRotation );
			self.State.PreRotationPosition = PreRotationPosition;

			-- Return stuff to normal once the mouse button is released
			self.Connections.HandleReleaseListener = Mouse.Button1Up:connect( function ()

				-- Prevent the platform from thinking we're selecting
				override_selection = true;
				self.State.rotating = false;

				-- Stop this connection from firing again
				if self.Connections.HandleReleaseListener then
					self.Connections.HandleReleaseListener:disconnect();
					self.Connections.HandleReleaseListener = nil;
				end;

				self:finishHistoryRecord();

				-- Restore properties that may have been changed temporarily
				-- from the pre-rotation state copies
				for Item, PreviousItemState in pairs( self.State.PreRotation ) do
					Item.Anchored = PreviousItemState.Anchored;
					self.State.PreRotation[Item] = nil;
					Item:MakeJoints();
				end;

			end );

		end );

		self.Handles.MouseDrag:connect( function ( axis, drag_distance )

			-- Round down and convert the drag distance to degrees to make it easier to work with
			local drag_distance = math.floor( math.deg( drag_distance ) );

			-- Calculate which multiple of the increment to use based on the current angle's
			-- proximity to their nearest upper and lower multiples

			local difference = drag_distance % self.Options.increment;

			local lower_degree = drag_distance - difference;
			local upper_degree = drag_distance - difference + self.Options.increment;

			local lower_degree_proximity = math.abs( drag_distance - lower_degree );
			local upper_degree_proximity = math.abs( drag_distance - upper_degree );

			if lower_degree_proximity <= upper_degree_proximity then
				drag_distance = lower_degree;
			else
				drag_distance = upper_degree;
			end;

			local increase = self.Options.increment * math.floor( drag_distance / self.Options.increment );

			self.State.degrees_rotated = drag_distance;

			-- Go through the selection and make changes to it
			for _, Item in pairs( Selection.Items ) do

				-- Keep a copy of `Item` in case we need to revert anything
				local PreviousItemState = Item:Clone();

				-- Break any of `Item`'s joints so it can move freely
				Item:BreakJoints();

				-- Rotate `Item` according to the options and the handle that was used
				if axis == Enum.Axis.Y then
					if self.Options.pivot == "center" then
						Item.CFrame = self.State.PreRotationPosition:toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( 0, math.rad( increase ), 0 ) ):toWorldSpace( self.State.PreRotation[Item].CFrame:toObjectSpace( self.State.PreRotationPosition ):inverse() );
					elseif self.Options.pivot == "local" then
						Item.CFrame = self.State.PreRotation[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( 0, math.rad( increase ), 0 ) );
					elseif self.Options.pivot == "last" then
						Item.CFrame = ( self.Options.PivotPoint or self.State.PreRotation[Selection.Last].CFrame ):toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( 0, math.rad( increase ), 0 ) ):toWorldSpace( self.State.PreRotation[Item].CFrame:toObjectSpace( self.Options.PivotPoint or self.State.PreRotation[Selection.Last].CFrame ):inverse() );
					end;
				elseif axis == Enum.Axis.X then
					if self.Options.pivot == "center" then
						Item.CFrame = self.State.PreRotationPosition:toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( math.rad( increase ), 0, 0 ) ):toWorldSpace( self.State.PreRotation[Item].CFrame:toObjectSpace( self.State.PreRotationPosition ):inverse() );
					elseif self.Options.pivot == "local" then
						Item.CFrame = self.State.PreRotation[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( math.rad( increase ), 0, 0 ) );
					elseif self.Options.pivot == "last" then
						Item.CFrame = ( self.Options.PivotPoint or self.State.PreRotation[Selection.Last].CFrame ):toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( math.rad( increase ), 0, 0 ) ):toWorldSpace( self.State.PreRotation[Item].CFrame:toObjectSpace( self.Options.PivotPoint or self.State.PreRotation[Selection.Last].CFrame ):inverse() );
					end;
				elseif axis == Enum.Axis.Z then
					if self.Options.pivot == "center" then
						Item.CFrame = self.State.PreRotationPosition:toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( 0, 0, math.rad( increase ) ) ):toWorldSpace( self.State.PreRotation[Item].CFrame:toObjectSpace( self.State.PreRotationPosition ):inverse() );
					elseif self.Options.pivot == "local" then
						Item.CFrame = self.State.PreRotation[Item].CFrame:toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( 0, 0, math.rad( increase ) ) );
					elseif self.Options.pivot == "last" then
						Item.CFrame = ( self.Options.PivotPoint or self.State.PreRotation[Selection.Last].CFrame ):toWorldSpace( CFrame.new( 0, 0, 0 ) * CFrame.Angles( 0, 0, math.rad( increase ) ) ):toWorldSpace( self.State.PreRotation[Item].CFrame:toObjectSpace( self.Options.PivotPoint or self.State.PreRotation[Selection.Last].CFrame ):inverse() );
					end;
				end;

				-- Make joints with surrounding parts again once the resizing is done
				Item:MakeJoints();

			end;

		end );

	end;

	-- Stop listening for the existence of the previous adornee (if any)
	if self.Connections.AdorneeExistenceListener then
		self.Connections.AdorneeExistenceListener:disconnect();
		self.Connections.AdorneeExistenceListener = nil;
	end;

	-- Attach the handles to `Part`
	self.Handles.Adornee = Part;

	-- Make sure to hide the handles if `Part` suddenly stops existing
	self.Connections.AdorneeExistenceListener = Part.AncestryChanged:connect( function ( Object, NewParent )

		-- Make sure this change in parent applies directly to `Part`
		if Object ~= Part then
			return;
		end;

		-- Show the handles according to the existence of the part
		if NewParent == nil then
			self:hideHandles();
		else
			self:showHandles( Part );
		end;

	end );

end;

Tools.Rotate.hideHandles = function ( self )

	-- Hide the handles if they exist
	if self.Handles then
		self.Handles.Adornee = nil;
	end;

end;

Tools.Rotate.Loaded = true;
end))
LocalScript72.Disabled = true
LocalScript73.Name = "BTPaintTool"
LocalScript73.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript73,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Paint tool
------------------------------------------

-- Create the main container for this tool
Tools.Paint = {};

-- Define the color of the tool
Tools.Paint.Color = BrickColor.new( "Really red" );

-- Define options
Tools.Paint.Options = {
	["Color"] = nil
};

Tools.Paint.State = {};

-- Add listeners
Tools.Paint.Listeners = {};

Tools.Paint.Listeners.Equipped = function ()

	local self = Tools.Paint;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Show the GUI
	self:showGUI();

	-- Update the selected color
	self:changeColor( self.Options.Color );

end;

Tools.Paint.Listeners.Unequipped = function ()

	local self = Tools.Paint;

	-- Clear out the preferred color option
	self:changeColor( nil );

	-- Hide the GUI
	self:hideGUI();

	-- Restore the original color of the selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Paint.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_colors = {};
		terminal_colors = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.BrickColor = self.initial_colors[Target];
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.BrickColor = self.terminal_colors[Target];
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_colors[Item] = Item.BrickColor;
		end;
	end;

end;

Tools.Paint.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_colors[Item] = Item.BrickColor;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Paint.Listeners.Button1Up = function ()

	local self = Tools.Paint;

	-- Make sure that they clicked on one of the items in their selection
	-- (and they weren't multi-selecting)
	if Selection:find( Mouse.Target ) and not selecting and not selecting then

		override_selection = true;

		self:startHistoryRecord();

		-- Paint all of the selected items `Tools.Paint.Options.Color`
		if self.Options.Color then
			for _, Item in pairs( Selection.Items ) do
				Item.BrickColor = self.Options.Color;
			end;
		end;

		self:finishHistoryRecord();

	end;

end;

Tools.Paint.changeColor = function ( self, Color )

	-- Alright so if `Color` is given, set that as the preferred color
	if Color then

		-- First of all, change the color option itself
		self.Options.Color = Color;

		self:startHistoryRecord();

		-- Then, we want to update the color of any items in the selection
		for _, Item in pairs( Selection.Items ) do
			Item.BrickColor = Color;
		end;

		self:finishHistoryRecord();

		-- After that, we want to mark our new color in the palette
		if self.GUI then

			-- First clear out any other marks
			for _, ColorSquare in pairs( self.GUI.Palette:GetChildren() ) do
				ColorSquare.Text = "";
			end;

			-- Then mark the right square
			self.GUI.Palette[Color.Name].Text = "X";

		end;

	-- Otherwise, let's assume no color at all
	else

		-- Set the preferred color to none
		self.Options.Color = nil;

		-- Clear out any color option marks on any of the squares
		if self.GUI then
			for _, ColorSquare in pairs( self.GUI.Palette:GetChildren() ) do
				ColorSquare.Text = "";
			end;
		end;

	end;

end;

Tools.Paint.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTPaintToolGUI" ):Clone();
		Container.Parent = UI;

		for _, ColorButton in pairs( Container.Palette:GetChildren() ) do
			ColorButton.MouseButton1Click:connect( function ()
				self:changeColor( BrickColor.new( ColorButton.Name ) );
			end );
		end;

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Paint.hideGUI = function ( self )

	-- Hide the GUI if it exists
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Paint.Loaded = true;
end))
LocalScript73.Disabled = true
LocalScript74.Name = "BTSurfaceTool"
LocalScript74.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript74,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Surface tool
------------------------------------------

-- Create the tool
Tools.Surface = {};

-- Define the tool's color
Tools.Surface.Color = BrickColor.new( "Bright violet" );

-- Keep a container for temporary connections
Tools.Surface.Connections = {};

-- Keep a container for state data
Tools.Surface.State = {
	["type"] = nil;
};

-- Maintain a container for options
Tools.Surface.Options = {
	["side"] = Enum.NormalId.Front;
};

-- Keep a container for platform event connections
Tools.Surface.Listeners = {};

-- Start adding functionality to the tool
Tools.Surface.Listeners.Equipped = function ()

	local self = Tools.Surface;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Restore the side option
	self:changeSurface( self.Options.side );

	-- Update the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the surface type of every item in the selection
				local surface_type = nil;
				for item_index, Item in pairs( Selection.Items ) do

					-- Set the first values for the first item
					if item_index == 1 then
						surface_type = Item[self.Options.side.Name .. "Surface"];

					-- Otherwise, compare them and set them to `nil` if they're not identical
					else
						if surface_type ~= Item[self.Options.side.Name .. "Surface"] then
							surface_type = nil;
						end;
					end;

				end;

				self.State.type = surface_type;

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

			end;

		end;

	end )();

end;

Tools.Surface.Listeners.Unequipped = function ()

	local self = Tools.Surface;

	-- Stop the GUI updating loop
	self.Updater();
	self.Updater = nil;

	-- Hide the GUI
	self:hideGUI();

	-- Disconnect temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Surface.Listeners.Button2Down = function ()

	local self = Tools.Surface;

	-- Capture the camera rotation (for later use
	-- in determining whether a surface was being
	-- selected or the camera was being rotated
	-- with the right mouse button)
	local cr_x, cr_y, cr_z = Services.Workspace.CurrentCamera.CoordinateFrame:toEulerAnglesXYZ();
	self.State.PreB2DownCameraRotation = Vector3.new( cr_x, cr_y, cr_z );

end;

Tools.Surface.Listeners.Button2Up = function ()

	local self = Tools.Surface;

	local cr_x, cr_y, cr_z = Services.Workspace.CurrentCamera.CoordinateFrame:toEulerAnglesXYZ();
	local CameraRotation = Vector3.new( cr_x, cr_y, cr_z );

	-- If a surface is selected
	if Selection:find( Mouse.Target ) and self.State.PreB2DownCameraRotation == CameraRotation then
		self:changeSurface( Mouse.TargetSurface );
	end;

end;

Tools.Surface.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		target_surface = self.Options.side;
		initial_surfaces = {};
		terminal_surfaces = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target[self.target_surface.Name .. "Surface"] = self.initial_surfaces[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target[self.target_surface.Name .. "Surface"] = self.terminal_surfaces[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_surfaces[Item] = Item[self.Options.side.Name .. "Surface"];
		end;
	end;

end;

Tools.Surface.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_surfaces[Item] = Item[self.Options.side.Name .. "Surface"];
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Surface.SpecialTypeNames = {
	SmoothNoOutlines = "NO OUTLINE",
	Inlet = "INLETS"
};

Tools.Surface.changeType = function ( self, surface_type )

	self:startHistoryRecord();

	-- Apply `surface_type` to all items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item[self.Options.side.Name .. "Surface"] = surface_type;
		Item:MakeJoints();
	end;

	self:finishHistoryRecord();

	self.TypeDropdown:selectOption( self.SpecialTypeNames[surface_type.Name] or surface_type.Name:upper() );
	if self.TypeDropdown.open then
		self.TypeDropdown:toggle();
	end;
end;

Tools.Surface.changeSurface = function ( self, surface )
	self.Options.side = surface;
	self.SideDropdown:selectOption( surface.Name:upper() );
	if self.SideDropdown.open then
		self.SideDropdown:toggle();
	end;
end;

Tools.Surface.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	if #Selection.Items > 0 then
		self.TypeDropdown:selectOption( self.State.type and ( self.SpecialTypeNames[self.State.type.Name] or self.State.type.Name:upper() ) or "*" );
	else
		self.TypeDropdown:selectOption( "" );
	end;

end;

Tools.Surface.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTSurfaceToolGUI" ):Clone();
		Container.Parent = UI;

		local SideDropdown = createDropdown();
		self.SideDropdown = SideDropdown;
		SideDropdown.Frame.Parent = Container.SideOption;
		SideDropdown.Frame.Position = UDim2.new( 0, 30, 0, 0 );
		SideDropdown.Frame.Size = UDim2.new( 0, 72, 0, 25 );

		SideDropdown:addOption( "TOP" ).MouseButton1Up:connect( function ()
			self:changeSurface( Enum.NormalId.Top );
		end );
		SideDropdown:addOption( "BOTTOM" ).MouseButton1Up:connect( function ()
			self:changeSurface( Enum.NormalId.Bottom );
		end );
		SideDropdown:addOption( "FRONT" ).MouseButton1Up:connect( function ()
			self:changeSurface( Enum.NormalId.Front );
		end );
		SideDropdown:addOption( "BACK" ).MouseButton1Up:connect( function ()
			self:changeSurface( Enum.NormalId.Back );
		end );
		SideDropdown:addOption( "LEFT" ).MouseButton1Up:connect( function ()
			self:changeSurface( Enum.NormalId.Left );
		end );
		SideDropdown:addOption( "RIGHT" ).MouseButton1Up:connect( function ()
			self:changeSurface( Enum.NormalId.Right );
		end );

		local TypeDropdown = createDropdown();
		self.TypeDropdown = TypeDropdown;
		TypeDropdown.Frame.Parent = Container.TypeOption;
		TypeDropdown.Frame.Position = UDim2.new( 0, 30, 0, 0 );
		TypeDropdown.Frame.Size = UDim2.new( 0, 87, 0, 25 );

		TypeDropdown:addOption( "STUDS" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Studs );
		end );
		TypeDropdown:addOption( "INLETS" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Inlet );
		end );
		TypeDropdown:addOption( "SMOOTH" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Smooth );
		end );
		TypeDropdown:addOption( "WELD" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Weld );
		end );
		TypeDropdown:addOption( "GLUE" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Glue );
		end );
		TypeDropdown:addOption( "UNIVERSAL" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Universal );
		end );
		TypeDropdown:addOption( "HINGE" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Hinge );
		end );
		TypeDropdown:addOption( "MOTOR" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.Motor );
		end );
		TypeDropdown:addOption( "NO OUTLINE" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.SurfaceType.SmoothNoOutlines );
		end );

		self.GUI = Container;

	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Surface.hideGUI = function ( self )

	-- Hide the GUI if it exists already
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Surface.Loaded = true;
end))
LocalScript74.Disabled = true
LocalScript75.Name = "BTMaterialTool"
LocalScript75.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript75,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Material tool
------------------------------------------

-- Create the tool
Tools.Material = {};
Tools.Material.Color = BrickColor.new( "Bright violet" );
Tools.Material.Connections = {};
Tools.Material.State = {
	["material"] = nil;
	["reflectance_focused"] = false;
	["transparency_focused"] = false;
};
Tools.Material.Listeners = {};
Tools.Material.SpecialMaterialNames = {
	CorrodedMetal = "CORRODED METAL",
	DiamondPlate = "DIAMOND PLATE",
	SmoothPlastic = "SMOOTH PLASTIC"
};

-- Start adding functionality to the tool
Tools.Material.Listeners.Equipped = function ()

	local self = Tools.Material;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Update the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the material type of every item in the selection
				local material_type, transparency, reflectance = nil, nil, nil;
				for item_index, Item in pairs( Selection.Items ) do

					-- Set the first values for the first item
					if item_index == 1 then
						material_type = Item.Material;
						transparency = Item.Transparency;
						reflectance = Item.Reflectance;

					-- Otherwise, compare them and set them to `nil` if they're not identical
					else
						if material_type ~= Item.Material then
							material_type = nil;
						end;
						if reflectance ~= Item.Reflectance then
							reflectance = nil;
						end;
						if transparency ~= Item.Transparency then
							transparency = nil;
						end;
					end;

				end;

				self.State.material = material_type;
				self.State.transparency = transparency;
				self.State.reflectance = reflectance;

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

			end;

		end;

	end )();

end;

Tools.Material.Listeners.Unequipped = function ()

	local self = Tools.Material;

	-- Stop the GUI updating loop
	self.Updater();
	self.Updater = nil;

	-- Hide the GUI
	self:hideGUI();

	-- Disconnect temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Material.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_material = {};
		terminal_material = {};
		initial_transparency = {};
		terminal_transparency = {};
		initial_reflectance = {};
		terminal_reflectance = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.Material = self.initial_material[Target];
					Target.Transparency = self.initial_transparency[Target];
					Target.Reflectance = self.initial_reflectance[Target];
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.Material = self.terminal_material[Target];
					Target.Transparency = self.terminal_transparency[Target];
					Target.Reflectance = self.terminal_reflectance[Target];
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_material[Item] = Item.Material;
			self.State.HistoryRecord.initial_transparency[Item] = Item.Transparency;
			self.State.HistoryRecord.initial_reflectance[Item] = Item.Reflectance;
		end;
	end;

end;

Tools.Material.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_material[Item] = Item.Material;
			self.State.HistoryRecord.terminal_transparency[Item] = Item.Transparency;
			self.State.HistoryRecord.terminal_reflectance[Item] = Item.Reflectance;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Material.changeMaterial = function ( self, material_type )

	self:startHistoryRecord();

	-- Apply `material_type` to all items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.Material = material_type;
	end;

	self:finishHistoryRecord();

	if self.MaterialDropdown.open then
		self.MaterialDropdown:toggle();
	end;
end;

Tools.Material.changeTransparency = function ( self, transparency )

	self:startHistoryRecord();

	-- Apply `transparency` to all items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.Transparency = transparency;
	end;

	self:finishHistoryRecord();

end;

Tools.Material.changeReflectance = function ( self, reflectance )

	self:startHistoryRecord();

	-- Apply `reflectance` to all items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.Reflectance = reflectance;
	end;

	self:finishHistoryRecord();

end;

Tools.Material.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	if #Selection.Items > 0 then
		self.GUI.Size = UDim2.new( 0, 200, 0, 145 );
		self.GUI.MaterialOption.Visible = true;
		self.GUI.ReflectanceOption.Visible = true;
		self.GUI.TransparencyOption.Visible = true;
		self.GUI.SelectNote.Visible = false;
		self.MaterialDropdown:selectOption( self.State.material and ( self.SpecialMaterialNames[self.State.material.Name] or self.State.material.Name:upper() ) or "*" );

		-- Update the text inputs without interrupting the user
		if not self.State.transparency_focused then
			self.GUI.TransparencyOption.TransparencyInput.TextBox.Text = self.State.transparency and tostring( _round( self.State.transparency, 2 ) ) or "*";
		end;
		if not self.State.reflectance_focused then
			self.GUI.ReflectanceOption.ReflectanceInput.TextBox.Text = self.State.reflectance and tostring( _round( self.State.reflectance, 2 ) ) or "*";
		end;

	else
		self.GUI.Size = UDim2.new( 0, 200, 0, 62 );
		self.GUI.MaterialOption.Visible = false;
		self.GUI.ReflectanceOption.Visible = false;
		self.GUI.TransparencyOption.Visible = false;
		self.GUI.SelectNote.Visible = true;
		self.MaterialDropdown:selectOption( "" );
		self.GUI.TransparencyOption.TransparencyInput.TextBox.Text = "";
		self.GUI.ReflectanceOption.ReflectanceInput.TextBox.Text = "";
	end;

end;


Tools.Material.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTMaterialToolGUI" ):Clone();
		Container.Parent = UI;

		local MaterialDropdown = createDropdown();
		self.MaterialDropdown = MaterialDropdown;
		MaterialDropdown.Frame.Parent = Container.MaterialOption;
		MaterialDropdown.Frame.Position = UDim2.new( 0, 50, 0, 0 );
		MaterialDropdown.Frame.Size = UDim2.new( 0, 130, 0, 25 );

		MaterialDropdown:addOption( "SMOOTH PLASTIC" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.SmoothPlastic );
		end );
		MaterialDropdown:addOption( "PLASTIC" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Plastic );
		end );
		MaterialDropdown:addOption( "CONCRETE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Concrete );
		end );
		MaterialDropdown:addOption( "DIAMOND PLATE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.DiamondPlate );
		end );
		MaterialDropdown:addOption( "CORRODED METAL" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.CorrodedMetal );
		end );
		MaterialDropdown:addOption( "BRICK" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Brick );
		end );
		MaterialDropdown:addOption( "FABRIC" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Fabric );
		end );
		MaterialDropdown:addOption( "FOIL" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Foil );
		end );
		MaterialDropdown:addOption( "GRANITE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Granite );
		end );
		MaterialDropdown:addOption( "GRASS" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Grass );
		end );
		MaterialDropdown:addOption( "ICE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Ice );
		end );
		MaterialDropdown:addOption( "MARBLE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Marble );
		end );
		MaterialDropdown:addOption( "PEBBLE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Pebble );
		end );
		MaterialDropdown:addOption( "SAND" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Sand );
		end );
		MaterialDropdown:addOption( "SLATE" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Slate );
		end );
		MaterialDropdown:addOption( "WOOD" ).MouseButton1Up:connect( function ()
			self:changeMaterial( Enum.Material.Wood );
		end );

		-- Capture focus of the input when clicked
		-- (so we can detect when it is focused-on)
		Container.TransparencyOption.TransparencyInput.TextButton.MouseButton1Down:connect( function ()
			self.State.transparency_focused = true;
			Container.TransparencyOption.TransparencyInput.TextBox:CaptureFocus();
		end );

		-- Change the transparency when the value of the textbox is updated
		Container.TransparencyOption.TransparencyInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.TransparencyOption.TransparencyInput.TextBox.Text );
			if potential_new then
				if potential_new > 1 then
					potential_new = 1;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:changeTransparency( potential_new );
			end;
			self.State.transparency_focused = false;
		end );

		-- Capture focus of the input when clicked
		-- (so we can detect when it is focused-on)
		Container.ReflectanceOption.ReflectanceInput.TextButton.MouseButton1Down:connect( function ()
			self.State.reflectance_focused = true;
			Container.ReflectanceOption.ReflectanceInput.TextBox:CaptureFocus();
		end );

		-- Change the reflectance when the value of the textbox is updated
		Container.ReflectanceOption.ReflectanceInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.ReflectanceOption.ReflectanceInput.TextBox.Text );
			if potential_new then
				if potential_new > 1 then
					potential_new = 1;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:changeReflectance( potential_new );
			end;
			self.State.reflectance_focused = false;
		end );

		self.GUI = Container;

	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Material.hideGUI = function ( self )

	-- Hide the GUI if it exists already
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Material.Loaded = true;
end))
LocalScript75.Disabled = true
LocalScript76.Name = "BTAnchorTool"
LocalScript76.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript76,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Anchor tool
------------------------------------------

-- Create the tool
Tools.Anchor = {};

-- Create structures to hold data that the tool needs
Tools.Anchor.Connections = {};

Tools.Anchor.State = {
	["anchored"] = nil;
};

Tools.Anchor.Listeners = {};

-- Define the color of the tool
Tools.Anchor.Color = BrickColor.new( "Really black" );

-- Start adding functionality to the tool
Tools.Anchor.Listeners.Equipped = function ()

	local self = Tools.Anchor;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Update the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the anchor status of every item in the selection
				local anchor_status = nil;
				for item_index, Item in pairs( Selection.Items ) do

					-- Set the first values for the first item
					if item_index == 1 then
						anchor_status = Item.Anchored;

					-- Otherwise, compare them and set them to `nil` if they're not identical
					else
						if anchor_status ~= Item.Anchored then
							anchor_status = nil;
						end;
					end;

				end;

				self.State.anchored = anchor_status;

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

			end;

		end;

	end )();

	-- Listen for the Enter button to be pressed to toggle the anchor
	self.Connections.EnterButtonListener = Mouse.KeyDown:connect( function ( key )

		local key = key:lower();
		local key_code = key:byte();

		-- If the Enter button is pressed
		if key_code == 13 then

			if self.State.anchored == true then
				self:unanchor();

			elseif self.State.anchored == false then
				self:anchor();

			elseif self.State.anchored == nil then
				self:anchor();

			end;

		end;

	end );

end;


Tools.Anchor.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_positions = {};
		terminal_positions = {};
		initial_anchors = {};
		terminal_anchors = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.RotVelocity = Vector3.new( 0, 0, 0 );
					Target.Velocity = Vector3.new( 0, 0, 0 );
					Target.CFrame = self.initial_positions[Target];
					Target.Anchored = self.initial_anchors[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.RotVelocity = Vector3.new( 0, 0, 0 );
					Target.Velocity = Vector3.new( 0, 0, 0 );
					Target.CFrame = self.terminal_positions[Target];
					Target.Anchored = self.terminal_anchors[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_anchors[Item] = Item.Anchored;
			self.State.HistoryRecord.initial_positions[Item] = Item.CFrame;
		end;
	end;

end;

Tools.Anchor.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_anchors[Item] = Item.Anchored;
			self.State.HistoryRecord.terminal_positions[Item] = Item.CFrame;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Anchor.anchor = function ( self )

	self:startHistoryRecord();

	-- Anchor all the items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.Anchored = true;
		Item:MakeJoints();
	end;

	self:finishHistoryRecord();

end;

Tools.Anchor.unanchor = function ( self )

	self:startHistoryRecord();

	-- Unanchor all the items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.Anchored = false;
		Item.Velocity = Vector3.new( 0, 0, 0 );
		Item.RotVelocity = Vector3.new( 0, 0, 0 );
		Item:MakeJoints();
	end;

	self:finishHistoryRecord();

end;

Tools.Anchor.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTAnchorToolGUI" ):Clone();
		Container.Parent = UI;

		-- Change the anchor status when the button is clicked
		Container.Status.Anchored.Button.MouseButton1Down:connect( function ()
			self:anchor();
		end );

		Container.Status.Unanchored.Button.MouseButton1Down:connect( function ()
			self:unanchor();
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Anchor.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	local GUI = self.GUI;

	if self.State.anchored == nil then
		GUI.Status.Anchored.Background.Image = light_slanted_rectangle;
		GUI.Status.Anchored.SelectedIndicator.BackgroundTransparency = 1;
		GUI.Status.Unanchored.Background.Image = light_slanted_rectangle;
		GUI.Status.Unanchored.SelectedIndicator.BackgroundTransparency = 1;

	elseif self.State.anchored == true then
		GUI.Status.Anchored.Background.Image = dark_slanted_rectangle;
		GUI.Status.Anchored.SelectedIndicator.BackgroundTransparency = 0;
		GUI.Status.Unanchored.Background.Image = light_slanted_rectangle;
		GUI.Status.Unanchored.SelectedIndicator.BackgroundTransparency = 1;

	elseif self.State.anchored == false then
		GUI.Status.Anchored.Background.Image = light_slanted_rectangle;
		GUI.Status.Anchored.SelectedIndicator.BackgroundTransparency = 1;
		GUI.Status.Unanchored.Background.Image = dark_slanted_rectangle;
		GUI.Status.Unanchored.SelectedIndicator.BackgroundTransparency = 0;

	end;

end;

Tools.Anchor.hideGUI = function ( self )

	-- Hide the GUI if it exists
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Anchor.Listeners.Unequipped = function ()

	local self = Tools.Anchor;

	-- Stop the update loop
	if self.Updater then
		self.Updater();
		self.Updater = nil;
	end;

	-- Hide the GUI
	self:hideGUI();

	-- Clear out any temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of the selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Anchor.Loaded = true;
end))
LocalScript76.Disabled = true
LocalScript77.Name = "BTCollisionTool"
LocalScript77.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript77,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Collision tool
------------------------------------------

-- Create the tool
Tools.Collision = {};

-- Create structures to hold data that the tool needs
Tools.Collision.Connections = {};

Tools.Collision.State = {
	["colliding"] = nil;
};

Tools.Collision.Listeners = {};

-- Define the color of the tool
Tools.Collision.Color = BrickColor.new( "Really black" );

-- Start adding functionality to the tool
Tools.Collision.Listeners.Equipped = function ()

	local self = Tools.Collision;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Update the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.Updater = function ()
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the collision status of every item in the selection
				local colliding = nil;
				for item_index, Item in pairs( Selection.Items ) do

					-- Set the first values for the first item
					if item_index == 1 then
						colliding = Item.CanCollide;

					-- Otherwise, compare them and set them to `nil` if they're not identical
					else
						if colliding ~= Item.CanCollide then
							colliding = nil;
						end;
					end;

				end;

				self.State.colliding = colliding;

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

			end;

		end;

	end )();

	-- Listen for the Enter button to be pressed to toggle collision
	self.Connections.EnterButtonListener = Mouse.KeyDown:connect( function ( key )

		local key = key:lower();
		local key_code = key:byte();

		-- If the Enter button is pressed
		if key_code == 13 then

			if self.State.colliding == true then
				self:disable();

			elseif self.State.colliding == false then
				self:enable();

			elseif self.State.colliding == nil then
				self:enable();

			end;

		end;

	end );

end;

Tools.Collision.startHistoryRecord = function ( self )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( Selection.Items );
		initial_collide = {};
		terminal_collide = {};
		initial_cframe = {};
		terminal_cframe = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.CanCollide = self.initial_collide[Target];
					Target.CFrame = self.initial_cframe[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Target.CanCollide = self.terminal_collide[Target];
					Target.CFrame = self.terminal_cframe[Target];
					Target:MakeJoints();
					Selection:add( Target );
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_collide[Item] = Item.CanCollide;
			self.State.HistoryRecord.initial_cframe[Item] = Item.CFrame;
		end;
	end;

end;

Tools.Collision.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_collide[Item] = Item.CanCollide;
			self.State.HistoryRecord.terminal_cframe[Item] = Item.CFrame;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Collision.enable = function ( self )

	self:startHistoryRecord();

	-- Enable collision for all the items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.CanCollide = true;
		Item:MakeJoints();
	end;

	self:finishHistoryRecord();

end;

Tools.Collision.disable = function ( self )

	self:startHistoryRecord();

	-- Disable collision for all the items in the selection
	for _, Item in pairs( Selection.Items ) do
		Item.CanCollide = false;
		Item:MakeJoints();
	end;

	self:finishHistoryRecord();

end;

Tools.Collision.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTCollisionToolGUI" ):Clone();
		Container.Parent = UI;

		Container.Status.On.Button.MouseButton1Down:connect( function ()
			self:enable();
		end );

		Container.Status.Off.Button.MouseButton1Down:connect( function ()
			self:disable();
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Collision.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	local GUI = self.GUI;

	if self.State.colliding == nil then
		GUI.Status.On.Background.Image = light_slanted_rectangle;
		GUI.Status.On.SelectedIndicator.BackgroundTransparency = 1;
		GUI.Status.Off.Background.Image = light_slanted_rectangle;
		GUI.Status.Off.SelectedIndicator.BackgroundTransparency = 1;

	elseif self.State.colliding == true then
		GUI.Status.On.Background.Image = dark_slanted_rectangle;
		GUI.Status.On.SelectedIndicator.BackgroundTransparency = 0;
		GUI.Status.Off.Background.Image = light_slanted_rectangle;
		GUI.Status.Off.SelectedIndicator.BackgroundTransparency = 1;

	elseif self.State.colliding == false then
		GUI.Status.On.Background.Image = light_slanted_rectangle;
		GUI.Status.On.SelectedIndicator.BackgroundTransparency = 1;
		GUI.Status.Off.Background.Image = dark_slanted_rectangle;
		GUI.Status.Off.SelectedIndicator.BackgroundTransparency = 0;

	end;

end;

Tools.Collision.hideGUI = function ( self )

	-- Hide the GUI if it exists
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Collision.Listeners.Unequipped = function ()

	local self = Tools.Collision;

	-- Stop the update loop
	if self.Updater then
		self.Updater();
		self.Updater = nil;
	end;

	-- Hide the GUI
	self:hideGUI();

	-- Clear out any temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of the selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Collision.Loaded = true;
end))
LocalScript77.Disabled = true
LocalScript78.Name = "BTNewPartTool"
LocalScript78.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript78,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- New part tool
------------------------------------------

-- Create the tool
Tools.NewPart = {};

-- Define the tool's color
Tools.NewPart.Color = BrickColor.new( "Really black" );

-- Keep a container for temporary connections
Tools.NewPart.Connections = {};

-- Keep a container for state data
Tools.NewPart.State = {
	["Part"] = nil;
};

-- Maintain a container for options
Tools.NewPart.Options = {
	["type"] = "normal"
};

-- Keep a container for platform event connections
Tools.NewPart.Listeners = {};

-- Start adding functionality to the tool
Tools.NewPart.Listeners.Equipped = function ()

	local self = Tools.NewPart;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Restore the type option
	self:changeType( self.Options.type );

end;

Tools.NewPart.Listeners.Unequipped = function ()

	local self = Tools.NewPart;

	-- Hide the GUI
	self:hideGUI();

	-- Disconnect temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.NewPart.Listeners.Button1Down = function ()

	local self = Tools.NewPart;

	local NewPart;

	-- Create the new part of type `self.Options.type`
	if self.Options.type == "normal" then
		NewPart = Instance.new( "Part", Services.Workspace );
		NewPart.FormFactor = "Custom";
		NewPart.Size = Vector3.new( 4, 1, 2 );
	elseif self.Options.type == "truss" then
		NewPart = Instance.new( "TrussPart", Services.Workspace );
	elseif self.Options.type == "wedge" then
		NewPart = Instance.new( "WedgePart", Services.Workspace );
	elseif self.Options.type == "corner" then
		NewPart = Instance.new( "CornerWedgePart", Services.Workspace );
	elseif self.Options.type == "cylinder" then
		NewPart = Instance.new( "Part", Services.Workspace );
		NewPart.Shape = "Cylinder";
	elseif self.Options.type == "ball" then
		NewPart = Instance.new( "Part", Services.Workspace );
		NewPart.Shape = "Ball";
	elseif self.Options.type == "seat" then
		NewPart = Instance.new( "Seat", Services.Workspace );
	elseif self.Options.type == "vehicle seat" then
		NewPart = Instance.new( "VehicleSeat", Services.Workspace );
	elseif self.Options.type == "spawn" then
		NewPart = Instance.new( "SpawnLocation", Services.Workspace );
	end;
	NewPart.Anchored = true;

	-- Select the new part
	Selection:clear();
	Selection:add( NewPart );

	local HistoryRecord = {
		target = NewPart;
		apply = function ( self )
			Selection:clear();
			if self.target then
				self.target.Parent = Services.Workspace;
				Selection:add( self.target );
			end;
		end;
		unapply = function ( self )
			if self.target then
				self.target.Parent = nil;
			end;
		end;
	};
	History:add( HistoryRecord );

	-- Switch to the move tool and simulate clicking so
	-- that the user could easily position their new part
	equipTool( Tools.Move );
	Tools.Move.ManualTarget = NewPart;
	NewPart.CFrame = CFrame.new( Mouse.Hit.p );
	Tools.Move.Listeners.Button1Down();
	Tools.Move.Listeners.Move();

end;

Tools.NewPart.changeType = function ( self, new_type )
	self.Options.type = new_type;
	self.TypeDropdown:selectOption( new_type:upper() );
	if self.TypeDropdown.open then
		self.TypeDropdown:toggle();
	end;
end;

Tools.NewPart.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then

		local Container = Tool.Interfaces:WaitForChild( "BTNewPartToolGUI" ):Clone();
		Container.Parent = UI;

		local TypeDropdown = createDropdown();
		self.TypeDropdown = TypeDropdown;
		TypeDropdown.Frame.Parent = Container.TypeOption;
		TypeDropdown.Frame.Position = UDim2.new( 0, 70, 0, 0 );
		TypeDropdown.Frame.Size = UDim2.new( 0, 140, 0, 25 );

		TypeDropdown:addOption( "NORMAL" ).MouseButton1Up:connect( function ()
			self:changeType( "normal" );
		end );
		TypeDropdown:addOption( "TRUSS" ).MouseButton1Up:connect( function ()
			self:changeType( "truss" );
		end );
		TypeDropdown:addOption( "WEDGE" ).MouseButton1Up:connect( function ()
			self:changeType( "wedge" );
		end );
		TypeDropdown:addOption( "CORNER" ).MouseButton1Up:connect( function ()
			self:changeType( "corner" );
		end );
		TypeDropdown:addOption( "CYLINDER" ).MouseButton1Up:connect( function ()
			self:changeType( "cylinder" );
		end );
		TypeDropdown:addOption( "BALL" ).MouseButton1Up:connect( function ()
			self:changeType( "ball" );
		end );
		TypeDropdown:addOption( "SEAT" ).MouseButton1Up:connect( function ()
			self:changeType( "seat" );
		end );
		TypeDropdown:addOption( "VEHICLE SEAT" ).MouseButton1Up:connect( function ()
			self:changeType( "vehicle seat" );
		end );
		TypeDropdown:addOption( "SPAWN" ).MouseButton1Up:connect( function ()
			self:changeType( "spawn" );
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.NewPart.hideGUI = function ( self )

	-- Hide the GUI if it exists already
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.NewPart.Loaded = true;
end))
LocalScript78.Disabled = true
LocalScript79.Name = "BTMeshTool"
LocalScript79.Parent = LocalScript69
table.insert(cors,sandbox(LocalScript79,function()
-- Load the main tool's core environment when it's ready
repeat wait() until (
	_G.BTCoreEnv and
	_G.BTCoreEnv[script.Parent.Parent] and
	_G.BTCoreEnv[script.Parent.Parent].CoreReady
);
setfenv( 1, _G.BTCoreEnv[script.Parent.Parent] );

------------------------------------------
-- Mesh tool
------------------------------------------

-- Create the tool
Tools.Mesh = {};

-- Define the tool's color
Tools.Mesh.Color = BrickColor.new( "Bright violet" );

-- Keep a container for state data
Tools.Mesh.State = {};

-- Keep a container for temporary connections
Tools.Mesh.Connections = {};

-- Keep a container for platform event connections
Tools.Mesh.Listeners = {};

-- Start adding functionality to the tool
Tools.Mesh.Listeners.Equipped = function ()

	local self = Tools.Mesh;

	-- Change the color of selection boxes temporarily
	self.State.PreviousSelectionBoxColor = SelectionBoxColor;
	SelectionBoxColor = self.Color;
	updateSelectionBoxColor();

	-- Reveal the GUI
	self:showGUI();

	-- Update the GUI regularly
	coroutine.wrap( function ()
		updater_on = true;

		-- Provide a function to stop the loop
		self.stopGUIUpdater = function ( self )
			updater_on = false;
		end;

		while wait( 0.1 ) and updater_on do

			-- Make sure the tool's equipped
			if CurrentTool == self then

				-- Update the GUI if it's visible
				if self.GUI and self.GUI.Visible then
					self:updateGUI();
				end;

			end;

		end;

	end )();

end;

Tools.Mesh.Listeners.Unequipped = function ()

	local self = Tools.Mesh;

	-- Stop the GUI updater
	self:stopGUIUpdater();

	-- Hide the GUI
	self:hideGUI();

	-- Disconnect temporary connections
	for connection_index, Connection in pairs( self.Connections ) do
		Connection:disconnect();
		self.Connections[connection_index] = nil;
	end;

	-- Restore the original color of selection boxes
	SelectionBoxColor = self.State.PreviousSelectionBoxColor;
	updateSelectionBoxColor();

end;

Tools.Mesh.TypeDropdownLabels = {
	[Enum.MeshType.Brick] = "BLOCK";
	[Enum.MeshType.Cylinder] = "CYLINDER";
	[Enum.MeshType.FileMesh] = "FILE";
	[Enum.MeshType.Head] = "HEAD";
	[Enum.MeshType.Sphere] = "SPHERE";
	[Enum.MeshType.Torso] = "TRAPEZOID";
	[Enum.MeshType.Wedge] = "WEDGE";
};

Tools.Mesh.changeType = function ( self, new_type )

	-- Apply type `new_type` to all the meshes in items from the selection
	local meshes = {};
	for _, Item in pairs( Selection.Items ) do
		local Mesh = _getChildOfClass( Item, "SpecialMesh" );
		if Mesh then
			table.insert( meshes, Mesh );
		end;
	end;

	self:startHistoryRecord( meshes );
	for _, Mesh in pairs( meshes ) do
		Mesh.MeshType = new_type;
	end;
	self:finishHistoryRecord();

	if self.TypeDropdown.open then
		self.TypeDropdown:toggle();
	end;

	self:finishHistoryRecord();

end;

Tools.Mesh.updateGUI = function ( self )

	-- Make sure the GUI exists
	if not self.GUI then
		return;
	end;

	local GUI = self.GUI;

	if #Selection.Items > 0 then

		local meshes = {};
		for _, Item in pairs( Selection.Items ) do
			local Mesh = _getChildOfClass( Item, "SpecialMesh" );
			if Mesh then
				table.insert( meshes, Mesh );
			end;
		end;

		local show_add, show_remove, show_mesh_id;
		local mesh_type, mesh_scale_x, mesh_scale_y, mesh_scale_z, mesh_id, mesh_texture, mesh_tint_r, mesh_tint_g, mesh_tint_b;

		-- If every item has a mesh
		if #meshes == #Selection.Items then
			show_add = false;
			show_remove = true;

		-- If no item has a mesh
		elseif #meshes == 0 then
			show_add = true;
			show_remove = false;

		-- If some items have a mesh
		else
			show_add = true;
			show_remove = true;
		end;

		-- If there are meshes
		if #meshes > 0 then
			show_type = true;
			for mesh_index, Mesh in pairs( meshes ) do

				-- Set the start values for later comparison
				if mesh_index == 1 then
					mesh_type = Mesh.MeshType;
					mesh_scale_x, mesh_scale_y, mesh_scale_z = Mesh.Scale.x, Mesh.Scale.y, Mesh.Scale.z;
					mesh_id = Mesh.MeshId:lower();
					mesh_texture = Mesh.TextureId:lower();
					mesh_tint_r, mesh_tint_g, mesh_tint_b = Mesh.VertexColor.x, Mesh.VertexColor.y, Mesh.VertexColor.z;

				-- Set the values to `nil` if they vary across the selection
				else
					if mesh_type ~= Mesh.MeshType then
						mesh_type = nil;
					end;
					if mesh_scale_x ~= Mesh.Scale.x then
						mesh_scale_x = nil;
					end;
					if mesh_scale_y ~= Mesh.Scale.y then
						mesh_scale_y = nil;
					end;
					if mesh_scale_z ~= Mesh.Scale.z then
						mesh_scale_z = nil;
					end;
					if mesh_id ~= Mesh.MeshId:lower() then
						mesh_id = nil;
					end;
					if mesh_texture ~= Mesh.TextureId:lower() then
						mesh_texture = nil;
					end;
					if mesh_tint_r ~= Mesh.VertexColor.x then
						mesh_tint_r = nil;
					end;
					if mesh_tint_g ~= Mesh.VertexColor.y then
						mesh_tint_g = nil;
					end;
					if mesh_tint_b ~= Mesh.VertexColor.z then
						mesh_tint_b = nil;
					end;
				end;

				-- If there's a FileMesh around here, note that
				if Mesh.MeshType == Enum.MeshType.FileMesh then
					show_mesh_id = true;
				end;

			end;

			self.State.mesh_tint = ( mesh_tint_r and mesh_tint_g and mesh_tint_b ) and Color3.new( mesh_tint_r, mesh_tint_g, mesh_tint_b ) or nil;

			if show_mesh_id and show_add and show_remove then
				self.GUI.AddButton.Visible = true;
				self.GUI.RemoveButton.Visible = true;
				self.GUI.MeshIDOption.Visible = true;
				self.GUI.TextureIDOption.Visible = true;
				self.GUI.ScaleOption.Visible = true;
				self.GUI.TintOption.Visible = true;
				self.GUI.TypeOption.Visible = true;
				self.GUI.TypeOption.Position = UDim2.new( 0, 14, 0, 65 );
				self.GUI.ScaleOption.Position = UDim2.new( 0, 0, 0, 100 );
				self.GUI.MeshIDOption.Position = UDim2.new( 0, 14, 0, 135 );
				self.GUI.TextureIDOption.Position = UDim2.new( 0, 14, 0, 165 );
				self.GUI.TintOption.Position = UDim2.new( 0, 0, 0, 200 );
				self.GUI.Size = UDim2.new( 0, 200, 0, 265 );
			elseif show_mesh_id and not show_add and show_remove then
				self.GUI.AddButton.Visible = false;
				self.GUI.RemoveButton.Visible = true;
				self.GUI.MeshIDOption.Visible = true;
				self.GUI.TextureIDOption.Visible = true;
				self.GUI.ScaleOption.Visible = true;
				self.GUI.TintOption.Visible = true;
				self.GUI.TypeOption.Visible = true;
				self.GUI.TypeOption.Position = UDim2.new( 0, 14, 0, 30 );
				self.GUI.ScaleOption.Position = UDim2.new( 0, 0, 0, 65 );
				self.GUI.MeshIDOption.Position = UDim2.new( 0, 14, 0, 100 );
				self.GUI.TextureIDOption.Position = UDim2.new( 0, 14, 0, 130 );
				self.GUI.TintOption.Position = UDim2.new( 0, 0, 0, 165 );
				self.GUI.Size = UDim2.new( 0, 200, 0, 230 );

			elseif not show_mesh_id and show_add and show_remove then
				self.GUI.AddButton.Visible = true;
				self.GUI.RemoveButton.Visible = true;
				self.GUI.MeshIDOption.Visible = false;
				self.GUI.TextureIDOption.Visible = false;
				self.GUI.ScaleOption.Visible = true;
				self.GUI.TintOption.Visible = false;
				self.GUI.TypeOption.Visible = true;
				self.GUI.TypeOption.Position = UDim2.new( 0, 14, 0, 65 );
				self.GUI.ScaleOption.Position = UDim2.new( 0, 0, 0, 100 );
				self.GUI.Size = UDim2.new( 0, 200, 0, 165 );
			elseif not show_mesh_id and not show_add and show_remove then
				self.GUI.AddButton.Visible = false;
				self.GUI.RemoveButton.Visible = true;
				self.GUI.MeshIDOption.Visible = false;
				self.GUI.TextureIDOption.Visible = false;
				self.GUI.ScaleOption.Visible = true;
				self.GUI.TintOption.Visible = false;
				self.GUI.TypeOption.Visible = true;
				self.GUI.TypeOption.Position = UDim2.new( 0, 14, 0, 30 );
				self.GUI.ScaleOption.Position = UDim2.new( 0, 0, 0, 65 );
				self.GUI.Size = UDim2.new( 0, 200, 0, 130 );
			end;

			-- Update the values shown on the GUI
			if not self.State.mesh_id_focused then
				self.GUI.MeshIDOption.TextBox.Text = mesh_id and ( mesh_id:match( "%?id=([0-9]+)" ) or "" ) or "*";
			end;
			if not self.State.texture_id_focused then
				self.GUI.TextureIDOption.TextBox.Text = mesh_texture and ( mesh_texture:match( "%?id=([0-9]+)" ) or "" ) or "*";
			end;
			self.TypeDropdown:selectOption( mesh_type and self.TypeDropdownLabels[mesh_type] or "*" );
			if not self.State.scale_x_focused then
				self.GUI.ScaleOption.XInput.TextBox.Text = mesh_scale_x and _round( mesh_scale_x, 2 ) or "*";
			end;
			if not self.State.scale_y_focused then
				self.GUI.ScaleOption.YInput.TextBox.Text = mesh_scale_y and _round( mesh_scale_y, 2 ) or "*";
			end;
			if not self.State.scale_z_focused then
				self.GUI.ScaleOption.ZInput.TextBox.Text = mesh_scale_z and _round( mesh_scale_z, 2 ) or "*";
			end;
			if not self.State.tint_r_focused then
				self.GUI.TintOption.RInput.TextBox.Text = mesh_tint_r and _round( mesh_tint_r * 255, 0 ) or "*";
			end;
			if not self.State.tint_g_focused then
				self.GUI.TintOption.GInput.TextBox.Text = mesh_tint_g and _round( mesh_tint_g * 255, 0 ) or "*";
			end;
			if not self.State.tint_b_focused then
				self.GUI.TintOption.BInput.TextBox.Text = mesh_tint_b and _round( mesh_tint_b * 255, 0 ) or "*";
			end;

		-- If there are no meshes
		else
			self.GUI.AddButton.Visible = true;
			self.GUI.RemoveButton.Visible = false;
			self.GUI.MeshIDOption.Visible = false;
			self.GUI.TextureIDOption.Visible = false;
			self.GUI.ScaleOption.Visible = false;
			self.GUI.TintOption.Visible = false;
			self.GUI.TypeOption.Visible = false;
			self.GUI.Size = UDim2.new( 0, 200, 0, 62 );
		end;
		self.GUI.SelectNote.Visible = false;

	-- Show a note that says to select something
	else
		self.GUI.AddButton.Visible = false;
		self.GUI.RemoveButton.Visible = false;
		self.GUI.MeshIDOption.Visible = false;
		self.GUI.TextureIDOption.Visible = false;
		self.GUI.ScaleOption.Visible = false;
		self.GUI.TintOption.Visible = false;
		self.GUI.TypeOption.Visible = false;
		self.GUI.SelectNote.Visible = true;
		self.GUI.Size = UDim2.new( 0, 200, 0, 55 );
	end;

end;

Tools.Mesh.showGUI = function ( self )

	-- Initialize the GUI if it's not ready yet
	if not self.GUI then
		local Container = Tool.Interfaces:WaitForChild( "BTMeshToolGUI" ):Clone();
		Container.Parent = UI;

		-- Add functionality to the add/remove buttons
		Container.AddButton.Button.MouseButton1Up:connect( function ()
			self:addMesh();
		end );
		Container.RemoveButton.Button.MouseButton1Up:connect( function ()
			self:removeMesh();
		end );

		-- Add the type dropdown
		local TypeDropdown = createDropdown();
		self.TypeDropdown = TypeDropdown;
		TypeDropdown.Frame.Parent = Container.TypeOption;
		TypeDropdown.Frame.Position = UDim2.new( 0, 40, 0, 0 );
		TypeDropdown.Frame.Size = UDim2.new( 1, -40, 0, 25 );
		TypeDropdown:addOption( "BLOCK" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.Brick );
		end );
		TypeDropdown:addOption( "CYLINDER" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.Cylinder );
		end );
		TypeDropdown:addOption( "FILE" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.FileMesh );
		end );
		TypeDropdown:addOption( "HEAD" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.Head );
		end );
		TypeDropdown:addOption( "SPHERE" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.Sphere );
		end );
		TypeDropdown:addOption( "TRAPEZOID" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.Torso );
		end );
		TypeDropdown:addOption( "WEDGE" ).MouseButton1Up:connect( function ()
			self:changeType( Enum.MeshType.Wedge );
		end );

		-- Add functionality to the scale inputs
		Container.ScaleOption.XInput.TextButton.MouseButton1Down:connect( function ()
			self.State.scale_x_focused = true;
			Container.ScaleOption.XInput.TextBox:CaptureFocus();
		end );
		Container.ScaleOption.XInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.ScaleOption.XInput.TextBox.Text );
			if potential_new then
				self:changeScale( 'x', potential_new );
			end;
			self.State.scale_x_focused = false;
		end );

		Container.ScaleOption.YInput.TextButton.MouseButton1Down:connect( function ()
			self.State.scale_y_focused = true;
			Container.ScaleOption.YInput.TextBox:CaptureFocus();
		end );
		Container.ScaleOption.YInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.ScaleOption.YInput.TextBox.Text );
			if potential_new then
				self:changeScale( 'y', potential_new );
			end;
			self.State.scale_y_focused = false;
		end );

		Container.ScaleOption.ZInput.TextButton.MouseButton1Down:connect( function ()
			self.State.scale_z_focused = true;
			Container.ScaleOption.ZInput.TextBox:CaptureFocus();
		end );
		Container.ScaleOption.ZInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.ScaleOption.ZInput.TextBox.Text );
			if potential_new then
				self:changeScale( 'z', potential_new );
			end;
			self.State.scale_z_focused = false;
		end );

		-- Add functionality to the mesh/texture ID inputs
		Container.MeshIDOption.TextButton.MouseButton1Down:connect( function ()
			self.State.mesh_id_focused = true;
			Container.MeshIDOption.TextBox:CaptureFocus();
		end );
		Container.MeshIDOption.TextBox.FocusLost:connect( function ( enter_pressed )
			local input = Container.MeshIDOption.TextBox.Text;
			local potential_new = tonumber( input ) or input:lower():match( "%?id=([0-9]+)" );
			if potential_new then
				self:changeMesh( potential_new );
			end;
			self.State.mesh_id_focused = false;
		end );

		Container.TextureIDOption.TextButton.MouseButton1Down:connect( function ()
			self.State.texture_id_focused = true;
			Container.TextureIDOption.TextBox:CaptureFocus();
		end );
		Container.TextureIDOption.TextBox.FocusLost:connect( function ( enter_pressed )
			local input = Container.TextureIDOption.TextBox.Text;
			local potential_new = tonumber( input ) or input:lower():match( "%?id=([0-9]+)" );
			if potential_new then
				self:changeTexture( potential_new );
			end;
			self.State.texture_id_focused = false;
		end );

		-- Add functionality to the tint inputs
		Container.TintOption.RInput.TextButton.MouseButton1Down:connect( function ()
			self.State.tint_r_focused = true;
			Container.TintOption.RInput.TextBox:CaptureFocus();
		end );
		Container.TintOption.RInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.TintOption.RInput.TextBox.Text );
			if potential_new then
				if potential_new > 255 then
					potential_new = 255;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:changeTint( 'r', potential_new / 255 );
			end;
			self.State.tint_r_focused = false;
		end );

		Container.TintOption.GInput.TextButton.MouseButton1Down:connect( function ()
			self.State.tint_g_focused = true;
			Container.TintOption.GInput.TextBox:CaptureFocus();
		end );
		Container.TintOption.GInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.TintOption.GInput.TextBox.Text );
			if potential_new then
				if potential_new > 255 then
					potential_new = 255;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:changeTint( 'g', potential_new / 255 );
			end;
			self.State.tint_g_focused = false;
		end );

		Container.TintOption.BInput.TextButton.MouseButton1Down:connect( function ()
			self.State.tint_b_focused = true;
			Container.TintOption.BInput.TextBox:CaptureFocus();
		end );
		Container.TintOption.BInput.TextBox.FocusLost:connect( function ( enter_pressed )
			local potential_new = tonumber( Container.TintOption.BInput.TextBox.Text );
			if potential_new then
				if potential_new > 255 then
					potential_new = 255;
				elseif potential_new < 0 then
					potential_new = 0;
				end;
				self:changeTint( 'b', potential_new / 255 );
			end;
			self.State.tint_b_focused = false;
		end );

		Container.TintOption.HSVPicker.MouseButton1Up:connect( function ()
			ColorPicker:start( function ( ... )
				local args = { ... };
				-- If a color was picked, change the spotlights' color
				-- to the selected color
				if #args == 3 then
					local meshes = {};
					for _, Item in pairs( Selection.Items ) do
						local Mesh = _getChildOfClass( Item, "SpecialMesh" );
						if Mesh then
							table.insert( meshes, Mesh );
						end;
					end;
					self:startHistoryRecord( meshes );
					for _, Mesh in pairs( meshes ) do
						Mesh.VertexColor = Vector3.new( _HSVToRGB( ... ) );
					end;
					self:finishHistoryRecord();
				end;
			end, self.State.mesh_tint );
		end );

		self.GUI = Container;
	end;

	-- Reveal the GUI
	self.GUI.Visible = true;

end;

Tools.Mesh.addMesh = function ( self )

	local HistoryRecord = {
		apply = function ( self )
			Selection:clear();
			for _, Mesh in pairs( self.meshes ) do
				Mesh.Parent = self.mesh_parents[Mesh];
				Selection:add( Mesh.Parent );
			end;
		end;
		unapply = function ( self )
			Selection:clear();
			for _, Mesh in pairs( self.meshes ) do
				Selection:add( Mesh.Parent );
				Mesh.Parent = nil;
			end;
		end;
	};

	-- Add meshes to all the items from the selection that
	-- don't already have one
	local meshes = {};
	local mesh_parents = {};
	for _, Item in pairs( Selection.Items ) do
		local Mesh = _getChildOfClass( Item, "SpecialMesh" );
		if not Mesh then
			local Mesh = RbxUtility.Create "SpecialMesh" {
				Parent = Item;
				MeshType = Enum.MeshType.Brick;
			};
			table.insert( meshes, Mesh );
			mesh_parents[Mesh] = Item;
		end;
	end;

	HistoryRecord.meshes = meshes;
	HistoryRecord.mesh_parents = mesh_parents;
	History:add( HistoryRecord );

end;

Tools.Mesh.removeMesh = function ( self )

	local HistoryRecord = {
		apply = function ( self )
			Selection:clear();
			for _, Mesh in pairs( self.meshes ) do
				Selection:add( Mesh.Parent );
				Mesh.Parent = nil;
			end;
		end;
		unapply = function ( self )
			Selection:clear();
			for _, Mesh in pairs( self.meshes ) do
				Mesh.Parent = self.mesh_parents[Mesh];
				Selection:add( Mesh.Parent );
			end;
		end;
	};

	local meshes = {};
	local mesh_parents = {};
	-- Remove meshes from all the selected items
	for _, Item in pairs( Selection.Items ) do
		local meshes_found = _getChildrenOfClass( Item, "SpecialMesh" );
		for _, Mesh in pairs( meshes_found ) do
			table.insert( meshes, Mesh );
			mesh_parents[Mesh] = Mesh.Parent;
			Mesh.Parent = nil;
		end;
	end;

	HistoryRecord.meshes = meshes;
	HistoryRecord.mesh_parents = mesh_parents;
	History:add( HistoryRecord );

end;

Tools.Mesh.startHistoryRecord = function ( self, meshes )

	if self.State.HistoryRecord then
		self.State.HistoryRecord = nil;
	end;

	-- Create a history record
	self.State.HistoryRecord = {
		targets = _cloneTable( meshes );
		initial_type = {};
		terminal_type = {};
		initial_mesh = {};
		terminal_mesh = {};
		initial_texture = {};
		terminal_texture = {};
		initial_scale = {};
		terminal_scale = {};
		initial_tint = {};
		terminal_tint = {};
		unapply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Selection:add( Target.Parent );
					Target.MeshType = self.initial_type[Target];
					Target.MeshId = self.initial_mesh[Target];
					Target.TextureId = self.initial_texture[Target];
					Target.Scale = self.initial_scale[Target];
					Target.VertexColor = self.initial_tint[Target];
				end;
			end;
		end;
		apply = function ( self )
			Selection:clear();
			for _, Target in pairs( self.targets ) do
				if Target then
					Selection:add( Target.Parent );
					Target.MeshType = self.terminal_type[Target];
					Target.MeshId = self.terminal_mesh[Target];
					Target.TextureId = self.terminal_texture[Target];
					Target.Scale = self.terminal_scale[Target];
					Target.VertexColor = self.terminal_tint[Target];
				end;
			end;
		end;
	};
	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.initial_type[Item] = Item.MeshType;
			self.State.HistoryRecord.initial_mesh[Item] = Item.MeshId;
			self.State.HistoryRecord.initial_texture[Item] = Item.TextureId;
			self.State.HistoryRecord.initial_scale[Item] = Item.Scale;
			self.State.HistoryRecord.initial_tint[Item] = Item.VertexColor;
		end;
	end;

end;

Tools.Mesh.finishHistoryRecord = function ( self )

	if not self.State.HistoryRecord then
		return;
	end;

	for _, Item in pairs( self.State.HistoryRecord.targets ) do
		if Item then
			self.State.HistoryRecord.terminal_type[Item] = Item.MeshType;
			self.State.HistoryRecord.terminal_mesh[Item] = Item.MeshId;
			self.State.HistoryRecord.terminal_texture[Item] = Item.TextureId;
			self.State.HistoryRecord.terminal_scale[Item] = Item.Scale;
			self.State.HistoryRecord.terminal_tint[Item] = Item.VertexColor;
		end;
	end;
	History:add( self.State.HistoryRecord );
	self.State.HistoryRecord = nil;

end;

Tools.Mesh.changeMesh = function ( self, mesh_id )

	local meshes = {};

	for _, Item in pairs( Selection.Items ) do
		local Mesh = _getChildOfClass( Item, "SpecialMesh" );
		if Mesh then
			table.insert( meshes, Mesh );
		end;
	end;
	self:startHistoryRecord( meshes );
	for _, Mesh in pairs( meshes ) do
		Mesh.MeshId = "http://www.roblox.com/asset/?id=" .. mesh_id;
	end;
	self:finishHistoryRecord();

end;

Tools.Mesh.changeTexture = function ( self, texture_id )

	local meshes = {};

	for _, Item in pairs( Selection.Items ) do
		local Mesh = _getChildOfClass( Item, "SpecialMesh" );
		if Mesh then
			table.insert( meshes, Mesh );
		end;
	end;
	self:startHistoryRecord( meshes );
	for _, Mesh in pairs( meshes ) do
		Mesh.TextureId = "http://www.roblox.com/asset/?id=" .. texture_id;
	end;
	self:finishHistoryRecord();

end;

Tools.Mesh.changeScale = function ( self, component, new_value )

	local meshes = {};

	for _, Item in pairs( Selection.Items ) do
		local Mesh = _getChildOfClass( Item, "SpecialMesh" );
		if Mesh then
			table.insert( meshes, Mesh );
		end;
	end;

	self:startHistoryRecord( meshes );
	for _, Mesh in pairs( meshes ) do
		Mesh.Scale = Vector3.new(
			component == 'x' and new_value or Mesh.Scale.x,
			component == 'y' and new_value or Mesh.Scale.y,
			component == 'z' and new_value or Mesh.Scale.z
		);
	end;
	self:finishHistoryRecord();

end;

Tools.Mesh.changeTint = function ( self, component, new_value )

	local meshes = {};

	for _, Item in pairs( Selection.Items ) do
		local Mesh = _getChildOfClass( Item, "SpecialMesh" );
		if Mesh then
			table.insert( meshes, Mesh );
		end;
	end;

	self:startHistoryRecord( meshes );
	for _, Mesh in pairs( meshes ) do
		Mesh.VertexColor = Vector3.new(
			component == 'r' and new_value or Mesh.VertexColor.x,
			component == 'g' and new_value or Mesh.VertexColor.y,
			component == 'b' and new_value or Mesh.VertexColor.z
		);
	end;
	self:finishHistoryRecord();

end;

Tools.Mesh.hideGUI = function ( self )

	-- Hide the GUI if it exists already
	if self.GUI then
		self.GUI.Visible = false;
	end;

end;

Tools.Mesh.Loaded = true;
end))
LocalScript79.Disabled = true
